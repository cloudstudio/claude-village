import {
  Color3,
  Color4,
  CreateDisc,
  CreateLines,
  CreatePlane,
  DirectionalLight,
  Engine,
  FreeCamera,
  MaterialPluginBase,
  Mesh,
  Octree,
  OctreeBlock,
  OctreeSceneComponent,
  RawTexture2DArray,
  Scene,
  ScenePerformancePriority,
  StandardMaterial,
  Texture,
  TransformNode,
  Vector3,
  VertexData,
  __commonJS,
  __export,
  __publicField,
  __toESM
} from "./chunk-N5PUBLJK.js";

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter5() {
      EventEmitter5.init.call(this);
    }
    module.exports = EventEmitter5;
    module.exports.once = once;
    EventEmitter5.EventEmitter = EventEmitter5;
    EventEmitter5.prototype._events = void 0;
    EventEmitter5.prototype._eventsCount = 0;
    EventEmitter5.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter5, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter5.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter5.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter5.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter5.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter5.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len2 = handler.length;
        var listeners = arrayClone(handler, len2);
        for (var i = 0; i < len2; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter5.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter5.prototype.on = EventEmitter5.prototype.addListener;
    EventEmitter5.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter5.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter5.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter5.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter5.prototype.off = EventEmitter5.prototype.removeListener;
    EventEmitter5.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter5.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter5.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter5.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter5.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter5.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy4 = new Array(n);
      for (var i = 0; i < n; ++i)
        copy4[i] = arr[i];
      return copy4;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/gl-vec3/epsilon.js
var require_epsilon = __commonJS({
  "node_modules/gl-vec3/epsilon.js"(exports, module) {
    module.exports = 1e-6;
  }
});

// node_modules/gl-vec3/create.js
var require_create = __commonJS({
  "node_modules/gl-vec3/create.js"(exports, module) {
    module.exports = create6;
    function create6() {
      var out = new Float32Array(3);
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      return out;
    }
  }
});

// node_modules/gl-vec3/clone.js
var require_clone = __commonJS({
  "node_modules/gl-vec3/clone.js"(exports, module) {
    module.exports = clone3;
    function clone3(a2) {
      var out = new Float32Array(3);
      out[0] = a2[0];
      out[1] = a2[1];
      out[2] = a2[2];
      return out;
    }
  }
});

// node_modules/gl-vec3/fromValues.js
var require_fromValues = __commonJS({
  "node_modules/gl-vec3/fromValues.js"(exports, module) {
    module.exports = fromValues3;
    function fromValues3(x, y, z) {
      var out = new Float32Array(3);
      out[0] = x;
      out[1] = y;
      out[2] = z;
      return out;
    }
  }
});

// node_modules/gl-vec3/normalize.js
var require_normalize = __commonJS({
  "node_modules/gl-vec3/normalize.js"(exports, module) {
    module.exports = normalize4;
    function normalize4(out, a2) {
      var x = a2[0], y = a2[1], z = a2[2];
      var len2 = x * x + y * y + z * z;
      if (len2 > 0) {
        len2 = 1 / Math.sqrt(len2);
        out[0] = a2[0] * len2;
        out[1] = a2[1] * len2;
        out[2] = a2[2] * len2;
      }
      return out;
    }
  }
});

// node_modules/gl-vec3/dot.js
var require_dot = __commonJS({
  "node_modules/gl-vec3/dot.js"(exports, module) {
    module.exports = dot4;
    function dot4(a2, b) {
      return a2[0] * b[0] + a2[1] * b[1] + a2[2] * b[2];
    }
  }
});

// node_modules/gl-vec3/angle.js
var require_angle = __commonJS({
  "node_modules/gl-vec3/angle.js"(exports, module) {
    module.exports = angle2;
    var fromValues3 = require_fromValues();
    var normalize4 = require_normalize();
    var dot4 = require_dot();
    function angle2(a2, b) {
      var tempA = fromValues3(a2[0], a2[1], a2[2]);
      var tempB = fromValues3(b[0], b[1], b[2]);
      normalize4(tempA, tempA);
      normalize4(tempB, tempB);
      var cosine = dot4(tempA, tempB);
      if (cosine > 1) {
        return 0;
      } else {
        return Math.acos(cosine);
      }
    }
  }
});

// node_modules/gl-vec3/copy.js
var require_copy = __commonJS({
  "node_modules/gl-vec3/copy.js"(exports, module) {
    module.exports = copy4;
    function copy4(out, a2) {
      out[0] = a2[0];
      out[1] = a2[1];
      out[2] = a2[2];
      return out;
    }
  }
});

// node_modules/gl-vec3/set.js
var require_set = __commonJS({
  "node_modules/gl-vec3/set.js"(exports, module) {
    module.exports = set3;
    function set3(out, x, y, z) {
      out[0] = x;
      out[1] = y;
      out[2] = z;
      return out;
    }
  }
});

// node_modules/gl-vec3/equals.js
var require_equals = __commonJS({
  "node_modules/gl-vec3/equals.js"(exports, module) {
    module.exports = equals3;
    var EPSILON2 = require_epsilon();
    function equals3(a2, b) {
      var a0 = a2[0];
      var a1 = a2[1];
      var a22 = a2[2];
      var b0 = b[0];
      var b1 = b[1];
      var b2 = b[2];
      return Math.abs(a0 - b0) <= EPSILON2 * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON2 * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON2 * Math.max(1, Math.abs(a22), Math.abs(b2));
    }
  }
});

// node_modules/gl-vec3/exactEquals.js
var require_exactEquals = __commonJS({
  "node_modules/gl-vec3/exactEquals.js"(exports, module) {
    module.exports = exactEquals3;
    function exactEquals3(a2, b) {
      return a2[0] === b[0] && a2[1] === b[1] && a2[2] === b[2];
    }
  }
});

// node_modules/gl-vec3/add.js
var require_add = __commonJS({
  "node_modules/gl-vec3/add.js"(exports, module) {
    module.exports = add3;
    function add3(out, a2, b) {
      out[0] = a2[0] + b[0];
      out[1] = a2[1] + b[1];
      out[2] = a2[2] + b[2];
      return out;
    }
  }
});

// node_modules/gl-vec3/subtract.js
var require_subtract = __commonJS({
  "node_modules/gl-vec3/subtract.js"(exports, module) {
    module.exports = subtract2;
    function subtract2(out, a2, b) {
      out[0] = a2[0] - b[0];
      out[1] = a2[1] - b[1];
      out[2] = a2[2] - b[2];
      return out;
    }
  }
});

// node_modules/gl-vec3/sub.js
var require_sub = __commonJS({
  "node_modules/gl-vec3/sub.js"(exports, module) {
    module.exports = require_subtract();
  }
});

// node_modules/gl-vec3/multiply.js
var require_multiply = __commonJS({
  "node_modules/gl-vec3/multiply.js"(exports, module) {
    module.exports = multiply2;
    function multiply2(out, a2, b) {
      out[0] = a2[0] * b[0];
      out[1] = a2[1] * b[1];
      out[2] = a2[2] * b[2];
      return out;
    }
  }
});

// node_modules/gl-vec3/mul.js
var require_mul = __commonJS({
  "node_modules/gl-vec3/mul.js"(exports, module) {
    module.exports = require_multiply();
  }
});

// node_modules/gl-vec3/divide.js
var require_divide = __commonJS({
  "node_modules/gl-vec3/divide.js"(exports, module) {
    module.exports = divide2;
    function divide2(out, a2, b) {
      out[0] = a2[0] / b[0];
      out[1] = a2[1] / b[1];
      out[2] = a2[2] / b[2];
      return out;
    }
  }
});

// node_modules/gl-vec3/div.js
var require_div = __commonJS({
  "node_modules/gl-vec3/div.js"(exports, module) {
    module.exports = require_divide();
  }
});

// node_modules/gl-vec3/min.js
var require_min = __commonJS({
  "node_modules/gl-vec3/min.js"(exports, module) {
    module.exports = min2;
    function min2(out, a2, b) {
      out[0] = Math.min(a2[0], b[0]);
      out[1] = Math.min(a2[1], b[1]);
      out[2] = Math.min(a2[2], b[2]);
      return out;
    }
  }
});

// node_modules/gl-vec3/max.js
var require_max = __commonJS({
  "node_modules/gl-vec3/max.js"(exports, module) {
    module.exports = max2;
    function max2(out, a2, b) {
      out[0] = Math.max(a2[0], b[0]);
      out[1] = Math.max(a2[1], b[1]);
      out[2] = Math.max(a2[2], b[2]);
      return out;
    }
  }
});

// node_modules/gl-vec3/floor.js
var require_floor = __commonJS({
  "node_modules/gl-vec3/floor.js"(exports, module) {
    module.exports = floor2;
    function floor2(out, a2) {
      out[0] = Math.floor(a2[0]);
      out[1] = Math.floor(a2[1]);
      out[2] = Math.floor(a2[2]);
      return out;
    }
  }
});

// node_modules/gl-vec3/ceil.js
var require_ceil = __commonJS({
  "node_modules/gl-vec3/ceil.js"(exports, module) {
    module.exports = ceil2;
    function ceil2(out, a2) {
      out[0] = Math.ceil(a2[0]);
      out[1] = Math.ceil(a2[1]);
      out[2] = Math.ceil(a2[2]);
      return out;
    }
  }
});

// node_modules/gl-vec3/round.js
var require_round = __commonJS({
  "node_modules/gl-vec3/round.js"(exports, module) {
    module.exports = round3;
    function round3(out, a2) {
      out[0] = Math.round(a2[0]);
      out[1] = Math.round(a2[1]);
      out[2] = Math.round(a2[2]);
      return out;
    }
  }
});

// node_modules/gl-vec3/scale.js
var require_scale = __commonJS({
  "node_modules/gl-vec3/scale.js"(exports, module) {
    module.exports = scale3;
    function scale3(out, a2, b) {
      out[0] = a2[0] * b;
      out[1] = a2[1] * b;
      out[2] = a2[2] * b;
      return out;
    }
  }
});

// node_modules/gl-vec3/scaleAndAdd.js
var require_scaleAndAdd = __commonJS({
  "node_modules/gl-vec3/scaleAndAdd.js"(exports, module) {
    module.exports = scaleAndAdd2;
    function scaleAndAdd2(out, a2, b, scale3) {
      out[0] = a2[0] + b[0] * scale3;
      out[1] = a2[1] + b[1] * scale3;
      out[2] = a2[2] + b[2] * scale3;
      return out;
    }
  }
});

// node_modules/gl-vec3/distance.js
var require_distance = __commonJS({
  "node_modules/gl-vec3/distance.js"(exports, module) {
    module.exports = distance2;
    function distance2(a2, b) {
      var x = b[0] - a2[0], y = b[1] - a2[1], z = b[2] - a2[2];
      return Math.sqrt(x * x + y * y + z * z);
    }
  }
});

// node_modules/gl-vec3/dist.js
var require_dist = __commonJS({
  "node_modules/gl-vec3/dist.js"(exports, module) {
    module.exports = require_distance();
  }
});

// node_modules/gl-vec3/squaredDistance.js
var require_squaredDistance = __commonJS({
  "node_modules/gl-vec3/squaredDistance.js"(exports, module) {
    module.exports = squaredDistance2;
    function squaredDistance2(a2, b) {
      var x = b[0] - a2[0], y = b[1] - a2[1], z = b[2] - a2[2];
      return x * x + y * y + z * z;
    }
  }
});

// node_modules/gl-vec3/sqrDist.js
var require_sqrDist = __commonJS({
  "node_modules/gl-vec3/sqrDist.js"(exports, module) {
    module.exports = require_squaredDistance();
  }
});

// node_modules/gl-vec3/length.js
var require_length = __commonJS({
  "node_modules/gl-vec3/length.js"(exports, module) {
    module.exports = length4;
    function length4(a2) {
      var x = a2[0], y = a2[1], z = a2[2];
      return Math.sqrt(x * x + y * y + z * z);
    }
  }
});

// node_modules/gl-vec3/len.js
var require_len = __commonJS({
  "node_modules/gl-vec3/len.js"(exports, module) {
    module.exports = require_length();
  }
});

// node_modules/gl-vec3/squaredLength.js
var require_squaredLength = __commonJS({
  "node_modules/gl-vec3/squaredLength.js"(exports, module) {
    module.exports = squaredLength4;
    function squaredLength4(a2) {
      var x = a2[0], y = a2[1], z = a2[2];
      return x * x + y * y + z * z;
    }
  }
});

// node_modules/gl-vec3/sqrLen.js
var require_sqrLen = __commonJS({
  "node_modules/gl-vec3/sqrLen.js"(exports, module) {
    module.exports = require_squaredLength();
  }
});

// node_modules/gl-vec3/negate.js
var require_negate = __commonJS({
  "node_modules/gl-vec3/negate.js"(exports, module) {
    module.exports = negate2;
    function negate2(out, a2) {
      out[0] = -a2[0];
      out[1] = -a2[1];
      out[2] = -a2[2];
      return out;
    }
  }
});

// node_modules/gl-vec3/inverse.js
var require_inverse = __commonJS({
  "node_modules/gl-vec3/inverse.js"(exports, module) {
    module.exports = inverse2;
    function inverse2(out, a2) {
      out[0] = 1 / a2[0];
      out[1] = 1 / a2[1];
      out[2] = 1 / a2[2];
      return out;
    }
  }
});

// node_modules/gl-vec3/cross.js
var require_cross = __commonJS({
  "node_modules/gl-vec3/cross.js"(exports, module) {
    module.exports = cross2;
    function cross2(out, a2, b) {
      var ax = a2[0], ay = a2[1], az = a2[2], bx = b[0], by = b[1], bz = b[2];
      out[0] = ay * bz - az * by;
      out[1] = az * bx - ax * bz;
      out[2] = ax * by - ay * bx;
      return out;
    }
  }
});

// node_modules/gl-vec3/lerp.js
var require_lerp = __commonJS({
  "node_modules/gl-vec3/lerp.js"(exports, module) {
    module.exports = lerp3;
    function lerp3(out, a2, b, t) {
      var ax = a2[0], ay = a2[1], az = a2[2];
      out[0] = ax + t * (b[0] - ax);
      out[1] = ay + t * (b[1] - ay);
      out[2] = az + t * (b[2] - az);
      return out;
    }
  }
});

// node_modules/gl-vec3/random.js
var require_random = __commonJS({
  "node_modules/gl-vec3/random.js"(exports, module) {
    module.exports = random2;
    function random2(out, scale3) {
      scale3 = scale3 || 1;
      var r = Math.random() * 2 * Math.PI;
      var z = Math.random() * 2 - 1;
      var zScale = Math.sqrt(1 - z * z) * scale3;
      out[0] = Math.cos(r) * zScale;
      out[1] = Math.sin(r) * zScale;
      out[2] = z * scale3;
      return out;
    }
  }
});

// node_modules/gl-vec3/transformMat4.js
var require_transformMat4 = __commonJS({
  "node_modules/gl-vec3/transformMat4.js"(exports, module) {
    module.exports = transformMat42;
    function transformMat42(out, a2, m) {
      var x = a2[0], y = a2[1], z = a2[2], w = m[3] * x + m[7] * y + m[11] * z + m[15];
      w = w || 1;
      out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
      out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
      out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
      return out;
    }
  }
});

// node_modules/gl-vec3/transformMat3.js
var require_transformMat3 = __commonJS({
  "node_modules/gl-vec3/transformMat3.js"(exports, module) {
    module.exports = transformMat32;
    function transformMat32(out, a2, m) {
      var x = a2[0], y = a2[1], z = a2[2];
      out[0] = x * m[0] + y * m[3] + z * m[6];
      out[1] = x * m[1] + y * m[4] + z * m[7];
      out[2] = x * m[2] + y * m[5] + z * m[8];
      return out;
    }
  }
});

// node_modules/gl-vec3/transformQuat.js
var require_transformQuat = __commonJS({
  "node_modules/gl-vec3/transformQuat.js"(exports, module) {
    module.exports = transformQuat2;
    function transformQuat2(out, a2, q) {
      var x = a2[0], y = a2[1], z = a2[2], qx = q[0], qy = q[1], qz = q[2], qw = q[3];
      var tx = qy * z - qz * y;
      var ty = qz * x - qx * z;
      var tz = qx * y - qy * x;
      tx *= 2;
      ty *= 2;
      tz *= 2;
      out[0] = x + qw * tx + qy * tz - qz * ty;
      out[1] = y + qw * ty + qz * tx - qx * tz;
      out[2] = z + qw * tz + qx * ty - qy * tx;
      return out;
    }
  }
});

// node_modules/gl-vec3/rotateX.js
var require_rotateX = __commonJS({
  "node_modules/gl-vec3/rotateX.js"(exports, module) {
    module.exports = rotateX3;
    function rotateX3(out, a2, b, c) {
      var by = b[1];
      var bz = b[2];
      var py = a2[1] - by;
      var pz = a2[2] - bz;
      var sc = Math.sin(c);
      var cc = Math.cos(c);
      out[0] = a2[0];
      out[1] = by + py * cc - pz * sc;
      out[2] = bz + py * sc + pz * cc;
      return out;
    }
  }
});

// node_modules/gl-vec3/rotateY.js
var require_rotateY = __commonJS({
  "node_modules/gl-vec3/rotateY.js"(exports, module) {
    module.exports = rotateY3;
    function rotateY3(out, a2, b, c) {
      var bx = b[0];
      var bz = b[2];
      var px = a2[0] - bx;
      var pz = a2[2] - bz;
      var sc = Math.sin(c);
      var cc = Math.cos(c);
      out[0] = bx + pz * sc + px * cc;
      out[1] = a2[1];
      out[2] = bz + pz * cc - px * sc;
      return out;
    }
  }
});

// node_modules/gl-vec3/rotateZ.js
var require_rotateZ = __commonJS({
  "node_modules/gl-vec3/rotateZ.js"(exports, module) {
    module.exports = rotateZ3;
    function rotateZ3(out, a2, b, c) {
      var bx = b[0];
      var by = b[1];
      var px = a2[0] - bx;
      var py = a2[1] - by;
      var sc = Math.sin(c);
      var cc = Math.cos(c);
      out[0] = bx + px * cc - py * sc;
      out[1] = by + px * sc + py * cc;
      out[2] = a2[2];
      return out;
    }
  }
});

// node_modules/gl-vec3/forEach.js
var require_forEach = __commonJS({
  "node_modules/gl-vec3/forEach.js"(exports, module) {
    module.exports = forEach4;
    var vec = require_create()();
    function forEach4(a2, stride, offset, count, fn, arg) {
      var i, l;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l = Math.min(count * stride + offset, a2.length);
      } else {
        l = a2.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a2[i];
        vec[1] = a2[i + 1];
        vec[2] = a2[i + 2];
        fn(vec, vec, arg);
        a2[i] = vec[0];
        a2[i + 1] = vec[1];
        a2[i + 2] = vec[2];
      }
      return a2;
    }
  }
});

// node_modules/gl-vec3/index.js
var require_gl_vec3 = __commonJS({
  "node_modules/gl-vec3/index.js"(exports, module) {
    module.exports = {
      EPSILON: require_epsilon(),
      create: require_create(),
      clone: require_clone(),
      angle: require_angle(),
      fromValues: require_fromValues(),
      copy: require_copy(),
      set: require_set(),
      equals: require_equals(),
      exactEquals: require_exactEquals(),
      add: require_add(),
      subtract: require_subtract(),
      sub: require_sub(),
      multiply: require_multiply(),
      mul: require_mul(),
      divide: require_divide(),
      div: require_div(),
      min: require_min(),
      max: require_max(),
      floor: require_floor(),
      ceil: require_ceil(),
      round: require_round(),
      scale: require_scale(),
      scaleAndAdd: require_scaleAndAdd(),
      distance: require_distance(),
      dist: require_dist(),
      squaredDistance: require_squaredDistance(),
      sqrDist: require_sqrDist(),
      length: require_length(),
      len: require_len(),
      squaredLength: require_squaredLength(),
      sqrLen: require_sqrLen(),
      negate: require_negate(),
      inverse: require_inverse(),
      normalize: require_normalize(),
      dot: require_dot(),
      cross: require_cross(),
      lerp: require_lerp(),
      random: require_random(),
      transformMat4: require_transformMat4(),
      transformMat3: require_transformMat3(),
      transformQuat: require_transformQuat(),
      rotateX: require_rotateX(),
      rotateY: require_rotateY(),
      rotateZ: require_rotateZ(),
      forEach: require_forEach()
    };
  }
});

// node_modules/iota-array/iota.js
var require_iota = __commonJS({
  "node_modules/iota-array/iota.js"(exports, module) {
    "use strict";
    function iota(n) {
      var result = new Array(n);
      for (var i = 0; i < n; ++i) {
        result[i] = i;
      }
      return result;
    }
    module.exports = iota;
  }
});

// node_modules/ndarray/node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "node_modules/ndarray/node_modules/is-buffer/index.js"(exports, module) {
    module.exports = function(obj) {
      return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
    };
    function isBuffer(obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function isSlowBuffer(obj) {
      return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
    }
  }
});

// node_modules/ndarray/ndarray.js
var require_ndarray = __commonJS({
  "node_modules/ndarray/ndarray.js"(exports, module) {
    var iota = require_iota();
    var isBuffer = require_is_buffer();
    var hasTypedArrays = typeof Float64Array !== "undefined";
    function compare1st(a2, b) {
      return a2[0] - b[0];
    }
    function order() {
      var stride = this.stride;
      var terms = new Array(stride.length);
      var i;
      for (i = 0; i < terms.length; ++i) {
        terms[i] = [Math.abs(stride[i]), i];
      }
      terms.sort(compare1st);
      var result = new Array(terms.length);
      for (i = 0; i < result.length; ++i) {
        result[i] = terms[i][1];
      }
      return result;
    }
    function compileConstructor(dtype, dimension) {
      var className = ["View", dimension, "d", dtype].join("");
      if (dimension < 0) {
        className = "View_Nil" + dtype;
      }
      var useGetters = dtype === "generic";
      if (dimension === -1) {
        var code = "function " + className + "(a){this.data=a;};var proto=" + className + ".prototype;proto.dtype='" + dtype + "';proto.index=function(){return -1};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new " + className + "(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null};return function construct_" + className + "(a){return new " + className + "(a);}";
        var procedure = new Function(code);
        return procedure();
      } else if (dimension === 0) {
        var code = "function " + className + "(a,d) {this.data = a;this.offset = d};var proto=" + className + ".prototype;proto.dtype='" + dtype + "';proto.index=function(){return this.offset};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function " + className + "_copy() {return new " + className + "(this.data,this.offset)};proto.pick=function " + className + "_pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function " + className + "_get(){return " + (useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]") + "};proto.set=function " + className + "_set(v){return " + (useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v") + "};return function construct_" + className + "(a,b,c,d){return new " + className + "(a,d)}";
        var procedure = new Function("TrivialArray", code);
        return procedure(CACHED_CONSTRUCTORS[dtype][0]);
      }
      var code = ["'use strict'"];
      var indices = iota(dimension);
      var args = indices.map(function(i2) {
        return "i" + i2;
      });
      var index_str = "this.offset+" + indices.map(function(i2) {
        return "this.stride[" + i2 + "]*i" + i2;
      }).join("+");
      var shapeArg = indices.map(function(i2) {
        return "b" + i2;
      }).join(",");
      var strideArg = indices.map(function(i2) {
        return "c" + i2;
      }).join(",");
      code.push(
        "function " + className + "(a," + shapeArg + "," + strideArg + ",d){this.data=a",
        "this.shape=[" + shapeArg + "]",
        "this.stride=[" + strideArg + "]",
        "this.offset=d|0}",
        "var proto=" + className + ".prototype",
        "proto.dtype='" + dtype + "'",
        "proto.dimension=" + dimension
      );
      code.push(
        "Object.defineProperty(proto,'size',{get:function " + className + "_size(){return " + indices.map(function(i2) {
          return "this.shape[" + i2 + "]";
        }).join("*"),
        "}})"
      );
      if (dimension === 1) {
        code.push("proto.order=[0]");
      } else {
        code.push("Object.defineProperty(proto,'order',{get:");
        if (dimension < 4) {
          code.push("function " + className + "_order(){");
          if (dimension === 2) {
            code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})");
          } else if (dimension === 3) {
            code.push(
              "var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return [2,1,0];}else if(s0>s2){return [1,2,0];}else{return [1,0,2];}}else if(s0>s2){return [2,0,1];}else if(s2>s1){return [0,1,2];}else{return [0,2,1];}}})"
            );
          }
        } else {
          code.push("ORDER})");
        }
      }
      code.push(
        "proto.set=function " + className + "_set(" + args.join(",") + ",v){"
      );
      if (useGetters) {
        code.push("return this.data.set(" + index_str + ",v)}");
      } else {
        code.push("return this.data[" + index_str + "]=v}");
      }
      code.push("proto.get=function " + className + "_get(" + args.join(",") + "){");
      if (useGetters) {
        code.push("return this.data.get(" + index_str + ")}");
      } else {
        code.push("return this.data[" + index_str + "]}");
      }
      code.push(
        "proto.index=function " + className + "_index(",
        args.join(),
        "){return " + index_str + "}"
      );
      code.push("proto.hi=function " + className + "_hi(" + args.join(",") + "){return new " + className + "(this.data," + indices.map(function(i2) {
        return ["(typeof i", i2, "!=='number'||i", i2, "<0)?this.shape[", i2, "]:i", i2, "|0"].join("");
      }).join(",") + "," + indices.map(function(i2) {
        return "this.stride[" + i2 + "]";
      }).join(",") + ",this.offset)}");
      var a_vars = indices.map(function(i2) {
        return "a" + i2 + "=this.shape[" + i2 + "]";
      });
      var c_vars = indices.map(function(i2) {
        return "c" + i2 + "=this.stride[" + i2 + "]";
      });
      code.push("proto.lo=function " + className + "_lo(" + args.join(",") + "){var b=this.offset,d=0," + a_vars.join(",") + "," + c_vars.join(","));
      for (var i = 0; i < dimension; ++i) {
        code.push(
          "if(typeof i" + i + "==='number'&&i" + i + ">=0){d=i" + i + "|0;b+=c" + i + "*d;a" + i + "-=d}"
        );
      }
      code.push("return new " + className + "(this.data," + indices.map(function(i2) {
        return "a" + i2;
      }).join(",") + "," + indices.map(function(i2) {
        return "c" + i2;
      }).join(",") + ",b)}");
      code.push("proto.step=function " + className + "_step(" + args.join(",") + "){var " + indices.map(function(i2) {
        return "a" + i2 + "=this.shape[" + i2 + "]";
      }).join(",") + "," + indices.map(function(i2) {
        return "b" + i2 + "=this.stride[" + i2 + "]";
      }).join(",") + ",c=this.offset,d=0,ceil=Math.ceil");
      for (var i = 0; i < dimension; ++i) {
        code.push(
          "if(typeof i" + i + "==='number'){d=i" + i + "|0;if(d<0){c+=b" + i + "*(a" + i + "-1);a" + i + "=ceil(-a" + i + "/d)}else{a" + i + "=ceil(a" + i + "/d)}b" + i + "*=d}"
        );
      }
      code.push("return new " + className + "(this.data," + indices.map(function(i2) {
        return "a" + i2;
      }).join(",") + "," + indices.map(function(i2) {
        return "b" + i2;
      }).join(",") + ",c)}");
      var tShape = new Array(dimension);
      var tStride = new Array(dimension);
      for (var i = 0; i < dimension; ++i) {
        tShape[i] = "a[i" + i + "]";
        tStride[i] = "b[i" + i + "]";
      }
      code.push(
        "proto.transpose=function " + className + "_transpose(" + args + "){" + args.map(function(n, idx) {
          return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)";
        }).join(";"),
        "var a=this.shape,b=this.stride;return new " + className + "(this.data," + tShape.join(",") + "," + tStride.join(",") + ",this.offset)}"
      );
      code.push("proto.pick=function " + className + "_pick(" + args + "){var a=[],b=[],c=this.offset");
      for (var i = 0; i < dimension; ++i) {
        code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){c=(c+this.stride[" + i + "]*i" + i + ")|0}else{a.push(this.shape[" + i + "]);b.push(this.stride[" + i + "])}");
      }
      code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}");
      code.push("return function construct_" + className + "(data,shape,stride,offset){return new " + className + "(data," + indices.map(function(i2) {
        return "shape[" + i2 + "]";
      }).join(",") + "," + indices.map(function(i2) {
        return "stride[" + i2 + "]";
      }).join(",") + ",offset)}");
      var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"));
      return procedure(CACHED_CONSTRUCTORS[dtype], order);
    }
    function arrayDType(data) {
      if (isBuffer(data)) {
        return "buffer";
      }
      if (hasTypedArrays) {
        switch (Object.prototype.toString.call(data)) {
          case "[object Float64Array]":
            return "float64";
          case "[object Float32Array]":
            return "float32";
          case "[object Int8Array]":
            return "int8";
          case "[object Int16Array]":
            return "int16";
          case "[object Int32Array]":
            return "int32";
          case "[object Uint8Array]":
            return "uint8";
          case "[object Uint16Array]":
            return "uint16";
          case "[object Uint32Array]":
            return "uint32";
          case "[object Uint8ClampedArray]":
            return "uint8_clamped";
          case "[object BigInt64Array]":
            return "bigint64";
          case "[object BigUint64Array]":
            return "biguint64";
        }
      }
      if (Array.isArray(data)) {
        return "array";
      }
      return "generic";
    }
    var CACHED_CONSTRUCTORS = {
      "float32": [],
      "float64": [],
      "int8": [],
      "int16": [],
      "int32": [],
      "uint8": [],
      "uint16": [],
      "uint32": [],
      "array": [],
      "uint8_clamped": [],
      "bigint64": [],
      "biguint64": [],
      "buffer": [],
      "generic": []
    };
    function wrappedNDArrayCtor(data, shape, stride, offset) {
      if (data === void 0) {
        var ctor = CACHED_CONSTRUCTORS.array[0];
        return ctor([]);
      } else if (typeof data === "number") {
        data = [data];
      }
      if (shape === void 0) {
        shape = [data.length];
      }
      var d = shape.length;
      if (stride === void 0) {
        stride = new Array(d);
        for (var i = d - 1, sz = 1; i >= 0; --i) {
          stride[i] = sz;
          sz *= shape[i];
        }
      }
      if (offset === void 0) {
        offset = 0;
        for (var i = 0; i < d; ++i) {
          if (stride[i] < 0) {
            offset -= (shape[i] - 1) * stride[i];
          }
        }
      }
      var dtype = arrayDType(data);
      var ctor_list = CACHED_CONSTRUCTORS[dtype];
      while (ctor_list.length <= d + 1) {
        ctor_list.push(compileConstructor(dtype, ctor_list.length - 1));
      }
      var ctor = ctor_list[d + 1];
      return ctor(data, shape, stride, offset);
    }
    module.exports = wrappedNDArrayCtor;
  }
});

// node_modules/fast-voxel-raycast/index.js
var require_fast_voxel_raycast = __commonJS({
  "node_modules/fast-voxel-raycast/index.js"(exports, module) {
    "use strict";
    function traceRay_impl(getVoxel, px, py, pz, dx2, dy, dz, max_d, hit_pos, hit_norm) {
      var t = 0, floor2 = Math.floor, ix = floor2(px) | 0, iy = floor2(py) | 0, iz = floor2(pz) | 0, stepx = dx2 > 0 ? 1 : -1, stepy = dy > 0 ? 1 : -1, stepz = dz > 0 ? 1 : -1, txDelta = Math.abs(1 / dx2), tyDelta = Math.abs(1 / dy), tzDelta = Math.abs(1 / dz), xdist = stepx > 0 ? ix + 1 - px : px - ix, ydist = stepy > 0 ? iy + 1 - py : py - iy, zdist = stepz > 0 ? iz + 1 - pz : pz - iz, txMax = txDelta < Infinity ? txDelta * xdist : Infinity, tyMax = tyDelta < Infinity ? tyDelta * ydist : Infinity, tzMax = tzDelta < Infinity ? tzDelta * zdist : Infinity, steppedIndex = -1;
      while (t <= max_d) {
        var b = getVoxel(ix, iy, iz);
        if (b) {
          if (hit_pos) {
            hit_pos[0] = px + t * dx2;
            hit_pos[1] = py + t * dy;
            hit_pos[2] = pz + t * dz;
          }
          if (hit_norm) {
            hit_norm[0] = hit_norm[1] = hit_norm[2] = 0;
            if (steppedIndex === 0) hit_norm[0] = -stepx;
            if (steppedIndex === 1) hit_norm[1] = -stepy;
            if (steppedIndex === 2) hit_norm[2] = -stepz;
          }
          return b;
        }
        if (txMax < tyMax) {
          if (txMax < tzMax) {
            ix += stepx;
            t = txMax;
            txMax += txDelta;
            steppedIndex = 0;
          } else {
            iz += stepz;
            t = tzMax;
            tzMax += tzDelta;
            steppedIndex = 2;
          }
        } else {
          if (tyMax < tzMax) {
            iy += stepy;
            t = tyMax;
            tyMax += tyDelta;
            steppedIndex = 1;
          } else {
            iz += stepz;
            t = tzMax;
            tzMax += tzDelta;
            steppedIndex = 2;
          }
        }
      }
      if (hit_pos) {
        hit_pos[0] = px + t * dx2;
        hit_pos[1] = py + t * dy;
        hit_pos[2] = pz + t * dz;
      }
      if (hit_norm) {
        hit_norm[0] = hit_norm[1] = hit_norm[2] = 0;
      }
      return 0;
    }
    function traceRay(getVoxel, origin, direction, max_d, hit_pos, hit_norm) {
      var px = +origin[0], py = +origin[1], pz = +origin[2], dx2 = +direction[0], dy = +direction[1], dz = +direction[2], ds = Math.sqrt(dx2 * dx2 + dy * dy + dz * dz);
      if (ds === 0) {
        throw new Error("Can't raycast along a zero vector");
      }
      dx2 /= ds;
      dy /= ds;
      dz /= ds;
      if (typeof max_d === "undefined") {
        max_d = 64;
      } else {
        max_d = +max_d;
      }
      return traceRay_impl(getVoxel, px, py, pz, dx2, dy, dz, max_d, hit_pos, hit_norm);
    }
    module.exports = traceRay;
  }
});

// node_modules/voxel-aabb-sweep/index.js
var require_voxel_aabb_sweep = __commonJS({
  "node_modules/voxel-aabb-sweep/index.js"(exports, module) {
    "use strict";
    var tr_arr = [];
    var ldi_arr = [];
    var tri_arr = [];
    var step_arr = [];
    var tDelta_arr = [];
    var tNext_arr = [];
    var vec_arr = [];
    var normed_arr = [];
    var base_arr = [];
    var max_arr = [];
    var left_arr = [];
    var result_arr = [];
    function sweep_impl(getVoxel, callback, vec, base, max2, epsilon) {
      var tr = tr_arr;
      var ldi = ldi_arr;
      var tri = tri_arr;
      var step = step_arr;
      var tDelta = tDelta_arr;
      var tNext = tNext_arr;
      var normed = normed_arr;
      var floor2 = Math.floor;
      var cumulative_t = 0;
      var t = 0;
      var max_t = 0;
      var axis = 0;
      var i = 0;
      initSweep();
      if (max_t === 0) return 0;
      axis = stepForward();
      while (t <= max_t) {
        if (checkCollision(axis)) {
          var done = handleCollision();
          if (done) return cumulative_t;
        }
        axis = stepForward();
      }
      cumulative_t += max_t;
      for (i = 0; i < 3; i++) {
        base[i] += vec[i];
        max2[i] += vec[i];
      }
      return cumulative_t;
      function initSweep() {
        t = 0;
        max_t = Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2]);
        if (max_t === 0) return;
        for (var i2 = 0; i2 < 3; i2++) {
          var dir = vec[i2] >= 0;
          step[i2] = dir ? 1 : -1;
          var lead = dir ? max2[i2] : base[i2];
          tr[i2] = dir ? base[i2] : max2[i2];
          ldi[i2] = leadEdgeToInt(lead, step[i2]);
          tri[i2] = trailEdgeToInt(tr[i2], step[i2]);
          normed[i2] = vec[i2] / max_t;
          tDelta[i2] = Math.abs(1 / normed[i2]);
          var dist2 = dir ? ldi[i2] + 1 - lead : lead - ldi[i2];
          tNext[i2] = tDelta[i2] < Infinity ? tDelta[i2] * dist2 : Infinity;
        }
      }
      function checkCollision(i_axis) {
        var stepx = step[0];
        var x0 = i_axis === 0 ? ldi[0] : tri[0];
        var x1 = ldi[0] + stepx;
        var stepy = step[1];
        var y0 = i_axis === 1 ? ldi[1] : tri[1];
        var y1 = ldi[1] + stepy;
        var stepz = step[2];
        var z0 = i_axis === 2 ? ldi[2] : tri[2];
        var z1 = ldi[2] + stepz;
        for (var x = x0; x != x1; x += stepx) {
          for (var y = y0; y != y1; y += stepy) {
            for (var z = z0; z != z1; z += stepz) {
              if (getVoxel(x, y, z)) return true;
            }
          }
        }
        return false;
      }
      function handleCollision() {
        cumulative_t += t;
        var dir = step[axis];
        var done2 = t / max_t;
        var left = left_arr;
        for (i = 0; i < 3; i++) {
          var dv2 = vec[i] * done2;
          base[i] += dv2;
          max2[i] += dv2;
          left[i] = vec[i] - dv2;
        }
        if (dir > 0) {
          max2[axis] = Math.round(max2[axis]);
        } else {
          base[axis] = Math.round(base[axis]);
        }
        var res = callback(cumulative_t, axis, dir, left);
        if (res) return true;
        for (i = 0; i < 3; i++) vec[i] = left[i];
        initSweep();
        if (max_t === 0) return true;
        return false;
      }
      function stepForward() {
        var axis2 = tNext[0] < tNext[1] ? tNext[0] < tNext[2] ? 0 : 2 : tNext[1] < tNext[2] ? 1 : 2;
        var dt = tNext[axis2] - t;
        t = tNext[axis2];
        ldi[axis2] += step[axis2];
        tNext[axis2] += tDelta[axis2];
        for (i = 0; i < 3; i++) {
          tr[i] += dt * normed[i];
          tri[i] = trailEdgeToInt(tr[i], step[i]);
        }
        return axis2;
      }
      function leadEdgeToInt(coord, step2) {
        return floor2(coord - step2 * epsilon);
      }
      function trailEdgeToInt(coord, step2) {
        return floor2(coord + step2 * epsilon);
      }
    }
    function sweep3(getVoxel, box, dir, callback, noTranslate, epsilon) {
      var vec = vec_arr;
      var base = base_arr;
      var max2 = max_arr;
      var result = result_arr;
      for (var i = 0; i < 3; i++) {
        vec[i] = +dir[i];
        max2[i] = +box.max[i];
        base[i] = +box.base[i];
      }
      if (!epsilon) epsilon = 1e-10;
      var dist2 = sweep_impl(getVoxel, callback, vec, base, max2, epsilon);
      if (!noTranslate) {
        for (i = 0; i < 3; i++) {
          result[i] = dir[i] > 0 ? max2[i] - box.max[i] : base[i] - box.base[i];
        }
        box.translate(result);
      }
      return dist2;
    }
    module.exports = sweep3;
  }
});

// node_modules/ent-comp/src/dataStore.js
var require_dataStore = __commonJS({
  "node_modules/ent-comp/src/dataStore.js"(exports, module) {
    module.exports = class DataStore {
      constructor() {
        this.list = [];
        this.hash = {};
        this._map = {};
        this._pendingRemovals = [];
      }
      // add a new state object
      add(id, stateObject) {
        if (typeof this._map[id] === "number") {
          var index = this._map[id];
          this.hash[id] = stateObject;
          this.list[index] = stateObject;
        } else {
          this._map[id] = this.list.length;
          this.hash[id] = stateObject;
          this.list.push(stateObject);
        }
      }
      // remove - nulls the state object, actual removal comes later
      remove(id) {
        var index = this._map[id];
        this.hash[id] = null;
        this.list[index] = null;
        this._pendingRemovals.push(id);
      }
      // just sever references
      dispose() {
        this.list = null;
        this.hash = null;
        this._map = null;
        this._pendingRemovals.length = 0;
      }
      // deletes removed objects from data structures
      flush() {
        for (var i = 0; i < this._pendingRemovals.length; i++) {
          var id = this._pendingRemovals[i];
          if (this.hash[id] !== null) continue;
          removeElement(this, id);
        }
        this._pendingRemovals.length = 0;
      }
    };
    function removeElement(data, id) {
      var index = data._map[id];
      delete data.hash[id];
      delete data._map[id];
      if (index === data.list.length - 1) {
        data.list.pop();
      } else {
        var swapped = data.list.pop();
        data.list[index] = swapped;
        if (swapped === null || swapped[0] === null) {
          var prevIndex = data.list.length;
          for (var swapID in data._map) {
            if (data._map[swapID] === prevIndex) {
              data._map[swapID] = index;
              return;
            }
          }
        } else {
          var swappedID = swapped.__id || swapped[0].__id;
          data._map[swappedID] = index;
        }
      }
    }
  }
});

// node_modules/ent-comp/src/ECS.js
var require_ECS = __commonJS({
  "node_modules/ent-comp/src/ECS.js"(exports, module) {
    module.exports = ECS2;
    var DataStore = require_dataStore();
    function ECS2() {
      var self = this;
      this.components = {};
      this.comps = this.components;
      var components = this.components;
      var UID = 1;
      var storage = {};
      var systems = [];
      var renderSystems = [];
      var deferrals = {
        timeout: false,
        removals: [],
        multiComps: []
      };
      this._storage = storage;
      this._systems = systems;
      this._renderSystems = renderSystems;
      this.createEntity = function(compList) {
        var id = UID++;
        if (Array.isArray(compList)) {
          compList.forEach((compName) => self.addComponent(id, compName));
        }
        return id;
      };
      this.deleteEntity = function(entID) {
        Object.keys(storage).forEach((compName) => {
          var data = storage[compName];
          if (data.hash[entID]) {
            removeComponent(entID, compName);
          }
        });
        return self;
      };
      this.createComponent = function(compDefn) {
        if (!compDefn) throw new Error("Missing component definition");
        var name = compDefn.name;
        if (!name) throw new Error("Component definition must have a name property.");
        if (typeof name !== "string") throw new Error("Component name must be a string.");
        if (name === "") throw new Error("Component name must be a non-empty string.");
        if (storage[name]) throw new Error(`Component ${name} already exists.`);
        var internalDef = {};
        internalDef.name = name;
        internalDef.multi = !!compDefn.multi;
        internalDef.order = isNaN(compDefn.order) ? 99 : compDefn.order;
        internalDef.state = compDefn.state || {};
        internalDef.onAdd = compDefn.onAdd || null;
        internalDef.onRemove = compDefn.onRemove || null;
        internalDef.system = compDefn.system || null;
        internalDef.renderSystem = compDefn.renderSystem || null;
        components[name] = internalDef;
        storage[name] = new DataStore();
        storage[name]._pendingMultiCleanup = false;
        storage[name]._multiCleanupIDs = internalDef.multi ? [] : null;
        if (internalDef.system) {
          systems.push(name);
          systems.sort((a2, b) => components[a2].order - components[b].order);
        }
        if (internalDef.renderSystem) {
          renderSystems.push(name);
          renderSystems.sort((a2, b) => components[a2].order - components[b].order);
        }
        return name;
      };
      this.overwriteComponent = function(compName, compDefn) {
        var def = components[compName];
        if (!def) throw new Error(`Unknown component: ${compName}`);
        if (!compDefn) throw new Error("Missing component definition");
        if (def.name !== compDefn.name) throw new Error("Overwriting component must use the same name property.");
        var internalDef = {};
        internalDef.name = compName;
        internalDef.multi = !!compDefn.multi;
        internalDef.order = isNaN(compDefn.order) ? 99 : compDefn.order;
        internalDef.state = compDefn.state || {};
        internalDef.onAdd = compDefn.onAdd || null;
        internalDef.onRemove = compDefn.onRemove || null;
        internalDef.system = compDefn.system || null;
        internalDef.renderSystem = compDefn.renderSystem || null;
        components[compName] = internalDef;
        storage[compName]._pendingMultiCleanup = false;
        storage[compName]._multiCleanupIDs = internalDef.multi ? [] : null;
        var si = systems.indexOf(compName);
        if (internalDef.system && si < 0) systems.push(compName);
        if (!internalDef.system && si >= 0) systems.splice(si, 1);
        systems.sort((a2, b) => components[a2].order - components[b].order);
        var ri = renderSystems.indexOf(compName);
        if (internalDef.renderSystem && ri < 0) renderSystems.push(compName);
        if (!internalDef.renderSystem && ri >= 0) renderSystems.splice(ri, 1);
        renderSystems.sort((a2, b) => components[a2].order - components[b].order);
        var baseState = internalDef.state;
        this.getStatesList(compName).forEach((state) => {
          for (var key in baseState) {
            if (!(key in state)) state[key] = baseState[key];
          }
          if (internalDef.onAdd) internalDef.onAdd(state.__id, state);
        });
        return compName;
      };
      this.deleteComponent = function(compName) {
        var data = storage[compName];
        if (!data) throw new Error(`Unknown component: ${compName}`);
        data.flush();
        data.list.forEach((obj) => {
          if (!obj) return;
          var id = obj.__id || obj[0].__id;
          removeComponent(id, compName);
        });
        var i = systems.indexOf(compName);
        var j = renderSystems.indexOf(compName);
        if (i > -1) systems.splice(i, 1);
        if (j > -1) renderSystems.splice(j, 1);
        storage[compName].dispose();
        delete storage[compName];
        delete components[compName];
        return self;
      };
      this.addComponent = function(entID, compName, state) {
        var def = components[compName];
        var data = storage[compName];
        if (!data) throw new Error(`Unknown component: ${compName}.`);
        if (data.hash[entID] && !def.multi) {
          throw new Error(`Entity ${entID} already has component: ${compName}.`);
        }
        var newState = Object.assign({}, { __id: entID }, def.state, state);
        newState.__id = entID;
        if (def.multi) {
          var statesArr = data.hash[entID];
          if (!statesArr) {
            statesArr = [];
            data.add(entID, statesArr);
          }
          statesArr.push(newState);
        } else {
          data.add(entID, newState);
        }
        if (def.onAdd) def.onAdd(entID, newState);
        return this;
      };
      this.hasComponent = function(entID, compName) {
        var data = storage[compName];
        if (!data) throw new Error(`Unknown component: ${compName}.`);
        return !!data.hash[entID];
      };
      this.removeComponent = function(entID, compName) {
        var data = storage[compName];
        if (!data) throw new Error(`Unknown component: ${compName}.`);
        removeComponent(entID, compName);
        return self;
      };
      this.getState = function(entID, compName) {
        var data = storage[compName];
        if (!data) throw new Error(`Unknown component: ${compName}.`);
        return data.hash[entID];
      };
      this.getStatesList = function(compName) {
        var data = storage[compName];
        if (!data) throw new Error(`Unknown component: ${compName}.`);
        doDeferredCleanup(data);
        return data.list;
      };
      this.getStateAccessor = function(compName) {
        if (!storage[compName]) throw new Error(`Unknown component: ${compName}.`);
        var hash = storage[compName].hash;
        return (id) => hash[id];
      };
      this.getComponentAccessor = function(compName) {
        if (!storage[compName]) throw new Error(`Unknown component: ${compName}.`);
        var hash = storage[compName].hash;
        return (id) => !!hash[id];
      };
      this.tick = function(dt) {
        doDeferredCleanup();
        for (var i = 0; i < systems.length; i++) {
          var compName = systems[i];
          var comp = components[compName];
          var data = storage[compName];
          comp.system(dt, data.list);
          doDeferredCleanup();
        }
        return self;
      };
      this.render = function(dt) {
        doDeferredCleanup();
        for (var i = 0; i < renderSystems.length; i++) {
          var compName = renderSystems[i];
          var comp = components[compName];
          var data = storage[compName];
          comp.renderSystem(dt, data.list);
          doDeferredCleanup();
        }
        return self;
      };
      this.removeMultiComponent = function(entID, compName, index) {
        var def = components[compName];
        var data = storage[compName];
        if (!data) throw new Error(`Unknown component: ${compName}.`);
        if (!def.multi) throw new Error("removeMultiComponent called on non-multi component");
        removeMultiCompElement(entID, def, data, index);
        return self;
      };
      function removeComponent(entID, compName) {
        var def = components[compName];
        var data = storage[compName];
        var state = data.hash[entID];
        if (!state) return;
        data.remove(entID);
        if (def.onRemove) {
          if (def.multi) {
            state.forEach((state2) => {
              if (state2) def.onRemove(entID, state2);
            });
            state.length = 0;
          } else {
            def.onRemove(entID, state);
          }
        }
        deferrals.removals.push(data);
        pingDeferrals();
      }
      function removeMultiCompElement(entID, def, data, index) {
        var statesArr = data.hash[entID];
        if (!statesArr) return;
        var state = statesArr[index];
        if (!state) return;
        statesArr[index] = null;
        if (def.onRemove) def.onRemove(entID, state);
        deferrals.multiComps.push({ entID, data });
        pingDeferrals();
      }
      function pingDeferrals() {
        if (deferrals.timeout) return;
        deferrals.timeout = true;
        setTimeout(deferralHandler, 1);
      }
      function deferralHandler() {
        deferrals.timeout = false;
        doDeferredCleanup();
      }
      function doDeferredCleanup() {
        if (deferrals.multiComps.length) {
          deferredMultiCompCleanup(deferrals.multiComps);
        }
        if (deferrals.removals.length) {
          deferredComponentCleanup(deferrals.removals);
        }
      }
      function deferredMultiCompCleanup(list) {
        for (var i = 0; i < list.length; i++) {
          var { entID, data } = list[i];
          var statesArr = data.hash[entID];
          if (!statesArr) continue;
          for (var j = 0; j < statesArr.length; j++) {
            if (statesArr[j]) continue;
            statesArr.splice(j, 1);
            j--;
          }
          if (statesArr.length === 0) {
            data.remove(entID);
            deferrals.removals.push(data);
          }
        }
        list.length = 0;
      }
      function deferredComponentCleanup(list) {
        for (var i = 0; i < list.length; i++) {
          var data = list[i];
          data.flush();
        }
        list.length = 0;
      }
    }
  }
});

// node_modules/bit-twiddle/twiddle.js
var require_twiddle = __commonJS({
  "node_modules/bit-twiddle/twiddle.js"(exports) {
    "use strict";
    "use restrict";
    var INT_BITS = 32;
    exports.INT_BITS = INT_BITS;
    exports.INT_MAX = 2147483647;
    exports.INT_MIN = -1 << INT_BITS - 1;
    exports.sign = function(v) {
      return (v > 0) - (v < 0);
    };
    exports.abs = function(v) {
      var mask = v >> INT_BITS - 1;
      return (v ^ mask) - mask;
    };
    exports.min = function(x, y) {
      return y ^ (x ^ y) & -(x < y);
    };
    exports.max = function(x, y) {
      return x ^ (x ^ y) & -(x < y);
    };
    exports.isPow2 = function(v) {
      return !(v & v - 1) && !!v;
    };
    exports.log2 = function(v) {
      var r, shift;
      r = (v > 65535) << 4;
      v >>>= r;
      shift = (v > 255) << 3;
      v >>>= shift;
      r |= shift;
      shift = (v > 15) << 2;
      v >>>= shift;
      r |= shift;
      shift = (v > 3) << 1;
      v >>>= shift;
      r |= shift;
      return r | v >> 1;
    };
    exports.log10 = function(v) {
      return v >= 1e9 ? 9 : v >= 1e8 ? 8 : v >= 1e7 ? 7 : v >= 1e6 ? 6 : v >= 1e5 ? 5 : v >= 1e4 ? 4 : v >= 1e3 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
    };
    exports.popCount = function(v) {
      v = v - (v >>> 1 & 1431655765);
      v = (v & 858993459) + (v >>> 2 & 858993459);
      return (v + (v >>> 4) & 252645135) * 16843009 >>> 24;
    };
    function countTrailingZeros(v) {
      var c = 32;
      v &= -v;
      if (v) c--;
      if (v & 65535) c -= 16;
      if (v & 16711935) c -= 8;
      if (v & 252645135) c -= 4;
      if (v & 858993459) c -= 2;
      if (v & 1431655765) c -= 1;
      return c;
    }
    exports.countTrailingZeros = countTrailingZeros;
    exports.nextPow2 = function(v) {
      v += v === 0;
      --v;
      v |= v >>> 1;
      v |= v >>> 2;
      v |= v >>> 4;
      v |= v >>> 8;
      v |= v >>> 16;
      return v + 1;
    };
    exports.prevPow2 = function(v) {
      v |= v >>> 1;
      v |= v >>> 2;
      v |= v >>> 4;
      v |= v >>> 8;
      v |= v >>> 16;
      return v - (v >>> 1);
    };
    exports.parity = function(v) {
      v ^= v >>> 16;
      v ^= v >>> 8;
      v ^= v >>> 4;
      v &= 15;
      return 27030 >>> v & 1;
    };
    var REVERSE_TABLE = new Array(256);
    (function(tab) {
      for (var i = 0; i < 256; ++i) {
        var v = i, r = i, s = 7;
        for (v >>>= 1; v; v >>>= 1) {
          r <<= 1;
          r |= v & 1;
          --s;
        }
        tab[i] = r << s & 255;
      }
    })(REVERSE_TABLE);
    exports.reverse = function(v) {
      return REVERSE_TABLE[v & 255] << 24 | REVERSE_TABLE[v >>> 8 & 255] << 16 | REVERSE_TABLE[v >>> 16 & 255] << 8 | REVERSE_TABLE[v >>> 24 & 255];
    };
    exports.interleave2 = function(x, y) {
      x &= 65535;
      x = (x | x << 8) & 16711935;
      x = (x | x << 4) & 252645135;
      x = (x | x << 2) & 858993459;
      x = (x | x << 1) & 1431655765;
      y &= 65535;
      y = (y | y << 8) & 16711935;
      y = (y | y << 4) & 252645135;
      y = (y | y << 2) & 858993459;
      y = (y | y << 1) & 1431655765;
      return x | y << 1;
    };
    exports.deinterleave2 = function(v, n) {
      v = v >>> n & 1431655765;
      v = (v | v >>> 1) & 858993459;
      v = (v | v >>> 2) & 252645135;
      v = (v | v >>> 4) & 16711935;
      v = (v | v >>> 16) & 65535;
      return v << 16 >> 16;
    };
    exports.interleave3 = function(x, y, z) {
      x &= 1023;
      x = (x | x << 16) & 4278190335;
      x = (x | x << 8) & 251719695;
      x = (x | x << 4) & 3272356035;
      x = (x | x << 2) & 1227133513;
      y &= 1023;
      y = (y | y << 16) & 4278190335;
      y = (y | y << 8) & 251719695;
      y = (y | y << 4) & 3272356035;
      y = (y | y << 2) & 1227133513;
      x |= y << 1;
      z &= 1023;
      z = (z | z << 16) & 4278190335;
      z = (z | z << 8) & 251719695;
      z = (z | z << 4) & 3272356035;
      z = (z | z << 2) & 1227133513;
      return x | z << 2;
    };
    exports.deinterleave3 = function(v, n) {
      v = v >>> n & 1227133513;
      v = (v | v >>> 2) & 3272356035;
      v = (v | v >>> 4) & 251719695;
      v = (v | v >>> 8) & 4278190335;
      v = (v | v >>> 16) & 1023;
      return v << 22 >> 22;
    };
    exports.nextCombination = function(v) {
      var t = v | v - 1;
      return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
    };
  }
});

// node_modules/dup/dup.js
var require_dup = __commonJS({
  "node_modules/dup/dup.js"(exports, module) {
    "use strict";
    function dupe_array(count, value, i) {
      var c = count[i] | 0;
      if (c <= 0) {
        return [];
      }
      var result = new Array(c), j;
      if (i === count.length - 1) {
        for (j = 0; j < c; ++j) {
          result[j] = value;
        }
      } else {
        for (j = 0; j < c; ++j) {
          result[j] = dupe_array(count, value, i + 1);
        }
      }
      return result;
    }
    function dupe_number(count, value) {
      var result, i;
      result = new Array(count);
      for (i = 0; i < count; ++i) {
        result[i] = value;
      }
      return result;
    }
    function dupe(count, value) {
      if (typeof value === "undefined") {
        value = 0;
      }
      switch (typeof count) {
        case "number":
          if (count > 0) {
            return dupe_number(count | 0, value);
          }
          break;
        case "object":
          if (typeof count.length === "number") {
            return dupe_array(count, value, 0);
          }
          break;
      }
      return [];
    }
    module.exports = dupe;
  }
});

// node_modules/is-buffer/index.js
var require_is_buffer2 = __commonJS({
  "node_modules/is-buffer/index.js"(exports, module) {
    module.exports = function isBuffer(obj) {
      return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    };
  }
});

// node_modules/@jpweeks/typedarray-pool/pool.js
var require_pool = __commonJS({
  "node_modules/@jpweeks/typedarray-pool/pool.js"(exports) {
    "use strict";
    var bits = require_twiddle();
    var dup = require_dup();
    var isBuffer = require_is_buffer2();
    if (!global.__TYPEDARRAY_POOL) {
      global.__TYPEDARRAY_POOL = {
        UINT8: dup([32, 0]),
        UINT16: dup([32, 0]),
        UINT32: dup([32, 0]),
        INT8: dup([32, 0]),
        INT16: dup([32, 0]),
        INT32: dup([32, 0]),
        FLOAT: dup([32, 0]),
        DOUBLE: dup([32, 0]),
        DATA: dup([32, 0]),
        UINT8C: dup([32, 0]),
        BUFFER: dup([32, 0])
      };
    }
    var hasUint8C = typeof Uint8ClampedArray !== "undefined";
    var POOL = global.__TYPEDARRAY_POOL;
    if (!POOL.UINT8C) {
      POOL.UINT8C = dup([32, 0]);
    }
    if (!POOL.BUFFER) {
      POOL.BUFFER = dup([32, 0]);
    }
    var DATA = POOL.DATA;
    var BUFFER = POOL.BUFFER;
    exports.free = function free(array) {
      if (isBuffer(array)) {
        BUFFER[bits.log2(array.length)].push(array);
      } else {
        if (Object.prototype.toString.call(array) !== "[object ArrayBuffer]") {
          array = array.buffer;
        }
        if (!array) {
          return;
        }
        var n = array.length || array.byteLength;
        var log_n = bits.log2(n) | 0;
        DATA[log_n].push(array);
      }
    };
    function freeArrayBuffer(buffer) {
      if (!buffer) {
        return;
      }
      var n = buffer.length || buffer.byteLength;
      var log_n = bits.log2(n);
      DATA[log_n].push(buffer);
    }
    function freeTypedArray(array) {
      freeArrayBuffer(array.buffer);
    }
    exports.freeUint8 = exports.freeUint16 = exports.freeUint32 = exports.freeInt8 = exports.freeInt16 = exports.freeInt32 = exports.freeFloat32 = exports.freeFloat = exports.freeFloat64 = exports.freeDouble = exports.freeUint8Clamped = exports.freeDataView = freeTypedArray;
    exports.freeArrayBuffer = freeArrayBuffer;
    exports.freeBuffer = function freeBuffer(array) {
      BUFFER[bits.log2(array.length)].push(array);
    };
    exports.malloc = function malloc(n, dtype) {
      if (dtype === void 0 || dtype === "arraybuffer") {
        return mallocArrayBuffer(n);
      } else {
        switch (dtype) {
          case "uint8":
            return mallocUint8(n);
          case "uint16":
            return mallocUint16(n);
          case "uint32":
            return mallocUint32(n);
          case "int8":
            return mallocInt8(n);
          case "int16":
            return mallocInt16(n);
          case "int32":
            return mallocInt32(n);
          case "float":
          case "float32":
            return mallocFloat(n);
          case "double":
          case "float64":
            return mallocDouble(n);
          case "uint8_clamped":
            return mallocUint8Clamped(n);
          case "buffer":
            throw "Buffer not supported";
          case "data":
          case "dataview":
            return mallocDataView(n);
          default:
            return null;
        }
      }
      return null;
    };
    function mallocArrayBuffer(n) {
      var n = bits.nextPow2(n);
      var log_n = bits.log2(n);
      var d = DATA[log_n];
      if (d.length > 0) {
        return d.pop();
      }
      return new ArrayBuffer(n);
    }
    exports.mallocArrayBuffer = mallocArrayBuffer;
    function mallocUint8(n) {
      return new Uint8Array(mallocArrayBuffer(n), 0, n);
    }
    exports.mallocUint8 = mallocUint8;
    function mallocUint16(n) {
      return new Uint16Array(mallocArrayBuffer(2 * n), 0, n);
    }
    exports.mallocUint16 = mallocUint16;
    function mallocUint32(n) {
      return new Uint32Array(mallocArrayBuffer(4 * n), 0, n);
    }
    exports.mallocUint32 = mallocUint32;
    function mallocInt8(n) {
      return new Int8Array(mallocArrayBuffer(n), 0, n);
    }
    exports.mallocInt8 = mallocInt8;
    function mallocInt16(n) {
      return new Int16Array(mallocArrayBuffer(2 * n), 0, n);
    }
    exports.mallocInt16 = mallocInt16;
    function mallocInt32(n) {
      return new Int32Array(mallocArrayBuffer(4 * n), 0, n);
    }
    exports.mallocInt32 = mallocInt32;
    function mallocFloat(n) {
      return new Float32Array(mallocArrayBuffer(4 * n), 0, n);
    }
    exports.mallocFloat32 = exports.mallocFloat = mallocFloat;
    function mallocDouble(n) {
      return new Float64Array(mallocArrayBuffer(8 * n), 0, n);
    }
    exports.mallocFloat64 = exports.mallocDouble = mallocDouble;
    function mallocUint8Clamped(n) {
      if (hasUint8C) {
        return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n);
      } else {
        return mallocUint8(n);
      }
    }
    exports.mallocUint8Clamped = mallocUint8Clamped;
    function mallocDataView(n) {
      return new DataView(mallocArrayBuffer(n), 0, n);
    }
    exports.mallocDataView = mallocDataView;
    exports.clearCache = function clearCache() {
      for (var i = 0; i < 32; ++i) {
        POOL.UINT8[i].length = 0;
        POOL.UINT16[i].length = 0;
        POOL.UINT32[i].length = 0;
        POOL.INT8[i].length = 0;
        POOL.INT16[i].length = 0;
        POOL.INT32[i].length = 0;
        POOL.FLOAT[i].length = 0;
        POOL.DOUBLE[i].length = 0;
        POOL.UINT8C[i].length = 0;
        DATA[i].length = 0;
        BUFFER[i].length = 0;
      }
    };
  }
});

// node_modules/box-intersect/lib/sort.js
var require_sort = __commonJS({
  "node_modules/box-intersect/lib/sort.js"(exports, module) {
    "use strict";
    module.exports = wrapper;
    var INSERT_SORT_CUTOFF = 32;
    function wrapper(data, n0) {
      if (n0 <= 4 * INSERT_SORT_CUTOFF) {
        insertionSort(0, n0 - 1, data);
      } else {
        quickSort(0, n0 - 1, data);
      }
    }
    function insertionSort(left, right, data) {
      var ptr = 2 * (left + 1);
      for (var i = left + 1; i <= right; ++i) {
        var a2 = data[ptr++];
        var b = data[ptr++];
        var j = i;
        var jptr = ptr - 2;
        while (j-- > left) {
          var x = data[jptr - 2];
          var y = data[jptr - 1];
          if (x < a2) {
            break;
          } else if (x === a2 && y < b) {
            break;
          }
          data[jptr] = x;
          data[jptr + 1] = y;
          jptr -= 2;
        }
        data[jptr] = a2;
        data[jptr + 1] = b;
      }
    }
    function swap(i, j, data) {
      i *= 2;
      j *= 2;
      var x = data[i];
      var y = data[i + 1];
      data[i] = data[j];
      data[i + 1] = data[j + 1];
      data[j] = x;
      data[j + 1] = y;
    }
    function move(i, j, data) {
      i *= 2;
      j *= 2;
      data[i] = data[j];
      data[i + 1] = data[j + 1];
    }
    function rotate(i, j, k, data) {
      i *= 2;
      j *= 2;
      k *= 2;
      var x = data[i];
      var y = data[i + 1];
      data[i] = data[j];
      data[i + 1] = data[j + 1];
      data[j] = data[k];
      data[j + 1] = data[k + 1];
      data[k] = x;
      data[k + 1] = y;
    }
    function shufflePivot(i, j, px, py, data) {
      i *= 2;
      j *= 2;
      data[i] = data[j];
      data[j] = px;
      data[i + 1] = data[j + 1];
      data[j + 1] = py;
    }
    function compare(i, j, data) {
      i *= 2;
      j *= 2;
      var x = data[i], y = data[j];
      if (x < y) {
        return false;
      } else if (x === y) {
        return data[i + 1] > data[j + 1];
      }
      return true;
    }
    function comparePivot(i, y, b, data) {
      i *= 2;
      var x = data[i];
      if (x < y) {
        return true;
      } else if (x === y) {
        return data[i + 1] < b;
      }
      return false;
    }
    function quickSort(left, right, data) {
      var sixth = (right - left + 1) / 6 | 0, index1 = left + sixth, index5 = right - sixth, index3 = left + right >> 1, index2 = index3 - sixth, index4 = index3 + sixth, el1 = index1, el2 = index2, el3 = index3, el4 = index4, el5 = index5, less = left + 1, great = right - 1, tmp = 0;
      if (compare(el1, el2, data)) {
        tmp = el1;
        el1 = el2;
        el2 = tmp;
      }
      if (compare(el4, el5, data)) {
        tmp = el4;
        el4 = el5;
        el5 = tmp;
      }
      if (compare(el1, el3, data)) {
        tmp = el1;
        el1 = el3;
        el3 = tmp;
      }
      if (compare(el2, el3, data)) {
        tmp = el2;
        el2 = el3;
        el3 = tmp;
      }
      if (compare(el1, el4, data)) {
        tmp = el1;
        el1 = el4;
        el4 = tmp;
      }
      if (compare(el3, el4, data)) {
        tmp = el3;
        el3 = el4;
        el4 = tmp;
      }
      if (compare(el2, el5, data)) {
        tmp = el2;
        el2 = el5;
        el5 = tmp;
      }
      if (compare(el2, el3, data)) {
        tmp = el2;
        el2 = el3;
        el3 = tmp;
      }
      if (compare(el4, el5, data)) {
        tmp = el4;
        el4 = el5;
        el5 = tmp;
      }
      var pivot1X = data[2 * el2];
      var pivot1Y = data[2 * el2 + 1];
      var pivot2X = data[2 * el4];
      var pivot2Y = data[2 * el4 + 1];
      var ptr0 = 2 * el1;
      var ptr2 = 2 * el3;
      var ptr4 = 2 * el5;
      var ptr5 = 2 * index1;
      var ptr6 = 2 * index3;
      var ptr7 = 2 * index5;
      for (var i1 = 0; i1 < 2; ++i1) {
        var x = data[ptr0 + i1];
        var y = data[ptr2 + i1];
        var z = data[ptr4 + i1];
        data[ptr5 + i1] = x;
        data[ptr6 + i1] = y;
        data[ptr7 + i1] = z;
      }
      move(index2, left, data);
      move(index4, right, data);
      for (var k = less; k <= great; ++k) {
        if (comparePivot(k, pivot1X, pivot1Y, data)) {
          if (k !== less) {
            swap(k, less, data);
          }
          ++less;
        } else {
          if (!comparePivot(k, pivot2X, pivot2Y, data)) {
            while (true) {
              if (!comparePivot(great, pivot2X, pivot2Y, data)) {
                if (--great < k) {
                  break;
                }
                continue;
              } else {
                if (comparePivot(great, pivot1X, pivot1Y, data)) {
                  rotate(k, less, great, data);
                  ++less;
                  --great;
                } else {
                  swap(k, great, data);
                  --great;
                }
                break;
              }
            }
          }
        }
      }
      shufflePivot(left, less - 1, pivot1X, pivot1Y, data);
      shufflePivot(right, great + 1, pivot2X, pivot2Y, data);
      if (less - 2 - left <= INSERT_SORT_CUTOFF) {
        insertionSort(left, less - 2, data);
      } else {
        quickSort(left, less - 2, data);
      }
      if (right - (great + 2) <= INSERT_SORT_CUTOFF) {
        insertionSort(great + 2, right, data);
      } else {
        quickSort(great + 2, right, data);
      }
      if (great - less <= INSERT_SORT_CUTOFF) {
        insertionSort(less, great, data);
      } else {
        quickSort(less, great, data);
      }
    }
  }
});

// node_modules/box-intersect/lib/sweep.js
var require_sweep = __commonJS({
  "node_modules/box-intersect/lib/sweep.js"(exports, module) {
    "use strict";
    module.exports = {
      init: sqInit,
      sweepBipartite,
      sweepComplete,
      scanBipartite,
      scanComplete
    };
    var pool = require_pool();
    var bits = require_twiddle();
    var isort = require_sort();
    var BLUE_FLAG = 1 << 28;
    var INIT_CAPACITY = 1024;
    var RED_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY);
    var RED_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY);
    var BLUE_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY);
    var BLUE_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY);
    var COMMON_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY);
    var COMMON_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY);
    var SWEEP_EVENTS = pool.mallocDouble(INIT_CAPACITY * 8);
    function sqInit(count) {
      var rcount = bits.nextPow2(count);
      if (RED_SWEEP_QUEUE.length < rcount) {
        pool.free(RED_SWEEP_QUEUE);
        RED_SWEEP_QUEUE = pool.mallocInt32(rcount);
      }
      if (RED_SWEEP_INDEX.length < rcount) {
        pool.free(RED_SWEEP_INDEX);
        RED_SWEEP_INDEX = pool.mallocInt32(rcount);
      }
      if (BLUE_SWEEP_QUEUE.length < rcount) {
        pool.free(BLUE_SWEEP_QUEUE);
        BLUE_SWEEP_QUEUE = pool.mallocInt32(rcount);
      }
      if (BLUE_SWEEP_INDEX.length < rcount) {
        pool.free(BLUE_SWEEP_INDEX);
        BLUE_SWEEP_INDEX = pool.mallocInt32(rcount);
      }
      if (COMMON_SWEEP_QUEUE.length < rcount) {
        pool.free(COMMON_SWEEP_QUEUE);
        COMMON_SWEEP_QUEUE = pool.mallocInt32(rcount);
      }
      if (COMMON_SWEEP_INDEX.length < rcount) {
        pool.free(COMMON_SWEEP_INDEX);
        COMMON_SWEEP_INDEX = pool.mallocInt32(rcount);
      }
      var eventLength = 8 * rcount;
      if (SWEEP_EVENTS.length < eventLength) {
        pool.free(SWEEP_EVENTS);
        SWEEP_EVENTS = pool.mallocDouble(eventLength);
      }
    }
    function sqPop(queue, index, count, item) {
      var idx = index[item];
      var top = queue[count - 1];
      queue[idx] = top;
      index[top] = idx;
    }
    function sqPush(queue, index, count, item) {
      queue[count] = item;
      index[item] = count;
    }
    function sweepBipartite(d, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {
      var ptr = 0;
      var elemSize = 2 * d;
      var istart = d - 1;
      var iend = elemSize - 1;
      for (var i = redStart; i < redEnd; ++i) {
        var idx = redIndex[i];
        var redOffset = elemSize * i;
        SWEEP_EVENTS[ptr++] = red[redOffset + istart];
        SWEEP_EVENTS[ptr++] = -(idx + 1);
        SWEEP_EVENTS[ptr++] = red[redOffset + iend];
        SWEEP_EVENTS[ptr++] = idx;
      }
      for (var i = blueStart; i < blueEnd; ++i) {
        var idx = blueIndex[i] + BLUE_FLAG;
        var blueOffset = elemSize * i;
        SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];
        SWEEP_EVENTS[ptr++] = -idx;
        SWEEP_EVENTS[ptr++] = blue[blueOffset + iend];
        SWEEP_EVENTS[ptr++] = idx;
      }
      var n = ptr >>> 1;
      isort(SWEEP_EVENTS, n);
      var redActive = 0;
      var blueActive = 0;
      for (var i = 0; i < n; ++i) {
        var e = SWEEP_EVENTS[2 * i + 1] | 0;
        if (e >= BLUE_FLAG) {
          e = e - BLUE_FLAG | 0;
          sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, e);
        } else if (e >= 0) {
          sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e);
        } else if (e <= -BLUE_FLAG) {
          e = -e - BLUE_FLAG | 0;
          for (var j = 0; j < redActive; ++j) {
            var retval = visit(RED_SWEEP_QUEUE[j], e);
            if (retval !== void 0) {
              return retval;
            }
          }
          sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, e);
        } else {
          e = -e - 1 | 0;
          for (var j = 0; j < blueActive; ++j) {
            var retval = visit(e, BLUE_SWEEP_QUEUE[j]);
            if (retval !== void 0) {
              return retval;
            }
          }
          sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, e);
        }
      }
    }
    function sweepComplete(d, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {
      var ptr = 0;
      var elemSize = 2 * d;
      var istart = d - 1;
      var iend = elemSize - 1;
      for (var i = redStart; i < redEnd; ++i) {
        var idx = redIndex[i] + 1 << 1;
        var redOffset = elemSize * i;
        SWEEP_EVENTS[ptr++] = red[redOffset + istart];
        SWEEP_EVENTS[ptr++] = -idx;
        SWEEP_EVENTS[ptr++] = red[redOffset + iend];
        SWEEP_EVENTS[ptr++] = idx;
      }
      for (var i = blueStart; i < blueEnd; ++i) {
        var idx = blueIndex[i] + 1 << 1;
        var blueOffset = elemSize * i;
        SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];
        SWEEP_EVENTS[ptr++] = -idx | 1;
        SWEEP_EVENTS[ptr++] = blue[blueOffset + iend];
        SWEEP_EVENTS[ptr++] = idx | 1;
      }
      var n = ptr >>> 1;
      isort(SWEEP_EVENTS, n);
      var redActive = 0;
      var blueActive = 0;
      var commonActive = 0;
      for (var i = 0; i < n; ++i) {
        var e = SWEEP_EVENTS[2 * i + 1] | 0;
        var color = e & 1;
        if (i < n - 1 && e >> 1 === SWEEP_EVENTS[2 * i + 3] >> 1) {
          color = 2;
          i += 1;
        }
        if (e < 0) {
          var id = -(e >> 1) - 1;
          for (var j = 0; j < commonActive; ++j) {
            var retval = visit(COMMON_SWEEP_QUEUE[j], id);
            if (retval !== void 0) {
              return retval;
            }
          }
          if (color !== 0) {
            for (var j = 0; j < redActive; ++j) {
              var retval = visit(RED_SWEEP_QUEUE[j], id);
              if (retval !== void 0) {
                return retval;
              }
            }
          }
          if (color !== 1) {
            for (var j = 0; j < blueActive; ++j) {
              var retval = visit(BLUE_SWEEP_QUEUE[j], id);
              if (retval !== void 0) {
                return retval;
              }
            }
          }
          if (color === 0) {
            sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, id);
          } else if (color === 1) {
            sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, id);
          } else if (color === 2) {
            sqPush(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive++, id);
          }
        } else {
          var id = (e >> 1) - 1;
          if (color === 0) {
            sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, id);
          } else if (color === 1) {
            sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, id);
          } else if (color === 2) {
            sqPop(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive--, id);
          }
        }
      }
    }
    function scanBipartite(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {
      var ptr = 0;
      var elemSize = 2 * d;
      var istart = axis;
      var iend = axis + d;
      var redShift = 1;
      var blueShift = 1;
      if (flip) {
        blueShift = BLUE_FLAG;
      } else {
        redShift = BLUE_FLAG;
      }
      for (var i = redStart; i < redEnd; ++i) {
        var idx = i + redShift;
        var redOffset = elemSize * i;
        SWEEP_EVENTS[ptr++] = red[redOffset + istart];
        SWEEP_EVENTS[ptr++] = -idx;
        SWEEP_EVENTS[ptr++] = red[redOffset + iend];
        SWEEP_EVENTS[ptr++] = idx;
      }
      for (var i = blueStart; i < blueEnd; ++i) {
        var idx = i + blueShift;
        var blueOffset = elemSize * i;
        SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];
        SWEEP_EVENTS[ptr++] = -idx;
      }
      var n = ptr >>> 1;
      isort(SWEEP_EVENTS, n);
      var redActive = 0;
      for (var i = 0; i < n; ++i) {
        var e = SWEEP_EVENTS[2 * i + 1] | 0;
        if (e < 0) {
          var idx = -e;
          var isRed = false;
          if (idx >= BLUE_FLAG) {
            isRed = !flip;
            idx -= BLUE_FLAG;
          } else {
            isRed = !!flip;
            idx -= 1;
          }
          if (isRed) {
            sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, idx);
          } else {
            var blueId = blueIndex[idx];
            var bluePtr = elemSize * idx;
            var b0 = blue[bluePtr + axis + 1];
            var b1 = blue[bluePtr + axis + 1 + d];
            red_loop:
              for (var j = 0; j < redActive; ++j) {
                var oidx = RED_SWEEP_QUEUE[j];
                var redPtr = elemSize * oidx;
                if (b1 < red[redPtr + axis + 1] || red[redPtr + axis + 1 + d] < b0) {
                  continue;
                }
                for (var k = axis + 2; k < d; ++k) {
                  if (blue[bluePtr + k + d] < red[redPtr + k] || red[redPtr + k + d] < blue[bluePtr + k]) {
                    continue red_loop;
                  }
                }
                var redId = redIndex[oidx];
                var retval;
                if (flip) {
                  retval = visit(blueId, redId);
                } else {
                  retval = visit(redId, blueId);
                }
                if (retval !== void 0) {
                  return retval;
                }
              }
          }
        } else {
          sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e - redShift);
        }
      }
    }
    function scanComplete(d, axis, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {
      var ptr = 0;
      var elemSize = 2 * d;
      var istart = axis;
      var iend = axis + d;
      for (var i = redStart; i < redEnd; ++i) {
        var idx = i + BLUE_FLAG;
        var redOffset = elemSize * i;
        SWEEP_EVENTS[ptr++] = red[redOffset + istart];
        SWEEP_EVENTS[ptr++] = -idx;
        SWEEP_EVENTS[ptr++] = red[redOffset + iend];
        SWEEP_EVENTS[ptr++] = idx;
      }
      for (var i = blueStart; i < blueEnd; ++i) {
        var idx = i + 1;
        var blueOffset = elemSize * i;
        SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];
        SWEEP_EVENTS[ptr++] = -idx;
      }
      var n = ptr >>> 1;
      isort(SWEEP_EVENTS, n);
      var redActive = 0;
      for (var i = 0; i < n; ++i) {
        var e = SWEEP_EVENTS[2 * i + 1] | 0;
        if (e < 0) {
          var idx = -e;
          if (idx >= BLUE_FLAG) {
            RED_SWEEP_QUEUE[redActive++] = idx - BLUE_FLAG;
          } else {
            idx -= 1;
            var blueId = blueIndex[idx];
            var bluePtr = elemSize * idx;
            var b0 = blue[bluePtr + axis + 1];
            var b1 = blue[bluePtr + axis + 1 + d];
            red_loop:
              for (var j = 0; j < redActive; ++j) {
                var oidx = RED_SWEEP_QUEUE[j];
                var redId = redIndex[oidx];
                if (redId === blueId) {
                  break;
                }
                var redPtr = elemSize * oidx;
                if (b1 < red[redPtr + axis + 1] || red[redPtr + axis + 1 + d] < b0) {
                  continue;
                }
                for (var k = axis + 2; k < d; ++k) {
                  if (blue[bluePtr + k + d] < red[redPtr + k] || red[redPtr + k + d] < blue[bluePtr + k]) {
                    continue red_loop;
                  }
                }
                var retval = visit(redId, blueId);
                if (retval !== void 0) {
                  return retval;
                }
              }
          }
        } else {
          var idx = e - BLUE_FLAG;
          for (var j = redActive - 1; j >= 0; --j) {
            if (RED_SWEEP_QUEUE[j] === idx) {
              for (var k = j + 1; k < redActive; ++k) {
                RED_SWEEP_QUEUE[k - 1] = RED_SWEEP_QUEUE[k];
              }
              break;
            }
          }
          --redActive;
        }
      }
    }
  }
});

// node_modules/box-intersect/lib/brute.js
var require_brute = __commonJS({
  "node_modules/box-intersect/lib/brute.js"(exports) {
    "use strict";
    var DIMENSION = "d";
    var AXIS = "ax";
    var VISIT = "vv";
    var FLIP = "fp";
    var ELEM_SIZE = "es";
    var RED_START = "rs";
    var RED_END = "re";
    var RED_BOXES = "rb";
    var RED_INDEX = "ri";
    var RED_PTR = "rp";
    var BLUE_START = "bs";
    var BLUE_END = "be";
    var BLUE_BOXES = "bb";
    var BLUE_INDEX = "bi";
    var BLUE_PTR = "bp";
    var RETVAL = "rv";
    var INNER_LABEL = "Q";
    var ARGS = [
      DIMENSION,
      AXIS,
      VISIT,
      RED_START,
      RED_END,
      RED_BOXES,
      RED_INDEX,
      BLUE_START,
      BLUE_END,
      BLUE_BOXES,
      BLUE_INDEX
    ];
    function generateBruteForce(redMajor, flip, full) {
      var funcName = "bruteForce" + (redMajor ? "Red" : "Blue") + (flip ? "Flip" : "") + (full ? "Full" : "");
      var code = [
        "function ",
        funcName,
        "(",
        ARGS.join(),
        "){",
        "var ",
        ELEM_SIZE,
        "=2*",
        DIMENSION,
        ";"
      ];
      var redLoop = "for(var i=" + RED_START + "," + RED_PTR + "=" + ELEM_SIZE + "*" + RED_START + ";i<" + RED_END + ";++i," + RED_PTR + "+=" + ELEM_SIZE + "){var x0=" + RED_BOXES + "[" + AXIS + "+" + RED_PTR + "],x1=" + RED_BOXES + "[" + AXIS + "+" + RED_PTR + "+" + DIMENSION + "],xi=" + RED_INDEX + "[i];";
      var blueLoop = "for(var j=" + BLUE_START + "," + BLUE_PTR + "=" + ELEM_SIZE + "*" + BLUE_START + ";j<" + BLUE_END + ";++j," + BLUE_PTR + "+=" + ELEM_SIZE + "){var y0=" + BLUE_BOXES + "[" + AXIS + "+" + BLUE_PTR + "]," + (full ? "y1=" + BLUE_BOXES + "[" + AXIS + "+" + BLUE_PTR + "+" + DIMENSION + "]," : "") + "yi=" + BLUE_INDEX + "[j];";
      if (redMajor) {
        code.push(redLoop, INNER_LABEL, ":", blueLoop);
      } else {
        code.push(blueLoop, INNER_LABEL, ":", redLoop);
      }
      if (full) {
        code.push("if(y1<x0||x1<y0)continue;");
      } else if (flip) {
        code.push("if(y0<=x0||x1<y0)continue;");
      } else {
        code.push("if(y0<x0||x1<y0)continue;");
      }
      code.push("for(var k=" + AXIS + "+1;k<" + DIMENSION + ";++k){var r0=" + RED_BOXES + "[k+" + RED_PTR + "],r1=" + RED_BOXES + "[k+" + DIMENSION + "+" + RED_PTR + "],b0=" + BLUE_BOXES + "[k+" + BLUE_PTR + "],b1=" + BLUE_BOXES + "[k+" + DIMENSION + "+" + BLUE_PTR + "];if(r1<b0||b1<r0)continue " + INNER_LABEL + ";}var " + RETVAL + "=" + VISIT + "(");
      if (flip) {
        code.push("yi,xi");
      } else {
        code.push("xi,yi");
      }
      code.push(");if(" + RETVAL + "!==void 0)return " + RETVAL + ";}}}");
      return {
        name: funcName,
        code: code.join("")
      };
    }
    function bruteForcePlanner(full) {
      var funcName = "bruteForce" + (full ? "Full" : "Partial");
      var prefix = [];
      var fargs = ARGS.slice();
      if (!full) {
        fargs.splice(3, 0, FLIP);
      }
      var code = ["function " + funcName + "(" + fargs.join() + "){"];
      function invoke(redMajor, flip) {
        var res = generateBruteForce(redMajor, flip, full);
        prefix.push(res.code);
        code.push("return " + res.name + "(" + ARGS.join() + ");");
      }
      code.push("if(" + RED_END + "-" + RED_START + ">" + BLUE_END + "-" + BLUE_START + "){");
      if (full) {
        invoke(true, false);
        code.push("}else{");
        invoke(false, false);
      } else {
        code.push("if(" + FLIP + "){");
        invoke(true, true);
        code.push("}else{");
        invoke(true, false);
        code.push("}}else{if(" + FLIP + "){");
        invoke(false, true);
        code.push("}else{");
        invoke(false, false);
        code.push("}");
      }
      code.push("}}return " + funcName);
      var codeStr = prefix.join("") + code.join("");
      var proc = new Function(codeStr);
      return proc();
    }
    exports.partial = bruteForcePlanner(false);
    exports.full = bruteForcePlanner(true);
  }
});

// node_modules/box-intersect/lib/partition.js
var require_partition = __commonJS({
  "node_modules/box-intersect/lib/partition.js"(exports, module) {
    "use strict";
    module.exports = genPartition;
    var code = "for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var _;if($)if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t}var u=f[p];f[p]=f[m],f[m++]=u}}return m";
    function genPartition(predicate, args) {
      var fargs = "abcdef".split("").concat(args);
      var reads = [];
      if (predicate.indexOf("lo") >= 0) {
        reads.push("lo=e[k+n]");
      }
      if (predicate.indexOf("hi") >= 0) {
        reads.push("hi=e[k+o]");
      }
      fargs.push(
        code.replace("_", reads.join()).replace("$", predicate)
      );
      return Function.apply(void 0, fargs);
    }
  }
});

// node_modules/box-intersect/lib/median.js
var require_median = __commonJS({
  "node_modules/box-intersect/lib/median.js"(exports, module) {
    "use strict";
    module.exports = findMedian;
    var genPartition = require_partition();
    var partitionStartLessThan = genPartition("lo<p0", ["p0"]);
    var PARTITION_THRESHOLD = 8;
    function insertionSort(d, axis, start, end, boxes, ids) {
      var elemSize = 2 * d;
      var boxPtr = elemSize * (start + 1) + axis;
      for (var i = start + 1; i < end; ++i, boxPtr += elemSize) {
        var x = boxes[boxPtr];
        for (var j = i, ptr = elemSize * (i - 1); j > start && boxes[ptr + axis] > x; --j, ptr -= elemSize) {
          var aPtr = ptr;
          var bPtr = ptr + elemSize;
          for (var k = 0; k < elemSize; ++k, ++aPtr, ++bPtr) {
            var y = boxes[aPtr];
            boxes[aPtr] = boxes[bPtr];
            boxes[bPtr] = y;
          }
          var tmp = ids[j];
          ids[j] = ids[j - 1];
          ids[j - 1] = tmp;
        }
      }
    }
    function findMedian(d, axis, start, end, boxes, ids) {
      if (end <= start + 1) {
        return start;
      }
      var lo = start;
      var hi = end;
      var mid = end + start >>> 1;
      var elemSize = 2 * d;
      var pivot = mid;
      var value = boxes[elemSize * mid + axis];
      while (lo < hi) {
        if (hi - lo < PARTITION_THRESHOLD) {
          insertionSort(d, axis, lo, hi, boxes, ids);
          value = boxes[elemSize * mid + axis];
          break;
        }
        var count = hi - lo;
        var pivot0 = Math.random() * count + lo | 0;
        var value0 = boxes[elemSize * pivot0 + axis];
        var pivot1 = Math.random() * count + lo | 0;
        var value1 = boxes[elemSize * pivot1 + axis];
        var pivot2 = Math.random() * count + lo | 0;
        var value2 = boxes[elemSize * pivot2 + axis];
        if (value0 <= value1) {
          if (value2 >= value1) {
            pivot = pivot1;
            value = value1;
          } else if (value0 >= value2) {
            pivot = pivot0;
            value = value0;
          } else {
            pivot = pivot2;
            value = value2;
          }
        } else {
          if (value1 >= value2) {
            pivot = pivot1;
            value = value1;
          } else if (value2 >= value0) {
            pivot = pivot0;
            value = value0;
          } else {
            pivot = pivot2;
            value = value2;
          }
        }
        var aPtr = elemSize * (hi - 1);
        var bPtr = elemSize * pivot;
        for (var i = 0; i < elemSize; ++i, ++aPtr, ++bPtr) {
          var x = boxes[aPtr];
          boxes[aPtr] = boxes[bPtr];
          boxes[bPtr] = x;
        }
        var y = ids[hi - 1];
        ids[hi - 1] = ids[pivot];
        ids[pivot] = y;
        pivot = partitionStartLessThan(
          d,
          axis,
          lo,
          hi - 1,
          boxes,
          ids,
          value
        );
        var aPtr = elemSize * (hi - 1);
        var bPtr = elemSize * pivot;
        for (var i = 0; i < elemSize; ++i, ++aPtr, ++bPtr) {
          var x = boxes[aPtr];
          boxes[aPtr] = boxes[bPtr];
          boxes[bPtr] = x;
        }
        var y = ids[hi - 1];
        ids[hi - 1] = ids[pivot];
        ids[pivot] = y;
        if (mid < pivot) {
          hi = pivot - 1;
          while (lo < hi && boxes[elemSize * (hi - 1) + axis] === value) {
            hi -= 1;
          }
          hi += 1;
        } else if (pivot < mid) {
          lo = pivot + 1;
          while (lo < hi && boxes[elemSize * lo + axis] === value) {
            lo += 1;
          }
        } else {
          break;
        }
      }
      return partitionStartLessThan(
        d,
        axis,
        start,
        mid,
        boxes,
        ids,
        boxes[elemSize * mid + axis]
      );
    }
  }
});

// node_modules/box-intersect/lib/intersect.js
var require_intersect = __commonJS({
  "node_modules/box-intersect/lib/intersect.js"(exports, module) {
    "use strict";
    module.exports = boxIntersectIter;
    var pool = require_pool();
    var bits = require_twiddle();
    var bruteForce = require_brute();
    var bruteForcePartial = bruteForce.partial;
    var bruteForceFull = bruteForce.full;
    var sweep3 = require_sweep();
    var findMedian = require_median();
    var genPartition = require_partition();
    var BRUTE_FORCE_CUTOFF = 128;
    var SCAN_CUTOFF = 1 << 22;
    var SCAN_COMPLETE_CUTOFF = 1 << 22;
    var partitionInteriorContainsInterval = genPartition(
      "!(lo>=p0)&&!(p1>=hi)",
      ["p0", "p1"]
    );
    var partitionStartEqual = genPartition(
      "lo===p0",
      ["p0"]
    );
    var partitionStartLessThan = genPartition(
      "lo<p0",
      ["p0"]
    );
    var partitionEndLessThanEqual = genPartition(
      "hi<=p0",
      ["p0"]
    );
    var partitionContainsPoint = genPartition(
      "lo<=p0&&p0<=hi",
      ["p0"]
    );
    var partitionContainsPointProper = genPartition(
      "lo<p0&&p0<=hi",
      ["p0"]
    );
    var IFRAME_SIZE = 6;
    var DFRAME_SIZE = 2;
    var INIT_CAPACITY = 1024;
    var BOX_ISTACK = pool.mallocInt32(INIT_CAPACITY);
    var BOX_DSTACK = pool.mallocDouble(INIT_CAPACITY);
    function iterInit(d, count) {
      var levels = 8 * bits.log2(count + 1) * (d + 1) | 0;
      var maxInts = bits.nextPow2(IFRAME_SIZE * levels);
      if (BOX_ISTACK.length < maxInts) {
        pool.free(BOX_ISTACK);
        BOX_ISTACK = pool.mallocInt32(maxInts);
      }
      var maxDoubles = bits.nextPow2(DFRAME_SIZE * levels);
      if (BOX_DSTACK.length < maxDoubles) {
        pool.free(BOX_DSTACK);
        BOX_DSTACK = pool.mallocDouble(maxDoubles);
      }
    }
    function iterPush(ptr, axis, redStart, redEnd, blueStart, blueEnd, state, lo, hi) {
      var iptr = IFRAME_SIZE * ptr;
      BOX_ISTACK[iptr] = axis;
      BOX_ISTACK[iptr + 1] = redStart;
      BOX_ISTACK[iptr + 2] = redEnd;
      BOX_ISTACK[iptr + 3] = blueStart;
      BOX_ISTACK[iptr + 4] = blueEnd;
      BOX_ISTACK[iptr + 5] = state;
      var dptr = DFRAME_SIZE * ptr;
      BOX_DSTACK[dptr] = lo;
      BOX_DSTACK[dptr + 1] = hi;
    }
    function onePointPartial(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueOffset, blue, blueId) {
      var elemSize = 2 * d;
      var bluePtr = blueOffset * elemSize;
      var blueX = blue[bluePtr + axis];
      red_loop:
        for (var i = redStart, redPtr = redStart * elemSize; i < redEnd; ++i, redPtr += elemSize) {
          var r0 = red[redPtr + axis];
          var r1 = red[redPtr + axis + d];
          if (blueX < r0 || r1 < blueX) {
            continue;
          }
          if (flip && blueX === r0) {
            continue;
          }
          var redId = redIndex[i];
          for (var j = axis + 1; j < d; ++j) {
            var r0 = red[redPtr + j];
            var r1 = red[redPtr + j + d];
            var b0 = blue[bluePtr + j];
            var b1 = blue[bluePtr + j + d];
            if (r1 < b0 || b1 < r0) {
              continue red_loop;
            }
          }
          var retval;
          if (flip) {
            retval = visit(blueId, redId);
          } else {
            retval = visit(redId, blueId);
          }
          if (retval !== void 0) {
            return retval;
          }
        }
    }
    function onePointFull(d, axis, visit, redStart, redEnd, red, redIndex, blueOffset, blue, blueId) {
      var elemSize = 2 * d;
      var bluePtr = blueOffset * elemSize;
      var blueX = blue[bluePtr + axis];
      red_loop:
        for (var i = redStart, redPtr = redStart * elemSize; i < redEnd; ++i, redPtr += elemSize) {
          var redId = redIndex[i];
          if (redId === blueId) {
            continue;
          }
          var r0 = red[redPtr + axis];
          var r1 = red[redPtr + axis + d];
          if (blueX < r0 || r1 < blueX) {
            continue;
          }
          for (var j = axis + 1; j < d; ++j) {
            var r0 = red[redPtr + j];
            var r1 = red[redPtr + j + d];
            var b0 = blue[bluePtr + j];
            var b1 = blue[bluePtr + j + d];
            if (r1 < b0 || b1 < r0) {
              continue red_loop;
            }
          }
          var retval = visit(redId, blueId);
          if (retval !== void 0) {
            return retval;
          }
        }
    }
    function boxIntersectIter(d, visit, initFull, xSize, xBoxes, xIndex, ySize, yBoxes, yIndex) {
      iterInit(d, xSize + ySize);
      var top = 0;
      var elemSize = 2 * d;
      var retval;
      iterPush(
        top++,
        0,
        0,
        xSize,
        0,
        ySize,
        initFull ? 16 : 0,
        -Infinity,
        Infinity
      );
      if (!initFull) {
        iterPush(
          top++,
          0,
          0,
          ySize,
          0,
          xSize,
          1,
          -Infinity,
          Infinity
        );
      }
      while (top > 0) {
        top -= 1;
        var iptr = top * IFRAME_SIZE;
        var axis = BOX_ISTACK[iptr];
        var redStart = BOX_ISTACK[iptr + 1];
        var redEnd = BOX_ISTACK[iptr + 2];
        var blueStart = BOX_ISTACK[iptr + 3];
        var blueEnd = BOX_ISTACK[iptr + 4];
        var state = BOX_ISTACK[iptr + 5];
        var dptr = top * DFRAME_SIZE;
        var lo = BOX_DSTACK[dptr];
        var hi = BOX_DSTACK[dptr + 1];
        var flip = state & 1;
        var full = !!(state & 16);
        var red = xBoxes;
        var redIndex = xIndex;
        var blue = yBoxes;
        var blueIndex = yIndex;
        if (flip) {
          red = yBoxes;
          redIndex = yIndex;
          blue = xBoxes;
          blueIndex = xIndex;
        }
        if (state & 2) {
          redEnd = partitionStartLessThan(
            d,
            axis,
            redStart,
            redEnd,
            red,
            redIndex,
            hi
          );
          if (redStart >= redEnd) {
            continue;
          }
        }
        if (state & 4) {
          redStart = partitionEndLessThanEqual(
            d,
            axis,
            redStart,
            redEnd,
            red,
            redIndex,
            lo
          );
          if (redStart >= redEnd) {
            continue;
          }
        }
        var redCount = redEnd - redStart;
        var blueCount = blueEnd - blueStart;
        if (full) {
          if (d * redCount * (redCount + blueCount) < SCAN_COMPLETE_CUTOFF) {
            retval = sweep3.scanComplete(
              d,
              axis,
              visit,
              redStart,
              redEnd,
              red,
              redIndex,
              blueStart,
              blueEnd,
              blue,
              blueIndex
            );
            if (retval !== void 0) {
              return retval;
            }
            continue;
          }
        } else {
          if (d * Math.min(redCount, blueCount) < BRUTE_FORCE_CUTOFF) {
            retval = bruteForcePartial(
              d,
              axis,
              visit,
              flip,
              redStart,
              redEnd,
              red,
              redIndex,
              blueStart,
              blueEnd,
              blue,
              blueIndex
            );
            if (retval !== void 0) {
              return retval;
            }
            continue;
          } else if (d * redCount * blueCount < SCAN_CUTOFF) {
            retval = sweep3.scanBipartite(
              d,
              axis,
              visit,
              flip,
              redStart,
              redEnd,
              red,
              redIndex,
              blueStart,
              blueEnd,
              blue,
              blueIndex
            );
            if (retval !== void 0) {
              return retval;
            }
            continue;
          }
        }
        var red0 = partitionInteriorContainsInterval(
          d,
          axis,
          redStart,
          redEnd,
          red,
          redIndex,
          lo,
          hi
        );
        if (redStart < red0) {
          if (d * (red0 - redStart) < BRUTE_FORCE_CUTOFF) {
            retval = bruteForceFull(
              d,
              axis + 1,
              visit,
              redStart,
              red0,
              red,
              redIndex,
              blueStart,
              blueEnd,
              blue,
              blueIndex
            );
            if (retval !== void 0) {
              return retval;
            }
          } else if (axis === d - 2) {
            if (flip) {
              retval = sweep3.sweepBipartite(
                d,
                visit,
                blueStart,
                blueEnd,
                blue,
                blueIndex,
                redStart,
                red0,
                red,
                redIndex
              );
            } else {
              retval = sweep3.sweepBipartite(
                d,
                visit,
                redStart,
                red0,
                red,
                redIndex,
                blueStart,
                blueEnd,
                blue,
                blueIndex
              );
            }
            if (retval !== void 0) {
              return retval;
            }
          } else {
            iterPush(
              top++,
              axis + 1,
              redStart,
              red0,
              blueStart,
              blueEnd,
              flip,
              -Infinity,
              Infinity
            );
            iterPush(
              top++,
              axis + 1,
              blueStart,
              blueEnd,
              redStart,
              red0,
              flip ^ 1,
              -Infinity,
              Infinity
            );
          }
        }
        if (red0 < redEnd) {
          var blue0 = findMedian(
            d,
            axis,
            blueStart,
            blueEnd,
            blue,
            blueIndex
          );
          var mid = blue[elemSize * blue0 + axis];
          var blue1 = partitionStartEqual(
            d,
            axis,
            blue0,
            blueEnd,
            blue,
            blueIndex,
            mid
          );
          if (blue1 < blueEnd) {
            iterPush(
              top++,
              axis,
              red0,
              redEnd,
              blue1,
              blueEnd,
              (flip | 4) + (full ? 16 : 0),
              mid,
              hi
            );
          }
          if (blueStart < blue0) {
            iterPush(
              top++,
              axis,
              red0,
              redEnd,
              blueStart,
              blue0,
              (flip | 2) + (full ? 16 : 0),
              lo,
              mid
            );
          }
          if (blue0 + 1 === blue1) {
            if (full) {
              retval = onePointFull(
                d,
                axis,
                visit,
                red0,
                redEnd,
                red,
                redIndex,
                blue0,
                blue,
                blueIndex[blue0]
              );
            } else {
              retval = onePointPartial(
                d,
                axis,
                visit,
                flip,
                red0,
                redEnd,
                red,
                redIndex,
                blue0,
                blue,
                blueIndex[blue0]
              );
            }
            if (retval !== void 0) {
              return retval;
            }
          } else if (blue0 < blue1) {
            var red1;
            if (full) {
              red1 = partitionContainsPoint(
                d,
                axis,
                red0,
                redEnd,
                red,
                redIndex,
                mid
              );
              if (red0 < red1) {
                var redX = partitionStartEqual(
                  d,
                  axis,
                  red0,
                  red1,
                  red,
                  redIndex,
                  mid
                );
                if (axis === d - 2) {
                  if (red0 < redX) {
                    retval = sweep3.sweepComplete(
                      d,
                      visit,
                      red0,
                      redX,
                      red,
                      redIndex,
                      blue0,
                      blue1,
                      blue,
                      blueIndex
                    );
                    if (retval !== void 0) {
                      return retval;
                    }
                  }
                  if (redX < red1) {
                    retval = sweep3.sweepBipartite(
                      d,
                      visit,
                      redX,
                      red1,
                      red,
                      redIndex,
                      blue0,
                      blue1,
                      blue,
                      blueIndex
                    );
                    if (retval !== void 0) {
                      return retval;
                    }
                  }
                } else {
                  if (red0 < redX) {
                    iterPush(
                      top++,
                      axis + 1,
                      red0,
                      redX,
                      blue0,
                      blue1,
                      16,
                      -Infinity,
                      Infinity
                    );
                  }
                  if (redX < red1) {
                    iterPush(
                      top++,
                      axis + 1,
                      redX,
                      red1,
                      blue0,
                      blue1,
                      0,
                      -Infinity,
                      Infinity
                    );
                    iterPush(
                      top++,
                      axis + 1,
                      blue0,
                      blue1,
                      redX,
                      red1,
                      1,
                      -Infinity,
                      Infinity
                    );
                  }
                }
              }
            } else {
              if (flip) {
                red1 = partitionContainsPointProper(
                  d,
                  axis,
                  red0,
                  redEnd,
                  red,
                  redIndex,
                  mid
                );
              } else {
                red1 = partitionContainsPoint(
                  d,
                  axis,
                  red0,
                  redEnd,
                  red,
                  redIndex,
                  mid
                );
              }
              if (red0 < red1) {
                if (axis === d - 2) {
                  if (flip) {
                    retval = sweep3.sweepBipartite(
                      d,
                      visit,
                      blue0,
                      blue1,
                      blue,
                      blueIndex,
                      red0,
                      red1,
                      red,
                      redIndex
                    );
                  } else {
                    retval = sweep3.sweepBipartite(
                      d,
                      visit,
                      red0,
                      red1,
                      red,
                      redIndex,
                      blue0,
                      blue1,
                      blue,
                      blueIndex
                    );
                  }
                } else {
                  iterPush(
                    top++,
                    axis + 1,
                    red0,
                    red1,
                    blue0,
                    blue1,
                    flip,
                    -Infinity,
                    Infinity
                  );
                  iterPush(
                    top++,
                    axis + 1,
                    blue0,
                    blue1,
                    red0,
                    red1,
                    flip ^ 1,
                    -Infinity,
                    Infinity
                  );
                }
              }
            }
          }
        }
      }
    }
  }
});

// node_modules/box-intersect/index.js
var require_box_intersect = __commonJS({
  "node_modules/box-intersect/index.js"(exports, module) {
    "use strict";
    module.exports = boxIntersectWrapper;
    var pool = require_pool();
    var sweep3 = require_sweep();
    var boxIntersectIter = require_intersect();
    function boxEmpty(d, box) {
      for (var j = 0; j < d; ++j) {
        if (!(box[j] <= box[j + d])) {
          return true;
        }
      }
      return false;
    }
    function convertBoxes(boxes, d, data, ids) {
      var ptr = 0;
      var count = 0;
      for (var i = 0, n = boxes.length; i < n; ++i) {
        var b = boxes[i];
        if (boxEmpty(d, b)) {
          continue;
        }
        for (var j = 0; j < 2 * d; ++j) {
          data[ptr++] = b[j];
        }
        ids[count++] = i;
      }
      return count;
    }
    function boxIntersect2(red, blue, visit, full) {
      var n = red.length;
      var m = blue.length;
      if (n <= 0 || m <= 0) {
        return;
      }
      var d = red[0].length >>> 1;
      if (d <= 0) {
        return;
      }
      var retval;
      var redList = pool.mallocDouble(2 * d * n);
      var redIds = pool.mallocInt32(n);
      n = convertBoxes(red, d, redList, redIds);
      if (n > 0) {
        if (d === 1 && full) {
          sweep3.init(n);
          retval = sweep3.sweepComplete(
            d,
            visit,
            0,
            n,
            redList,
            redIds,
            0,
            n,
            redList,
            redIds
          );
        } else {
          var blueList = pool.mallocDouble(2 * d * m);
          var blueIds = pool.mallocInt32(m);
          m = convertBoxes(blue, d, blueList, blueIds);
          if (m > 0) {
            sweep3.init(n + m);
            if (d === 1) {
              retval = sweep3.sweepBipartite(
                d,
                visit,
                0,
                n,
                redList,
                redIds,
                0,
                m,
                blueList,
                blueIds
              );
            } else {
              retval = boxIntersectIter(
                d,
                visit,
                full,
                n,
                redList,
                redIds,
                m,
                blueList,
                blueIds
              );
            }
            pool.free(blueList);
            pool.free(blueIds);
          }
        }
        pool.free(redList);
        pool.free(redIds);
      }
      return retval;
    }
    var RESULT;
    function appendItem(i, j) {
      RESULT.push([i, j]);
    }
    function intersectFullArray(x) {
      RESULT = [];
      boxIntersect2(x, x, appendItem, true);
      return RESULT;
    }
    function intersectBipartiteArray(x, y) {
      RESULT = [];
      boxIntersect2(x, y, appendItem, false);
      return RESULT;
    }
    function boxIntersectWrapper(arg0, arg1, arg2) {
      var result;
      switch (arguments.length) {
        case 1:
          return intersectFullArray(arg0);
        case 2:
          if (typeof arg1 === "function") {
            return boxIntersect2(arg0, arg0, arg1, true);
          } else {
            return intersectBipartiteArray(arg0, arg1);
          }
        case 3:
          return boxIntersect2(arg0, arg1, arg2, false);
        default:
          throw new Error("box-intersect: Invalid arguments");
      }
    }
  }
});

// node_modules/noa-engine/src/lib/shims.js
if (window && !window["global"]) {
  window["global"] = window.globalThis || {};
}

// node_modules/noa-engine/src/index.js
var import_events4 = __toESM(require_events());
var import_gl_vec312 = __toESM(require_gl_vec3());
var import_ndarray3 = __toESM(require_ndarray());
var import_fast_voxel_raycast = __toESM(require_fast_voxel_raycast());

// node_modules/game-inputs/src/inputs.js
var import_events = __toESM(require_events());

// node_modules/game-inputs/package.json
var package_default = {
  name: "game-inputs",
  version: "0.8.0",
  description: "Simple library to abstract key/mouse events for games.",
  main: "src/inputs.js",
  typings: "dist/src/inputs.d.ts",
  files: [
    "/src",
    "/dist"
  ],
  scripts: {
    start: "cd docs/ && webpack serve",
    build: "tsc; cd docs/ && webpack"
  },
  author: "Andy Hall",
  license: "ISC",
  keywords: [
    "game",
    "inputs",
    "key",
    "mouse",
    "events"
  ],
  dependencies: {
    events: "^3.3.0"
  },
  repository: {
    type: "git",
    url: "https://github.com/fenomas/game-inputs"
  },
  bugs: {
    url: "https://github.com/fenomas/game-inputs/issues"
  }
};

// node_modules/game-inputs/src/inputs.js
var version = package_default.version;
function DefaultOptions() {
  this.preventDefaults = false;
  this.stopPropagation = false;
  this.allowContextMenu = false;
  this.disabled = false;
}
var GameInputs = class {
  /**
   *   Simple inputs manager to abstract key/mouse inputs.
   * 
   * @param {HTMLElement} domElement
   * @param {DefaultOptions} options
  */
  constructor(domElement, options) {
    this.version = version;
    var opts = Object.assign({}, new DefaultOptions(), options || {});
    this.element = domElement || document;
    this.preventDefaults = !!opts.preventDefaults;
    this.stopPropagation = !!opts.stopPropagation;
    this.allowContextMenu = !!opts.allowContextMenu;
    this.disabled = !!opts.disabled;
    this.filterEvents = (ev, bindingName) => true;
    this.down = new import_events.EventEmitter();
    this.up = new import_events.EventEmitter();
    this.state = {};
    this.pointerState = {
      dx: 0,
      dy: 0,
      scrollx: 0,
      scrolly: 0,
      scrollz: 0
    };
    this.pressCount = {};
    this.releaseCount = {};
    this._keyBindmap = {};
    this._keyStates = {};
    this._bindPressCount = {};
    this._touches = { lastX: 0, lastY: 0, currID: null };
    this._pressedDuringMeta = {};
    if (document.readyState !== "loading") {
      initEvents(this);
    } else {
      document.addEventListener("DOMContentLoaded", (ev) => {
        initEvents(this);
      }, { once: true });
    }
  }
  /**
   * Binds one or more physical keys to an arbitrary binding name.
   * Key strings should align to `KeyboardEvent.code` strings - 
   * e.g. `KeyA`, `ArrowDown`, etc.
   * 
   * `inputs.bind('move-player-left', 'KeyW', 'ArrowLeft')
   * 
   * @param {string} bindingName 
   * @param {...string} keys 
   */
  bind(bindingName, ...keys) {
    keys.forEach((code) => {
      var bindings = this._keyBindmap[code] || [];
      if (bindings.includes(bindingName)) return;
      bindings.push(bindingName);
      this._keyBindmap[code] = bindings;
    });
    this.state[bindingName] = !!this.state[bindingName];
    this.pressCount[bindingName] = this.pressCount[bindingName] || 0;
    this.releaseCount[bindingName] = this.releaseCount[bindingName] || 0;
  }
  /**
   * Removes all key bindings for a given binding name.
   * 
   * `inputs.unbind('move-player-left')
   */
  unbind(bindingName) {
    for (var code in this._keyBindmap) {
      var bindings = this._keyBindmap[code];
      var i = bindings.indexOf(bindingName);
      if (i > -1) {
        bindings.splice(i, 1);
      }
    }
  }
  /**
   * Returns a copy of all existing bindings, in the format:
   * ```js
   *   {
   *      bindingName: [ keyCode1, keyCode2, ... ]
   *      ...
   *   }
   * ```
   */
  getBindings() {
    var res = {};
    for (var code in this._keyBindmap) {
      var bindings = this._keyBindmap[code];
      bindings.forEach((bindingName) => {
        res[bindingName] = res[bindingName] || [];
        res[bindingName].push(code);
      });
    }
    return res;
  }
  /**
   * Tick function - clears out all cumulative counters
  */
  tick() {
    zeroAllProperties(this.pointerState);
    zeroAllProperties(this.pressCount);
    zeroAllProperties(this.releaseCount);
  }
};
function zeroAllProperties(obj) {
  for (var key in obj) obj[key] = 0;
}
function initEvents(inputs) {
  window.addEventListener("keydown", onKeyEvent.bind(null, inputs, true), false);
  window.addEventListener("keyup", onKeyEvent.bind(null, inputs, false), false);
  var pointerOpts = { passive: true };
  if (window.PointerEvent) {
    inputs.element.addEventListener("pointerdown", onPointerEvent.bind(null, inputs, true), pointerOpts);
    window.document.addEventListener("pointerup", onPointerEvent.bind(null, inputs, false), pointerOpts);
    inputs.element.addEventListener("pointermove", onPointerMove.bind(null, inputs), pointerOpts);
  } else {
    inputs.element.addEventListener("mousedown", onPointerEvent.bind(null, inputs, true), pointerOpts);
    window.document.addEventListener("mouseup", onPointerEvent.bind(null, inputs, false), pointerOpts);
    inputs.element.addEventListener("mousemove", onPointerMove.bind(null, inputs), pointerOpts);
  }
  inputs.element.addEventListener("wheel", onWheelEvent.bind(null, inputs), pointerOpts);
  inputs.element.addEventListener("contextmenu", onContextMenu.bind(null, inputs), false);
  window.addEventListener("blur", onWindowBlur.bind(null, inputs), false);
}
function onKeyEvent(inputs, nowDown, ev) {
  handleKeyEvent(ev.code, nowDown, inputs, ev);
  workaroundMacBug(nowDown, inputs, ev);
}
function onPointerEvent(inputs, nowDown, ev) {
  if ("pointerId" in ev) {
    if (nowDown) {
      if (inputs._touches.currID !== null) return;
      inputs._touches.currID = ev.pointerId;
    } else {
      if (inputs._touches.currID !== ev.pointerId) return;
      inputs._touches.currID = null;
    }
  }
  var button = "button" in ev ? ev.button + 1 : 1;
  handleKeyEvent("Mouse" + button, nowDown, inputs, ev);
  return false;
}
function onPointerMove(inputs, ev) {
  if ("pointerId" in ev && inputs._touches.currID !== null) {
    if (inputs._touches.currID !== ev.pointerId) return;
  }
  var dx2 = ev.movementX || ev.mozMovementX || 0, dy = ev.movementY || ev.mozMovementY || 0;
  inputs.pointerState.dx += dx2;
  inputs.pointerState.dy += dy;
}
function onWheelEvent(inputs, ev) {
  var scale3 = 1;
  switch (ev.deltaMode) {
    case 0:
      scale3 = 1;
      break;
    case 1:
      scale3 = 12;
      break;
    case 2:
      scale3 = inputs.element.clientHeight || window.innerHeight;
      break;
  }
  inputs.pointerState.scrollx += (ev.deltaX || 0) * scale3;
  inputs.pointerState.scrolly += (ev.deltaY || 0) * scale3;
  inputs.pointerState.scrollz += (ev.deltaZ || 0) * scale3;
}
function onContextMenu(inputs, ev) {
  if (!inputs.allowContextMenu) {
    ev.preventDefault();
    return false;
  }
}
function onWindowBlur(inputs) {
  for (var code in inputs._keyStates) {
    if (!inputs._keyStates[code]) continue;
    if (/^Mouse\d/.test(code)) continue;
    handleKeyEvent(code, false, inputs, {
      code,
      note: `This is a mocked KeyboardEvent made by the 'game-inputs' module`,
      preventDefault: () => {
      },
      stopPropagation: () => {
      }
    });
  }
}
function handleKeyEvent(code, nowDown, inputs, ev) {
  var bindings = inputs._keyBindmap[code];
  if (!bindings) return;
  var prevState = inputs._keyStates[code];
  if (XOR(prevState, nowDown)) {
    inputs._keyStates[code] = nowDown;
    bindings.forEach((bindingName) => {
      var allow = inputs.filterEvents ? inputs.filterEvents(ev, bindingName) : true;
      if (!allow) return;
      handleBindingEvent(bindingName, nowDown, inputs, ev);
    });
  }
  if (!("button" in ev)) {
    if (inputs.preventDefaults && !ev.defaultPrevented) {
      ev.preventDefault();
    }
    if (inputs.stopPropagation) ev.stopPropagation();
  }
}
function handleBindingEvent(bindingName, pressed, inputs, ev) {
  var counter = pressed ? inputs.pressCount : inputs.releaseCount;
  counter[bindingName] = (counter[bindingName] || 0) + 1;
  var ct = inputs._bindPressCount[bindingName] || 0;
  ct += pressed ? 1 : -1;
  if (ct < 0) {
    ct = 0;
  }
  inputs._bindPressCount[bindingName] = ct;
  var currstate = inputs.state[bindingName];
  if (XOR(currstate, ct)) {
    inputs.state[bindingName] = ct > 0;
    var emitter = pressed ? inputs.down : inputs.up;
    if (!inputs.disabled) emitter.emit(bindingName, ev);
  }
}
function XOR(a2, b) {
  return a2 ? !b : b;
}
function workaroundMacBug(down2, inputs, ev) {
  var isMeta = /^Meta/.test(ev.code);
  if (ev.metaKey && !isMeta && down2) {
    inputs._pressedDuringMeta[ev.code] = true;
  } else if (isMeta && !down2) {
    for (var code in inputs._pressedDuringMeta) {
      if (!inputs._keyStates[code]) continue;
      if (/^Mouse\d/.test(code)) continue;
      handleKeyEvent(code, false, inputs, {
        code,
        note: `This is a mocked KeyboardEvent made by the 'game-inputs' module`,
        preventDefault: () => {
        },
        stopPropagation: () => {
        }
      });
    }
    inputs._pressedDuringMeta = {};
  }
}

// node_modules/noa-engine/src/lib/inputs.js
var defaultOptions = {
  preventDefaults: false,
  stopPropagation: false,
  allowContextMenu: false
};
var defaultBindings = {
  "forward": ["KeyW", "ArrowUp"],
  "backward": ["KeyS", "ArrowDown"],
  "left": ["KeyA", "ArrowLeft"],
  "right": ["KeyD", "ArrowRight"],
  "fire": "Mouse1",
  "mid-fire": ["Mouse2", "KeyQ"],
  "alt-fire": ["Mouse3", "KeyE"],
  "jump": "Space"
};
var Inputs = class extends GameInputs {
  /** @internal */
  constructor(noa, opts, element) {
    opts = Object.assign({}, defaultOptions, opts);
    super(element, opts);
    var b = opts.bindings || defaultBindings;
    for (var name in b) {
      var keys = Array.isArray(b[name]) ? b[name] : [b[name]];
      this.bind(name, ...keys);
    }
  }
};

// node_modules/noa-engine/src/lib/container.js
var import_events2 = __toESM(require_events());

// node_modules/micro-game-shell/src/micro-game-shell.js
var MicroGameShell = class {
  constructor(domElement = null, pollTime = 10) {
    this.stickyPointerLock = false;
    this.stickyFullscreen = false;
    this.tickRate = 30;
    this.maxRenderRate = 0;
    this.maxTickTime = 100;
    this.pointerLock = false;
    this.fullscreen = false;
    this.onTick = function(dt) {
    };
    this.onRender = function(dt, framePart, tickDur) {
    };
    this.onInit = function() {
    };
    this.onResize = function() {
    };
    this.onPointerLockChanged = function(hasPL = false) {
    };
    this.onFullscreenChanged = function(hasFS = false) {
    };
    this.onPointerLockError = function(err) {
    };
    this._data = new Data(pollTime);
    domReady(() => {
      setupTimers(this);
      setupDomElement(this, domElement);
      this.onInit();
    });
  }
};
function Data(pollTime = 10) {
  this.nowObject = performance || Date;
  this.pollTime = pollTime;
  this.renderAccum = 0;
  this.lastTickStarted = 0;
  this.lastFrameStarted = 0;
  this.lastRenderStarted = 0;
  this.avgTickTime = 2;
  this.frameCB = null;
  this.intervalCB = null;
  this.intervalID = -1;
}
function setupTimers(shell) {
  var dat = shell._data;
  var now = dat.nowObject.now();
  dat.lastTickStarted = now;
  dat.lastFrameStarted = now;
  dat.lastRenderStarted = now;
  dat.frameCB = () => frameHandler(shell);
  dat.intervalCB = () => intervalHandler(shell);
  requestAnimationFrame(dat.frameCB);
  if (dat.pollTime > 0) {
    dat.intervalID = setInterval(dat.intervalCB, dat.pollTime);
  }
}
function frameHandler(shell) {
  var dat = shell._data;
  requestAnimationFrame(dat.frameCB);
  intervalHandler(shell);
  var now = dat.nowObject.now();
  var dt = now - dat.lastFrameStarted;
  dat.lastFrameStarted = now;
  if (shell.maxRenderRate > 0) {
    dat.renderAccum += dt;
    var frameDur = 1e3 / shell.maxRenderRate;
    if (dat.renderAccum < frameDur) return;
    dat.renderAccum -= frameDur;
    if (dat.renderAccum > frameDur) dat.renderAccum = frameDur;
  }
  var renderDt = now - dat.lastRenderStarted;
  dat.lastRenderStarted = now;
  var tickDur = 1e3 / shell.tickRate;
  var framePart = (now - dat.lastTickStarted) / tickDur;
  if (framePart < 0) framePart = 0;
  shell.onRender(renderDt, framePart, tickDur);
  setTimeout(intervalHandler, 0, shell, true);
}
function intervalHandler(shell, lookAhead = false) {
  var dat = shell._data;
  var now = dat.nowObject.now();
  var tickUntil = now;
  if (lookAhead) tickUntil += dat.avgTickTime;
  var cutoffTime = now + shell.maxTickTime;
  if (!(cutoffTime > now)) cutoffTime = now + 1;
  var tickDur = 1e3 / shell.tickRate;
  while (dat.lastTickStarted + tickDur < tickUntil) {
    shell.onTick(tickDur);
    dat.lastTickStarted += tickDur;
    var after = dat.nowObject.now();
    dat.avgTickTime = runningAverage(dat.avgTickTime, after - now);
    now = after;
    if (now > cutoffTime) {
      dat.lastTickStarted = now;
      return;
    }
  }
}
function setupDomElement(shell, el) {
  if (!el) return;
  var hasPL = false;
  var hasFS = false;
  var setPL = (want) => {
    hasPL = el === document.pointerLockElement;
    if (!!want === hasPL) return;
    if (want) {
      var res = el.requestPointerLock();
      if (res && res.catch) res.catch((err) => {
      });
    } else {
      document.exitPointerLock();
    }
  };
  var setFS = (want) => {
    hasFS = el === document.fullscreenElement;
    if (!!want === hasFS) return;
    if (want) {
      if (el.requestFullscreen) {
        el.requestFullscreen();
      } else if (el.webkitRequestFullscreen) {
        el.webkitRequestFullscreen();
      }
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document["webkitExitFullscreen"]) {
        document["webkitExitFullscreen"]();
      }
    }
  };
  document.addEventListener("pointerlockchange", (ev) => {
    hasPL = el === document.pointerLockElement;
    shell.onPointerLockChanged(hasPL);
  });
  document.addEventListener("fullscreenchange", (ev) => {
    hasFS = el === document.fullscreenElement;
    shell.onFullscreenChanged(hasFS);
  });
  document.addEventListener("pointerlockerror", (err) => {
    hasPL = el === document.pointerLockElement;
    shell.onPointerLockError(err);
  });
  Object.defineProperty(shell, "pointerLock", {
    get: () => hasPL,
    set: setPL
  });
  Object.defineProperty(shell, "fullscreen", {
    get: () => hasFS,
    set: setFS
  });
  el.addEventListener("click", (ev) => {
    if (shell.stickyPointerLock) setPL(true);
    if (shell.stickyFullscreen) setFS(true);
  });
  var resizeHandler = () => shell.onResize();
  if (window.ResizeObserver) {
    var observer = new ResizeObserver(resizeHandler);
    observer.observe(el);
  } else {
    window.addEventListener("resize", resizeHandler);
  }
}
function runningAverage(avg, newVal) {
  if (newVal > avg * 4) newVal = avg * 4;
  if (newVal < avg * 0.25) newVal = avg * 0.25;
  return 0.9 * avg + 0.1 * newVal;
}
function domReady(fn) {
  if (document.readyState === "loading") {
    var handler = () => {
      document.removeEventListener("readystatechange", handler);
      fn();
    };
    document.addEventListener("readystatechange", handler);
  } else {
    setTimeout(fn, 0);
  }
}

// node_modules/noa-engine/src/lib/container.js
var Container = class extends import_events2.EventEmitter {
  /** @internal */
  constructor(noa, opts) {
    super();
    opts = opts || {};
    this.noa = noa;
    var domEl = opts.domElement || null;
    if (typeof domEl === "string") {
      domEl = document.querySelector(domEl);
    }
    this.element = domEl || createContainerDiv();
    this.canvas = getOrCreateCanvas(this.element);
    doCanvasBugfix(noa, this.canvas);
    this.supportsPointerLock = false;
    this.pointerInGame = false;
    this.isFocused = !!document.hasFocus();
    this.hasPointerLock = false;
    var pollTime = 10;
    this._shell = new MicroGameShell(this.element, pollTime);
    this._shell.tickRate = opts.tickRate;
    this._shell.maxRenderRate = opts.maxRenderRate;
    this._shell.stickyPointerLock = opts.stickyPointerLock;
    this._shell.stickyFullscreen = opts.stickyFullscreen;
    this._shell.maxTickTime = 50;
    this._shell.onTick = noa.tick.bind(noa);
    this._shell.onRender = noa.render.bind(noa);
    this._shell.onPointerLockChanged = (hasPL) => {
      this.hasPointerLock = hasPL;
      this.emit(hasPL ? "gainedPointerLock" : "lostPointerLock");
      if (hasPL) this.pointerInGame = true;
    };
    this._shell.onInit = () => {
      this._shell.onResize = noa.rendering.resize.bind(noa.rendering);
      detectPointerLock(this);
      this.element.addEventListener("mouseenter", () => {
        this.pointerInGame = true;
      });
      this.element.addEventListener("mouseleave", () => {
        this.pointerInGame = false;
      });
      window.addEventListener("focus", () => {
        this.isFocused = true;
      });
      window.addEventListener("blur", () => {
        this.isFocused = false;
      });
      var onFirstMousedown = () => {
        this.pointerInGame = true;
        this.isFocused = true;
        this.element.removeEventListener("mousedown", onFirstMousedown);
      };
      this.element.addEventListener("mousedown", onFirstMousedown);
      this.emit("DOMready");
      this._shell.onInit = null;
    };
  }
  /*
   *
   *
   *              PUBLIC API 
   *
   *
  */
  /** @internal */
  appendTo(htmlElement) {
    this.element.appendChild(htmlElement);
  }
  /** 
   * Sets whether `noa` should try to acquire or release pointerLock
  */
  setPointerLock(lock = false) {
    this._shell.pointerLock = !!lock;
  }
};
function createContainerDiv() {
  var container = document.createElement("div");
  container.tabIndex = 1;
  container.style.position = "fixed";
  container.style.left = "0px";
  container.style.right = "0px";
  container.style.top = "0px";
  container.style.bottom = "0px";
  container.style.height = "100%";
  container.style.overflow = "hidden";
  document.body.appendChild(container);
  document.body.style.overflow = "hidden";
  document.body.style.height = "100%";
  container.id = "noa-container";
  return container;
}
function getOrCreateCanvas(el) {
  var canvas = el.querySelector("canvas");
  if (!canvas) {
    canvas = document.createElement("canvas");
    canvas.style.position = "absolute";
    canvas.style.left = "0px";
    canvas.style.top = "0px";
    canvas.style.height = "100%";
    canvas.style.width = "100%";
    canvas.id = "noa-canvas";
    el.insertBefore(canvas, el.firstChild);
  }
  return canvas;
}
function detectPointerLock(self) {
  var lockElementExists = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document;
  if (lockElementExists) {
    self.supportsPointerLock = true;
    var listener = function(e) {
      self.supportsPointerLock = false;
      document.removeEventListener(e.type, listener);
    };
    document.addEventListener("touchmove", listener);
  }
}
function doCanvasBugfix(noa, canvas) {
  var ct = 0;
  var fixCanvas = () => {
    var w = canvas.width;
    canvas.width = w + 1;
    canvas.width = w;
    if (ct++ > 10) noa.off("beforeRender", fixCanvas);
  };
  noa.on("beforeRender", fixCanvas);
}

// node_modules/noa-engine/src/lib/camera.js
var import_gl_vec3 = __toESM(require_gl_vec3());

// node_modules/gl-matrix/esm/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
function round(a2) {
  if (a2 >= 0) return Math.round(a2);
  return a2 % 0.5 === 0 ? Math.floor(a2) : Math.round(a2);
}
var degree = Math.PI / 180;
var radian = 180 / Math.PI;

// node_modules/gl-matrix/esm/mat3.js
function create() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}

// node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone,
  copy: () => copy,
  create: () => create2,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals,
  exactEquals: () => exactEquals,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max,
  min: () => min,
  mul: () => mul,
  multiply: () => multiply,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  round: () => round2,
  scale: () => scale,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set,
  slerp: () => slerp,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create2() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone(a2) {
  var out = new ARRAY_TYPE(3);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  return out;
}
function length(a2) {
  var x = a2[0];
  var y = a2[1];
  var z = a2[2];
  return Math.sqrt(x * x + y * y + z * z);
}
function fromValues(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  return out;
}
function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add(out, a2, b) {
  out[0] = a2[0] + b[0];
  out[1] = a2[1] + b[1];
  out[2] = a2[2] + b[2];
  return out;
}
function subtract(out, a2, b) {
  out[0] = a2[0] - b[0];
  out[1] = a2[1] - b[1];
  out[2] = a2[2] - b[2];
  return out;
}
function multiply(out, a2, b) {
  out[0] = a2[0] * b[0];
  out[1] = a2[1] * b[1];
  out[2] = a2[2] * b[2];
  return out;
}
function divide(out, a2, b) {
  out[0] = a2[0] / b[0];
  out[1] = a2[1] / b[1];
  out[2] = a2[2] / b[2];
  return out;
}
function ceil(out, a2) {
  out[0] = Math.ceil(a2[0]);
  out[1] = Math.ceil(a2[1]);
  out[2] = Math.ceil(a2[2]);
  return out;
}
function floor(out, a2) {
  out[0] = Math.floor(a2[0]);
  out[1] = Math.floor(a2[1]);
  out[2] = Math.floor(a2[2]);
  return out;
}
function min(out, a2, b) {
  out[0] = Math.min(a2[0], b[0]);
  out[1] = Math.min(a2[1], b[1]);
  out[2] = Math.min(a2[2], b[2]);
  return out;
}
function max(out, a2, b) {
  out[0] = Math.max(a2[0], b[0]);
  out[1] = Math.max(a2[1], b[1]);
  out[2] = Math.max(a2[2], b[2]);
  return out;
}
function round2(out, a2) {
  out[0] = round(a2[0]);
  out[1] = round(a2[1]);
  out[2] = round(a2[2]);
  return out;
}
function scale(out, a2, b) {
  out[0] = a2[0] * b;
  out[1] = a2[1] * b;
  out[2] = a2[2] * b;
  return out;
}
function scaleAndAdd(out, a2, b, scale3) {
  out[0] = a2[0] + b[0] * scale3;
  out[1] = a2[1] + b[1] * scale3;
  out[2] = a2[2] + b[2] * scale3;
  return out;
}
function distance(a2, b) {
  var x = b[0] - a2[0];
  var y = b[1] - a2[1];
  var z = b[2] - a2[2];
  return Math.sqrt(x * x + y * y + z * z);
}
function squaredDistance(a2, b) {
  var x = b[0] - a2[0];
  var y = b[1] - a2[1];
  var z = b[2] - a2[2];
  return x * x + y * y + z * z;
}
function squaredLength(a2) {
  var x = a2[0];
  var y = a2[1];
  var z = a2[2];
  return x * x + y * y + z * z;
}
function negate(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  out[2] = -a2[2];
  return out;
}
function inverse(out, a2) {
  out[0] = 1 / a2[0];
  out[1] = 1 / a2[1];
  out[2] = 1 / a2[2];
  return out;
}
function normalize(out, a2) {
  var x = a2[0];
  var y = a2[1];
  var z = a2[2];
  var len2 = x * x + y * y + z * z;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
  }
  out[0] = a2[0] * len2;
  out[1] = a2[1] * len2;
  out[2] = a2[2] * len2;
  return out;
}
function dot(a2, b) {
  return a2[0] * b[0] + a2[1] * b[1] + a2[2] * b[2];
}
function cross(out, a2, b) {
  var ax = a2[0], ay = a2[1], az = a2[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a2, b, t) {
  var ax = a2[0];
  var ay = a2[1];
  var az = a2[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function slerp(out, a2, b, t) {
  var angle2 = Math.acos(Math.min(Math.max(dot(a2, b), -1), 1));
  var sinTotal = Math.sin(angle2);
  var ratioA = Math.sin((1 - t) * angle2) / sinTotal;
  var ratioB = Math.sin(t * angle2) / sinTotal;
  out[0] = ratioA * a2[0] + ratioB * b[0];
  out[1] = ratioA * a2[1] + ratioB * b[1];
  out[2] = ratioA * a2[2] + ratioB * b[2];
  return out;
}
function hermite(out, a2, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a2[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a2[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a2[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function bezier(out, a2, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a2[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a2[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a2[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function random(out, scale3) {
  scale3 = scale3 === void 0 ? 1 : scale3;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale3;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale3;
  return out;
}
function transformMat4(out, a2, m) {
  var x = a2[0], y = a2[1], z = a2[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformMat3(out, a2, m) {
  var x = a2[0], y = a2[1], z = a2[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat(out, a2, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var vx = a2[0], vy = a2[1], vz = a2[2];
  var tx = qy * vz - qz * vy;
  var ty = qz * vx - qx * vz;
  var tz = qx * vy - qy * vx;
  tx = tx + tx;
  ty = ty + ty;
  tz = tz + tz;
  out[0] = vx + qw * tx + qy * tz - qz * ty;
  out[1] = vy + qw * ty + qz * tx - qx * tz;
  out[2] = vz + qw * tz + qx * ty - qy * tx;
  return out;
}
function rotateX(out, a2, b, rad) {
  var p = [], r = [];
  p[0] = a2[0] - b[0];
  p[1] = a2[1] - b[1];
  p[2] = a2[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY(out, a2, b, rad) {
  var p = [], r = [];
  p[0] = a2[0] - b[0];
  p[1] = a2[1] - b[1];
  p[2] = a2[2] - b[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ(out, a2, b, rad) {
  var p = [], r = [];
  p[0] = a2[0] - b[0];
  p[1] = a2[1] - b[1];
  p[2] = a2[2] - b[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a2, b) {
  var ax = a2[0], ay = a2[1], az = a2[2], bx = b[0], by = b[1], bz = b[2], mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz)), cosine = mag && dot(a2, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str(a2) {
  return "vec3(" + a2[0] + ", " + a2[1] + ", " + a2[2] + ")";
}
function exactEquals(a2, b) {
  return a2[0] === b[0] && a2[1] === b[1] && a2[2] === b[2];
}
function equals(a2, b) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2));
}
var sub = subtract;
var mul = multiply;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
  var vec = create2();
  return function(a2, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a2.length);
    } else {
      l = a2.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a2[i];
      vec[1] = a2[i + 1];
      vec[2] = a2[i + 2];
      fn(vec, vec, arg);
      a2[i] = vec[0];
      a2[i + 1] = vec[1];
      a2[i + 2] = vec[2];
    }
    return a2;
  };
}();

// node_modules/gl-matrix/esm/vec4.js
function create3() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function normalize2(out, a2) {
  var x = a2[0];
  var y = a2[1];
  var z = a2[2];
  var w = a2[3];
  var len2 = x * x + y * y + z * z + w * w;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
  }
  out[0] = x * len2;
  out[1] = y * len2;
  out[2] = z * len2;
  out[3] = w * len2;
  return out;
}
var forEach2 = function() {
  var vec = create3();
  return function(a2, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a2.length);
    } else {
      l = a2.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a2[i];
      vec[1] = a2[i + 1];
      vec[2] = a2[i + 2];
      vec[3] = a2[i + 3];
      fn(vec, vec, arg);
      a2[i] = vec[0];
      a2[i + 1] = vec[1];
      a2[i + 2] = vec[2];
      a2[i + 3] = vec[3];
    }
    return a2;
  };
}();

// node_modules/gl-matrix/esm/quat.js
function create4() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function slerp2(out, a2, b, t) {
  var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
var normalize3 = normalize2;
var rotationTo = function() {
  var tmpvec3 = create2();
  var xUnitVec3 = fromValues(1, 0, 0);
  var yUnitVec3 = fromValues(0, 1, 0);
  return function(out, a2, b) {
    var dot4 = dot(a2, b);
    if (dot4 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a2);
      if (len(tmpvec3) < 1e-6) cross(tmpvec3, yUnitVec3, a2);
      normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot4 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a2, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot4;
      return normalize3(out, out);
    }
  };
}();
var sqlerp = function() {
  var temp1 = create4();
  var temp2 = create4();
  return function(out, a2, b, c, d, t) {
    slerp2(temp1, a2, d, t);
    slerp2(temp2, b, c, t);
    slerp2(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
var setAxes = function() {
  var matr = create();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize3(out, fromMat3(out, matr));
  };
}();

// node_modules/gl-matrix/esm/vec2.js
function create5() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
var forEach3 = function() {
  var vec = create5();
  return function(a2, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a2.length);
    } else {
      l = a2.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a2[i];
      vec[1] = a2[i + 1];
      fn(vec, vec, arg);
      a2[i] = vec[0];
      a2[i + 1] = vec[1];
    }
    return a2;
  };
}();

// node_modules/aabb-3d/dist/index.js
var AABB = class _AABB {
  constructor(pos, vec) {
    __publicField(this, "base");
    __publicField(this, "vec");
    __publicField(this, "max");
    __publicField(this, "mag");
    const pos2 = vec3_exports.create();
    vec3_exports.add(pos2, pos, vec);
    this.base = vec3_exports.min(vec3_exports.create(), pos, pos2);
    this.vec = vec3_exports.clone(vec);
    this.max = vec3_exports.max(vec3_exports.create(), pos, pos2);
    this.mag = vec3_exports.length(this.vec);
  }
  width() {
    return this.vec[0];
  }
  height() {
    return this.vec[1];
  }
  depth() {
    return this.vec[2];
  }
  x0() {
    return this.base[0];
  }
  y0() {
    return this.base[1];
  }
  z0() {
    return this.base[2];
  }
  x1() {
    return this.max[0];
  }
  y1() {
    return this.max[1];
  }
  z1() {
    return this.max[2];
  }
  /**
   * Moves the box. Returns itself.
   */
  translate(by) {
    vec3_exports.add(this.max, this.max, by);
    vec3_exports.add(this.base, this.base, by);
    return this;
  }
  setPosition(pos) {
    vec3_exports.add(this.max, pos, this.vec);
    vec3_exports.copy(this.base, pos);
    return this;
  }
  /**
   * Returns a new `aabb` that surrounds both `aabb`'s.
   */
  expand(aabb) {
    const max2 = vec3_exports.create();
    const min2 = vec3_exports.create();
    vec3_exports.max(max2, aabb.max, this.max);
    vec3_exports.min(min2, aabb.base, this.base);
    vec3_exports.subtract(max2, max2, min2);
    return new _AABB(min2, max2);
  }
  /**
   * Returns `true` if the two bounding boxes intersect (or touch at all.)
   */
  intersects(aabb) {
    if (aabb.base[0] > this.max[0])
      return false;
    if (aabb.base[1] > this.max[1])
      return false;
    if (aabb.base[2] > this.max[2])
      return false;
    if (aabb.max[0] < this.base[0])
      return false;
    if (aabb.max[1] < this.base[1])
      return false;
    if (aabb.max[2] < this.base[2])
      return false;
    return true;
  }
  touches(aabb) {
    const intersection = this.union(aabb);
    return intersection !== null && (intersection.width() == 0 || intersection.height() == 0 || intersection.depth() == 0);
  }
  /**
   * Returns a new `aabb` representing the shared area of the
   * two `aabb`'s. returns `null` if the boxes don't intersect.
   */
  union(aabb) {
    if (!this.intersects(aabb))
      return null;
    const base_x = Math.max(aabb.base[0], this.base[0]);
    const base_y = Math.max(aabb.base[1], this.base[1]);
    const base_z = Math.max(aabb.base[2], this.base[2]);
    const max_x = Math.min(aabb.max[0], this.max[0]);
    const max_y = Math.min(aabb.max[1], this.max[1]);
    const max_z = Math.min(aabb.max[2], this.max[2]);
    return new _AABB([base_x, base_y, base_z], [max_x - base_x, max_y - base_y, max_z - base_z]);
  }
};

// node_modules/noa-engine/src/lib/camera.js
var import_voxel_aabb_sweep = __toESM(require_voxel_aabb_sweep());
function CameraDefaults() {
  this.inverseX = false;
  this.inverseY = false;
  this.sensitivityMult = 1;
  this.sensitivityMultOutsidePointerlock = 0;
  this.sensitivityX = 10;
  this.sensitivityY = 10;
  this.initialZoom = 0;
  this.zoomSpeed = 0.2;
}
var tempVectors = [
  import_gl_vec3.default.create(),
  import_gl_vec3.default.create(),
  import_gl_vec3.default.create()
];
var originVector = import_gl_vec3.default.create();
var Camera = class {
  /** 
   * @internal 
   * @param {import('../index').Engine} noa
   * @param {Partial.<CameraDefaults>} opts
  */
  constructor(noa, opts) {
    opts = Object.assign({}, new CameraDefaults(), opts);
    this.noa = noa;
    this.sensitivityX = +opts.sensitivityX;
    this.sensitivityY = +opts.sensitivityY;
    this.inverseX = !!opts.inverseX;
    this.inverseY = !!opts.inverseY;
    this.sensitivityMult = opts.sensitivityMult;
    this.sensitivityMultOutsidePointerlock = opts.sensitivityMultOutsidePointerlock;
    this.heading = 0;
    this.pitch = 0;
    this.cameraTarget = this.noa.ents.createEntity(["position"]);
    var eyeOffset = 0.9 * noa.ents.getPositionData(noa.playerEntity).height;
    noa.ents.addComponent(this.cameraTarget, "followsEntity", {
      entity: noa.playerEntity,
      offset: [0, eyeOffset, 0]
    });
    this.zoomDistance = opts.initialZoom;
    this.zoomSpeed = opts.zoomSpeed;
    this.currentZoom = opts.initialZoom;
    this._dirVector = import_gl_vec3.default.fromValues(0, 0, 1);
  }
  /*
   * 
   * 
   *          API
   * 
   * 
  */
  /*
   *      Local position functions for high precision
  */
  /** @internal */
  _localGetTargetPosition() {
    var pdat = this.noa.ents.getPositionData(this.cameraTarget);
    var pos = tempVectors[0];
    return import_gl_vec3.default.copy(pos, pdat._renderPosition);
  }
  /** @internal */
  _localGetPosition() {
    var loc = this._localGetTargetPosition();
    if (this.currentZoom === 0) return loc;
    return import_gl_vec3.default.scaleAndAdd(loc, loc, this._dirVector, -this.currentZoom);
  }
  /**
   * Returns the camera's current target position - i.e. the player's 
   * eye position. When the camera is zoomed all the way in, 
   * this returns the same location as `camera.getPosition()`.
  */
  getTargetPosition() {
    var loc = this._localGetTargetPosition();
    var globalCamPos = tempVectors[1];
    return this.noa.localToGlobal(loc, globalCamPos);
  }
  /**
   * Returns the current camera position (read only)
  */
  getPosition() {
    var loc = this._localGetPosition();
    var globalCamPos = tempVectors[2];
    return this.noa.localToGlobal(loc, globalCamPos);
  }
  /**
   * Returns the camera direction vector (read only)
  */
  getDirection() {
    return this._dirVector;
  }
  /*
   * 
   * 
   * 
   *          internals below
   * 
   * 
   * 
  */
  /**
   * Called before render, if mouseLock etc. is applicable.
   * Applies current mouse x/y inputs to the camera angle and zoom
   * @internal
  */
  applyInputsToCamera() {
    var senseMult = this.sensitivityMult;
    if (this.noa.container.supportsPointerLock) {
      if (!this.noa.container.hasPointerLock) {
        senseMult *= this.sensitivityMultOutsidePointerlock;
      }
    }
    if (senseMult === 0) return;
    var pointerState = this.noa.inputs.pointerState;
    bugFix(pointerState);
    var conv = 66e-4 * Math.PI / 180;
    var dx2 = pointerState.dx * this.sensitivityX * senseMult * conv;
    var dy = pointerState.dy * this.sensitivityY * senseMult * conv;
    if (this.inverseX) dx2 = -dx2;
    if (this.inverseY) dy = -dy;
    var twopi = 2 * Math.PI;
    this.heading += dx2 < 0 ? dx2 + twopi : dx2;
    if (this.heading > twopi) this.heading -= twopi;
    var maxPitch = Math.PI / 2 - 1e-3;
    this.pitch = Math.max(-maxPitch, Math.min(maxPitch, this.pitch + dy));
    import_gl_vec3.default.set(this._dirVector, 0, 0, 1);
    var dir = this._dirVector;
    var origin = originVector;
    import_gl_vec3.default.rotateX(dir, dir, origin, this.pitch);
    import_gl_vec3.default.rotateY(dir, dir, origin, this.heading);
  }
  /**
   *  Called before all renders, pre- and post- entity render systems
   * @internal
  */
  updateBeforeEntityRenderSystems() {
    this.currentZoom += (this.zoomDistance - this.currentZoom) * this.zoomSpeed;
  }
  /** @internal */
  updateAfterEntityRenderSystems() {
    var maxZoom = cameraObstructionDistance(this);
    if (this.currentZoom > maxZoom) this.currentZoom = maxZoom;
  }
};
function cameraObstructionDistance(self) {
  if (!self._sweepBox) {
    self._sweepBox = new AABB([0, 0, 0], [0.2, 0.2, 0.2]);
    self._sweepGetVoxel = self.noa.world.getBlockSolidity.bind(self.noa.world);
    self._sweepVec = import_gl_vec3.default.create();
    self._sweepHit = () => true;
  }
  var pos = import_gl_vec3.default.copy(self._sweepVec, self._localGetTargetPosition());
  import_gl_vec3.default.add(pos, pos, self.noa.worldOriginOffset);
  for (var i = 0; i < 3; i++) pos[i] -= 0.1;
  self._sweepBox.setPosition(pos);
  var dist2 = Math.max(self.zoomDistance, self.currentZoom) + 0.1;
  import_gl_vec3.default.scale(self._sweepVec, self.getDirection(), -dist2);
  return (0, import_voxel_aabb_sweep.default)(self._sweepGetVoxel, self._sweepBox, self._sweepVec, self._sweepHit, true);
}
function bugFix(pointerState) {
  var dx2 = pointerState.dx;
  var dy = pointerState.dy;
  var badx = Math.abs(dx2) > 400 && Math.abs(dx2 / lastx) > 4;
  var bady = Math.abs(dy) > 400 && Math.abs(dy / lasty) > 4;
  if (badx || bady) {
    pointerState.dx = lastx;
    pointerState.dy = lasty;
    lastx = (lastx + dx2) / 2;
    lasty = (lasty + dy) / 2;
  } else {
    lastx = dx2 || 1;
    lasty = dy || 1;
  }
}
var lastx = 0;
var lasty = 0;

// node_modules/noa-engine/src/lib/entities.js
var import_ent_comp = __toESM(require_ECS());
var import_gl_vec38 = __toESM(require_gl_vec3());

// node_modules/noa-engine/src/components/position.js
var import_gl_vec32 = __toESM(require_gl_vec3());
var PositionState = class {
  constructor() {
    this.position = null;
    this.width = 0.8;
    this.height = 0.8;
    this._localPosition = null;
    this._renderPosition = null;
    this._extents = null;
  }
};
function position_default(noa) {
  return {
    name: "position",
    order: 60,
    state: new PositionState(),
    onAdd: function(eid, state) {
      var pos = [0, 0, 0];
      if (state.position) import_gl_vec32.default.copy(pos, state.position);
      state.position = pos;
      state._localPosition = import_gl_vec32.default.create();
      state._renderPosition = import_gl_vec32.default.create();
      state._extents = new Float32Array(6);
      noa.globalToLocal(state.position, null, state._localPosition);
      import_gl_vec32.default.copy(state._renderPosition, state._localPosition);
      updatePositionExtents(state);
    },
    onRemove: null,
    system: function(dt, states) {
      var off = noa.worldOriginOffset;
      for (var i = 0; i < states.length; i++) {
        var state = states[i];
        import_gl_vec32.default.add(state.position, state._localPosition, off);
        updatePositionExtents(state);
      }
    }
  };
}
function updatePositionExtents(state) {
  var hw = state.width / 2;
  var lpos = state._localPosition;
  var ext = state._extents;
  ext[0] = lpos[0] - hw;
  ext[1] = lpos[1];
  ext[2] = lpos[2] - hw;
  ext[3] = lpos[0] + hw;
  ext[4] = lpos[1] + state.height;
  ext[5] = lpos[2] + hw;
}

// node_modules/noa-engine/src/components/physics.js
var import_gl_vec33 = __toESM(require_gl_vec3());
var PhysicsState = class {
  constructor() {
    this.body = null;
  }
};
function physics_default(noa) {
  return {
    name: "physics",
    order: 40,
    state: new PhysicsState(),
    onAdd: function(entID, state) {
      state.body = noa.physics.addBody();
      var posDat = noa.ents.getPositionData(state.__id);
      setPhysicsFromPosition(state, posDat);
    },
    onRemove: function(entID, state) {
      if (noa.ents.hasPosition(state.__id)) {
        var pdat = noa.ents.getPositionData(state.__id);
        setPositionFromPhysics(state, pdat);
        backtrackRenderPos(state, pdat, 0, false);
      }
      noa.physics.removeBody(state.body);
    },
    system: function(dt, states) {
      for (var i = 0; i < states.length; i++) {
        var state = states[i];
        var pdat = noa.ents.getPositionData(state.__id);
        setPositionFromPhysics(state, pdat);
      }
    },
    renderSystem: function(dt, states) {
      var tickPos = noa.positionInCurrentTick;
      var tickTime = 1e3 / noa.container._shell.tickRate;
      tickTime *= noa.timeScale;
      var tickMS = tickPos * tickTime;
      var backtrackAmt = (tickMS - tickTime) / 1e3;
      for (var i = 0; i < states.length; i++) {
        var state = states[i];
        var id = state.__id;
        var pdat = noa.ents.getPositionData(id);
        var smoothed = noa.ents.cameraSmoothed(id);
        backtrackRenderPos(state, pdat, backtrackAmt, smoothed);
      }
    }
  };
}
var local = import_gl_vec33.default.create();
function setPhysicsFromPosition(physState, posState) {
  var box = physState.body.aabb;
  var ext = posState._extents;
  import_gl_vec33.default.copy(box.base, ext);
  import_gl_vec33.default.set(box.vec, posState.width, posState.height, posState.width);
  import_gl_vec33.default.add(box.max, box.base, box.vec);
}
function setPositionFromPhysics(physState, posState) {
  var base = physState.body.aabb.base;
  var hw = posState.width / 2;
  import_gl_vec33.default.set(posState._localPosition, base[0] + hw, base[1], base[2] + hw);
}
function backtrackRenderPos(physState, posState, backtrackAmt, smoothed) {
  var vel = physState.body.velocity;
  import_gl_vec33.default.scaleAndAdd(local, posState._localPosition, vel, backtrackAmt);
  if (smoothed) import_gl_vec33.default.lerp(local, posState._renderPosition, local, 0.3);
  import_gl_vec33.default.copy(posState._renderPosition, local);
}

// node_modules/noa-engine/src/components/collideEntities.js
var import_box_intersect = __toESM(require_box_intersect());
function collideEntities_default(noa) {
  var intervals = [];
  return {
    name: "collideEntities",
    order: 70,
    state: {
      cylinder: false,
      collideBits: 1 | 0,
      collideMask: 1 | 0,
      callback: null
    },
    onAdd: null,
    onRemove: null,
    system: function entityCollider(dt, states) {
      var ents = noa.ents;
      for (var i = 0; i < states.length; i++) {
        var id = states[i].__id;
        var dat = ents.getPositionData(id);
        intervals[i] = dat._extents;
      }
      intervals.length = states.length;
      (0, import_box_intersect.default)(intervals, function(a2, b) {
        var stateA = states[a2];
        var stateB = states[b];
        if (!stateA || !stateB) return;
        var intervalA = intervals[a2];
        var intervalB = intervals[b];
        if (cylindricalHitTest(stateA, stateB, intervalA, intervalB)) {
          handleCollision(noa, stateA, stateB);
        }
      });
    }
  };
  function handleCollision(noa2, stateA, stateB) {
    var idA = stateA.__id;
    var idB = stateB.__id;
    if (stateA.collideMask & stateB.collideBits) {
      if (stateA.callback) stateA.callback(idB);
    }
    if (stateB.collideMask & stateA.collideBits) {
      if (stateB.callback) stateB.callback(idA);
    }
    noa2.ents.onPairwiseEntityCollision(idA, idB);
  }
  function cylindricalHitTest(stateA, stateB, intervalA, intervalB) {
    if (stateA.cylinder) {
      if (stateB.cylinder) {
        return cylinderCylinderTest(intervalA, intervalB);
      } else {
        return cylinderBoxTest(intervalA, intervalB);
      }
    } else if (stateB.cylinder) {
      return cylinderBoxTest(intervalB, intervalA);
    }
    return true;
  }
  function cylinderCylinderTest(a2, b) {
    var rada = (a2[3] - a2[0]) / 2;
    var radb = (b[3] - b[0]) / 2;
    var dx2 = a2[0] + rada - (b[0] + radb);
    var dz = a2[2] + rada - (b[2] + radb);
    var distsq = dx2 * dx2 + dz * dz;
    var radsum = rada + radb;
    return distsq <= radsum * radsum;
  }
  function cylinderBoxTest(cyl, cube) {
    var rad = (cyl[3] - cyl[0]) / 2;
    var cx = cyl[0] + rad;
    var cz = cyl[2] + rad;
    var px = clamp(cx, cube[0], cube[3]);
    var pz = clamp(cz, cube[2], cube[5]);
    var dx2 = px - cx;
    var dz = pz - cz;
    var distsq = dx2 * dx2 + dz * dz;
    return distsq <= rad * rad;
  }
  function clamp(val, lo, hi) {
    return val < lo ? lo : val > hi ? hi : val;
  }
}

// node_modules/noa-engine/src/components/collideTerrain.js
function collideTerrain_default(noa) {
  return {
    name: "collideTerrain",
    order: 0,
    state: {
      callback: null
    },
    onAdd: function(eid, state) {
      var ents = noa.entities;
      if (ents.hasPhysics(eid)) {
        var body = ents.getPhysics(eid).body;
        body.onCollide = function bodyOnCollide(impulse) {
          var cb = noa.ents.getCollideTerrain(eid).callback;
          if (cb) cb(impulse, eid);
        };
      }
    },
    onRemove: function(eid, state) {
      var ents = noa.entities;
      if (ents.hasPhysics(eid)) {
        ents.getPhysics(eid).body.onCollide = null;
      }
    }
  };
}

// node_modules/noa-engine/src/components/fadeOnZoom.js
function fadeOnZoom_default(noa) {
  return {
    name: "fadeOnZoom",
    order: 99,
    state: {
      cutoff: 1.5
    },
    onAdd: null,
    onRemove: null,
    system: function fadeOnZoomProc(dt, states) {
      var zoom = noa.camera.currentZoom;
      for (var i = 0; i < states.length; i++) {
        checkZoom(states[i], zoom, noa);
      }
    }
  };
}
function checkZoom(state, zoom, noa) {
  if (!noa.ents.hasMesh(state.__id)) return;
  var mesh = noa.ents.getMeshData(state.__id).mesh;
  if (!mesh.metadata) return;
  var shouldHide = zoom < state.cutoff;
  noa.rendering.setMeshVisibility(mesh, !shouldHide);
}

// node_modules/noa-engine/src/components/followsEntity.js
var import_gl_vec34 = __toESM(require_gl_vec3());
function followsEntity_default(noa) {
  return {
    name: "followsEntity",
    order: 50,
    state: {
      entity: 0 | 0,
      offset: null,
      onTargetMissing: null
    },
    onAdd: function(eid, state) {
      var off = import_gl_vec34.default.create();
      state.offset = state.offset ? import_gl_vec34.default.copy(off, state.offset) : off;
      updatePosition(state);
      updateRenderPosition(state);
    },
    onRemove: null,
    // on tick, copy over regular positions
    system: function followEntity(dt, states) {
      for (var i = 0; i < states.length; i++) {
        updatePosition(states[i]);
      }
    },
    // on render, copy over render positions
    renderSystem: function followEntityMesh(dt, states) {
      for (var i = 0; i < states.length; i++) {
        updateRenderPosition(states[i]);
      }
    }
  };
  function updatePosition(state) {
    var id = state.__id;
    var self = noa.ents.getPositionData(id);
    var other = noa.ents.getPositionData(state.entity);
    if (!other) {
      if (state.onTargetMissing) state.onTargetMissing(id);
      noa.ents.removeComponent(id, noa.ents.names.followsEntity);
    } else {
      import_gl_vec34.default.add(self._localPosition, other._localPosition, state.offset);
    }
  }
  function updateRenderPosition(state) {
    var id = state.__id;
    var self = noa.ents.getPositionData(id);
    var other = noa.ents.getPositionData(state.entity);
    if (other) {
      import_gl_vec34.default.add(self._renderPosition, other._renderPosition, state.offset);
    }
  }
}

// node_modules/noa-engine/src/components/mesh.js
var import_gl_vec35 = __toESM(require_gl_vec3());
function mesh_default(noa) {
  return {
    name: "mesh",
    order: 100,
    state: {
      mesh: null,
      offset: null
    },
    onAdd: function(eid, state) {
      var posDat = noa.ents.getPositionData(eid);
      if (state.mesh) {
        noa.rendering.addMeshToScene(state.mesh, false, posDat.position);
      } else {
        throw new Error("Mesh component added without a mesh - probably a bug!");
      }
      if (!state.offset) state.offset = import_gl_vec35.default.create();
      var rpos = posDat._renderPosition;
      state.mesh.position.copyFromFloats(
        rpos[0] + state.offset[0],
        rpos[1] + state.offset[1],
        rpos[2] + state.offset[2]
      );
    },
    onRemove: function(eid, state) {
      state.mesh.dispose();
    },
    renderSystem: function(dt, states) {
      for (var i = 0; i < states.length; i++) {
        var state = states[i];
        var id = state.__id;
        var rpos = noa.ents.getPositionData(id)._renderPosition;
        state.mesh.position.copyFromFloats(
          rpos[0] + state.offset[0],
          rpos[1] + state.offset[1],
          rpos[2] + state.offset[2]
        );
      }
    }
  };
}

// node_modules/noa-engine/src/components/movement.js
var import_gl_vec36 = __toESM(require_gl_vec3());
function MovementState() {
  this.heading = 0;
  this.running = false;
  this.jumping = false;
  this.maxSpeed = 10;
  this.moveForce = 30;
  this.responsiveness = 15;
  this.runningFriction = 0;
  this.standingFriction = 2;
  this.airMoveMult = 0.5;
  this.jumpImpulse = 10;
  this.jumpForce = 12;
  this.jumpTime = 500;
  this.airJumps = 1;
  this._jumpCount = 0;
  this._currjumptime = 0;
  this._isJumping = false;
}
function movement_default(noa) {
  return {
    name: "movement",
    order: 30,
    state: new MovementState(),
    onAdd: null,
    onRemove: null,
    system: function movementProcessor(dt, states) {
      var ents = noa.entities;
      for (var i = 0; i < states.length; i++) {
        var state = states[i];
        var phys = ents.getPhysics(state.__id);
        if (phys) applyMovementPhysics(dt, state, phys.body);
      }
    }
  };
}
var tempvec = import_gl_vec36.default.create();
var tempvec2 = import_gl_vec36.default.create();
var zeroVec = import_gl_vec36.default.create();
function applyMovementPhysics(dt, state, body) {
  var onGround = body.atRestY() < 0;
  var canjump = onGround || state._jumpCount < state.airJumps;
  if (onGround) {
    state._isJumping = false;
    state._jumpCount = 0;
  }
  if (state.jumping) {
    if (state._isJumping) {
      if (state._currjumptime > 0) {
        var jf = state.jumpForce;
        if (state._currjumptime < dt) jf *= state._currjumptime / dt;
        body.applyForce([0, jf, 0]);
        state._currjumptime -= dt;
      }
    } else if (canjump) {
      state._isJumping = true;
      if (!onGround) state._jumpCount++;
      state._currjumptime = state.jumpTime;
      body.applyImpulse([0, state.jumpImpulse, 0]);
      if (!onGround && body.velocity[1] < 0) body.velocity[1] = 0;
    }
  } else {
    state._isJumping = false;
  }
  var m = tempvec;
  var push = tempvec2;
  if (state.running) {
    var speed = state.maxSpeed;
    import_gl_vec36.default.set(m, 0, 0, speed);
    import_gl_vec36.default.rotateY(m, m, zeroVec, state.heading);
    import_gl_vec36.default.subtract(push, m, body.velocity);
    push[1] = 0;
    var pushLen = import_gl_vec36.default.length(push);
    import_gl_vec36.default.normalize(push, push);
    if (pushLen > 0) {
      var canPush = state.moveForce;
      if (!onGround) canPush *= state.airMoveMult;
      var pushAmt = state.responsiveness * pushLen;
      if (canPush > pushAmt) canPush = pushAmt;
      import_gl_vec36.default.scale(push, push, canPush);
      body.applyForce(push);
    }
    body.friction = state.runningFriction;
  } else {
    body.friction = state.standingFriction;
  }
}

// node_modules/noa-engine/src/components/receivesInputs.js
function receivesInputs_default(noa) {
  return {
    name: "receivesInputs",
    order: 20,
    state: {},
    onAdd: null,
    onRemove: null,
    system: function inputProcessor(dt, states) {
      var ents = noa.entities;
      var inputState = noa.inputs.state;
      var camHeading = noa.camera.heading;
      for (var i = 0; i < states.length; i++) {
        var state = states[i];
        var moveState = ents.getMovement(state.__id);
        setMovementState(moveState, inputState, camHeading);
      }
    }
  };
}
function setMovementState(state, inputs, camHeading) {
  state.jumping = !!inputs.jump;
  var fb = inputs.forward ? inputs.backward ? 0 : 1 : inputs.backward ? -1 : 0;
  var rl = inputs.right ? inputs.left ? 0 : 1 : inputs.left ? -1 : 0;
  if ((fb | rl) === 0) {
    state.running = false;
  } else {
    state.running = true;
    if (fb) {
      if (fb == -1) camHeading += Math.PI;
      if (rl) {
        camHeading += Math.PI / 4 * fb * rl;
      }
    } else {
      camHeading += rl * Math.PI / 2;
    }
    state.heading = camHeading;
  }
}

// node_modules/noa-engine/src/components/shadow.js
var import_gl_vec37 = __toESM(require_gl_vec3());
function shadow_default(noa, distance2 = 10) {
  var shadowDist = distance2;
  var scene = noa.rendering.getScene();
  var disc = CreateDisc("shadow", { radius: 0.75, tessellation: 30 }, scene);
  disc.rotation.x = Math.PI / 2;
  var mat = noa.rendering.makeStandardMaterial("shadow_component_mat");
  mat.diffuseColor.set(0, 0, 0);
  mat.ambientColor.set(0, 0, 0);
  mat.alpha = 0.5;
  disc.material = mat;
  mat.freeze();
  noa.rendering.setMeshVisibility(disc, false);
  return {
    name: "shadow",
    order: 80,
    state: {
      size: 0.5,
      _mesh: null
    },
    onAdd: function(eid, state) {
      var mesh = disc.createInstance("shadow_instance");
      noa.rendering.addMeshToScene(mesh);
      mesh.setEnabled(false);
      state._mesh = mesh;
    },
    onRemove: function(eid, state) {
      state._mesh.dispose();
      state._mesh = null;
    },
    system: function shadowSystem(dt, states) {
      var cpos = noa.camera._localGetPosition();
      var dist2 = shadowDist;
      for (var i = 0; i < states.length; i++) {
        var state = states[i];
        var posState = noa.ents.getPositionData(state.__id);
        var physState = noa.ents.getPhysics(state.__id);
        updateShadowHeight(noa, posState, physState, state._mesh, state.size, dist2, cpos);
      }
    },
    renderSystem: function(dt, states) {
      for (var i = 0; i < states.length; i++) {
        var state = states[i];
        var rpos = noa.ents.getPositionData(state.__id)._renderPosition;
        var spos = state._mesh.position;
        spos.x = rpos[0];
        spos.z = rpos[2];
      }
    }
  };
}
var shadowPos = import_gl_vec37.default.fromValues(0, 0, 0);
var down = import_gl_vec37.default.fromValues(0, -1, 0);
function updateShadowHeight(noa, posDat, physDat, mesh, size, shadowDist, camPos) {
  var localY;
  if (physDat && physDat.body.resting[1] < 0) {
    localY = posDat._localPosition[1];
  } else {
    var res = noa._localPick(posDat._localPosition, down, shadowDist);
    if (!res) {
      mesh.setEnabled(false);
      return;
    }
    localY = res.position[1] - noa.worldOriginOffset[1];
  }
  localY = Math.round(localY);
  import_gl_vec37.default.copy(shadowPos, posDat._localPosition);
  shadowPos[1] = localY;
  var sqdist = import_gl_vec37.default.squaredDistance(camPos, shadowPos);
  var offset = 0.01 + 0.1 * (sqdist / 1600);
  if (offset > 0.1) offset = 0.1;
  mesh.position.y = localY + offset;
  var dist2 = posDat._localPosition[1] - localY;
  var scale3 = size * 0.7 * (1 - dist2 / shadowDist);
  mesh.scaling.copyFromFloats(scale3, scale3, scale3);
  mesh.setEnabled(true);
}

// node_modules/noa-engine/src/components/smoothCamera.js
function smoothCamera_default(noa) {
  var compName = "smoothCamera";
  return {
    name: compName,
    order: 99,
    state: {
      time: 100.1
    },
    onAdd: null,
    onRemove: null,
    system: function(dt, states) {
      for (var i = 0; i < states.length; i++) {
        var state = states[i];
        state.time -= dt;
        if (state.time < 0) noa.ents.removeComponent(state.__id, compName);
      }
    }
  };
}

// node_modules/noa-engine/src/lib/entities.js
var defaultOptions2 = {
  shadowDistance: 10
};
var Entities = class extends import_ent_comp.default {
  /** @internal */
  constructor(noa, opts) {
    super();
    opts = Object.assign({}, defaultOptions2, opts);
    var componentArgs = {
      "shadow": opts.shadowDistance
    };
    this.noa = noa;
    this.names = {};
    var compDefs = {
      collideEntities: collideEntities_default,
      collideTerrain: collideTerrain_default,
      fadeOnZoom: fadeOnZoom_default,
      followsEntity: followsEntity_default,
      mesh: mesh_default,
      movement: movement_default,
      physics: physics_default,
      position: position_default,
      receivesInputs: receivesInputs_default,
      shadow: shadow_default,
      smoothCamera: smoothCamera_default
    };
    Object.keys(compDefs).forEach((bareName) => {
      var arg = componentArgs[bareName] || void 0;
      var compFn = compDefs[bareName];
      var compDef = compFn(noa, arg);
      this.names[bareName] = this.createComponent(compDef);
    });
    this.cameraSmoothed = this.getComponentAccessor(this.names.smoothCamera);
    this.hasPhysics = this.getComponentAccessor(this.names.physics);
    this.hasPosition = this.getComponentAccessor(this.names.position);
    this.getPositionData = this.getStateAccessor(this.names.position);
    this.getPosition = (id) => {
      var state = this.getPositionData(id);
      return state ? state.position : null;
    };
    this.getPhysics = this.getStateAccessor(this.names.physics);
    this.getPhysicsBody = (id) => {
      var state = this.getPhysics(id);
      return state ? state.body : null;
    };
    this.hasMesh = this.getComponentAccessor(this.names.mesh);
    this.getMeshData = this.getStateAccessor(this.names.mesh);
    this.getMovement = this.getStateAccessor(this.names.movement);
    this.getCollideTerrain = this.getStateAccessor(this.names.collideTerrain);
    this.getCollideEntities = this.getStateAccessor(this.names.collideEntities);
    this.onPairwiseEntityCollision = function(id1, id2) {
    };
  }
  /*
   * 
   * 
   *      PUBLIC ENTITY STATE ACCESSORS
   * 
   * 
  */
  /** Set an entity's position, and update all derived state.
   * 
   * In general, always use this to set an entity's position unless
   * you're familiar with engine internals.
   * 
   * ```js
   * noa.ents.setPosition(playerEntity, [5, 6, 7])
   * noa.ents.setPosition(playerEntity, 5, 6, 7)  // also works
   * ```
   * 
   * @param {number} id
   */
  setPosition(id, pos, y = 0, z = 0) {
    if (typeof pos === "number") pos = [pos, y, z];
    var loc = this.noa.globalToLocal(pos, null, []);
    this._localSetPosition(id, loc);
  }
  /** Set an entity's size 
   * @param {number} xs
   * @param {number} ys
   * @param {number} zs
  */
  setEntitySize(id, xs, ys, zs) {
    var posDat = this.getPositionData(id);
    posDat.width = (xs + zs) / 2;
    posDat.height = ys;
    this._updateDerivedPositionData(id, posDat);
  }
  /**
   * called when engine rebases its local coords
   * @internal
   */
  _rebaseOrigin(delta) {
    for (var state of this.getStatesList(this.names.position)) {
      var locPos = state._localPosition;
      var hw = state.width / 2;
      nudgePosition(locPos, 0, -hw, hw, state.__id);
      nudgePosition(locPos, 1, 0, state.height, state.__id);
      nudgePosition(locPos, 2, -hw, hw, state.__id);
      import_gl_vec38.default.subtract(locPos, locPos, delta);
      this._updateDerivedPositionData(state.__id, state);
    }
  }
  /** @internal */
  _localGetPosition(id) {
    return this.getPositionData(id)._localPosition;
  }
  /** @internal */
  _localSetPosition(id, pos) {
    var posDat = this.getPositionData(id);
    import_gl_vec38.default.copy(posDat._localPosition, pos);
    this._updateDerivedPositionData(id, posDat);
  }
  /** 
   * helper to update everything derived from `_localPosition`
   * @internal 
  */
  _updateDerivedPositionData(id, posDat) {
    import_gl_vec38.default.copy(posDat._renderPosition, posDat._localPosition);
    var offset = this.noa.worldOriginOffset;
    import_gl_vec38.default.add(posDat.position, posDat._localPosition, offset);
    updatePositionExtents(posDat);
    var physDat = this.getPhysics(id);
    if (physDat) setPhysicsFromPosition(physDat, posDat);
  }
  /*
   *
   *
   *      OTHER ENTITY MANAGEMENT APIs
   * 
   *      note most APIs are on the original ECS module (ent-comp)
   *      these are some overlaid extras for noa
   *
   *
  */
  /** 
   * Safely add a component - if the entity already had the 
   * component, this will remove and re-add it.
  */
  addComponentAgain(id, name, state) {
    if (this.hasComponent(id, name)) this.removeComponent(id, name);
    this.addComponent(id, name, state);
  }
  /** 
   * Checks whether a voxel is obstructed by any entity (with the 
   * `collidesTerrain` component)
  */
  isTerrainBlocked(x, y, z) {
    var off = this.noa.worldOriginOffset;
    var xlocal = Math.floor(x - off[0]);
    var ylocal = Math.floor(y - off[1]);
    var zlocal = Math.floor(z - off[2]);
    var blockExt = [
      xlocal + 1e-3,
      ylocal + 1e-3,
      zlocal + 1e-3,
      xlocal + 0.999,
      ylocal + 0.999,
      zlocal + 0.999
    ];
    var list = this.getStatesList(this.names.collideTerrain);
    for (var i = 0; i < list.length; i++) {
      var id = list[i].__id;
      var ext = this.getPositionData(id)._extents;
      if (extentsOverlap(blockExt, ext)) return true;
    }
    return false;
  }
  /** 
   * Gets an array of all entities overlapping the given AABB
  */
  getEntitiesInAABB(box, withComponent) {
    var off = this.noa.worldOriginOffset;
    var testExtents = [
      box.base[0] - off[0],
      box.base[1] - off[1],
      box.base[2] - off[2],
      box.max[0] - off[0],
      box.max[1] - off[1],
      box.max[2] - off[2]
    ];
    var entStates;
    if (withComponent) {
      entStates = [];
      for (var compState of this.getStatesList(withComponent)) {
        var pdat = this.getPositionData(compState.__id);
        if (pdat) entStates.push(pdat);
      }
    } else {
      entStates = this.getStatesList(this.names.position);
    }
    var hits = [];
    for (var i = 0; i < entStates.length; i++) {
      var state = entStates[i];
      if (extentsOverlap(testExtents, state._extents)) {
        hits.push(state.__id);
      }
    }
    return hits;
  }
  /** 
   * Helper to set up a general entity, and populate with some common components depending on arguments.
  */
  add(position = null, width = 1, height = 1, mesh = null, meshOffset = null, doPhysics = false, shadow = false) {
    var self = this;
    var eid = this.createEntity();
    this.addComponent(eid, this.names.position, {
      position: position || import_gl_vec38.default.create(),
      width,
      height
    });
    if (doPhysics) {
      this.addComponent(eid, this.names.physics);
      var body = this.getPhysics(eid).body;
      var smoothName = this.names.smoothCamera;
      body.onStep = function() {
        self.addComponentAgain(eid, smoothName);
      };
    }
    if (mesh) {
      if (!meshOffset) meshOffset = import_gl_vec38.default.create();
      this.addComponent(eid, this.names.mesh, {
        mesh,
        offset: meshOffset
      });
    }
    if (shadow) {
      this.addComponent(eid, this.names.shadow, { size: width });
    }
    return eid;
  }
};
function nudgePosition(pos, index, dmin, dmax, id) {
  var min2 = pos[index] + dmin;
  var max2 = pos[index] + dmax;
  if (Math.abs(min2 - Math.round(min2)) < 2e-3) pos[index] += 2e-3;
  if (Math.abs(max2 - Math.round(max2)) < 1e-3) pos[index] -= 1e-3;
}
function extentsOverlap(extA, extB) {
  if (extA[0] > extB[3]) return false;
  if (extA[1] > extB[4]) return false;
  if (extA[2] > extB[5]) return false;
  if (extA[3] < extB[0]) return false;
  if (extA[4] < extB[1]) return false;
  if (extA[5] < extB[2]) return false;
  return true;
}

// node_modules/noa-engine/src/lib/util.js
function removeUnorderedListItem(list, item) {
  var i = list.indexOf(item);
  if (i < 0) return;
  if (i === list.length - 1) {
    list.pop();
  } else {
    list[i] = list.pop();
  }
}
function locationHasher(i, j, k) {
  return i & 1023 | (j & 1023) << 10 | (k & 1023) << 20;
}
var ChunkStorage = class {
  constructor() {
    this.hash = {};
  }
  /** @returns {import('./chunk').Chunk} */
  getChunkByIndexes(i = 0, j = 0, k = 0) {
    return this.hash[locationHasher(i, j, k)] || null;
  }
  /** @param {import('./chunk').Chunk} chunk */
  storeChunkByIndexes(i = 0, j = 0, k = 0, chunk) {
    this.hash[locationHasher(i, j, k)] = chunk;
  }
  removeChunkByIndexes(i = 0, j = 0, k = 0) {
    delete this.hash[locationHasher(i, j, k)];
  }
};
var LocationQueue = class {
  constructor() {
    this.arr = [];
    this.hash = {};
  }
  forEach(cb, thisArg) {
    this.arr.forEach(cb, thisArg);
  }
  includes(i, j, k) {
    var id = locationHasher(i, j, k);
    return !!this.hash[id];
  }
  add(i, j, k, toFront = false) {
    var id = locationHasher(i, j, k);
    if (this.hash[id]) return;
    if (toFront) {
      this.arr.unshift([i, j, k, id]);
    } else {
      this.arr.push([i, j, k, id]);
    }
    this.hash[id] = true;
  }
  removeByIndex(ix) {
    var el = this.arr[ix];
    delete this.hash[el[3]];
    this.arr.splice(ix, 1);
  }
  remove(i, j, k) {
    var id = locationHasher(i, j, k);
    if (!this.hash[id]) return;
    delete this.hash[id];
    for (var ix = 0; ix < this.arr.length; ix++) {
      if (id === this.arr[ix][3]) {
        this.arr.splice(ix, 1);
        return;
      }
    }
    throw "internal bug with location queue - hash value overlapped";
  }
  count() {
    return this.arr.length;
  }
  isEmpty() {
    return this.arr.length === 0;
  }
  empty() {
    this.arr = [];
    this.hash = {};
  }
  pop() {
    var el = this.arr.pop();
    delete this.hash[el[3]];
    return el;
  }
  copyFrom(queue) {
    this.arr = queue.arr.slice();
    this.hash = {};
    for (var key in queue.hash) this.hash[key] = true;
  }
  sortByDistance(locToDist, reverse = false) {
    sortLocationArrByDistance(this.arr, locToDist, reverse);
  }
};
function sortLocationArrByDistance(arr, distFn, reverse) {
  var hash = {};
  for (var loc of arr) {
    hash[loc[3]] = distFn(loc[0], loc[1], loc[2]);
  }
  if (reverse) {
    arr.sort((a2, b) => hash[a2[3]] - hash[b[3]]);
  } else {
    arr.sort((a2, b) => hash[b[3]] - hash[a2[3]]);
  }
  hash = null;
}
function makeProfileHook(every, title = "", filter) {
  if (!(every > 0)) return () => {
  };
  var times = {};
  var started = 0, last = 0, iter = 0, total = 0;
  var start = () => {
    started = last = performance.now();
    iter++;
  };
  var add3 = (name) => {
    var t = performance.now();
    times[name] = (times[name] || 0) + (t - last);
    last = t;
  };
  var report = () => {
    total += performance.now() - started;
    if (iter < every) return;
    var out = `${title}: ${(total / every).toFixed(2)}ms  --  `;
    out += Object.keys(times).map((name) => {
      if (filter && times[name] / total < 0.05) return "";
      return `${name}: ${(times[name] / iter).toFixed(2)}ms`;
    }).join("  ");
    console.log(out + `    (avg over ${every} runs)`);
    times = {};
    iter = total = 0;
  };
  return (state) => {
    if (state === "start") start();
    else if (state === "end") report();
    else add3(state);
  };
}

// node_modules/noa-engine/src/lib/objectMesher.js
var PROFILE = 0;
function ObjectMesher(noa) {
  this.rootNode = new TransformNode("objectMeshRoot", noa.rendering.scene);
  var rebaseOffset = [0, 0, 0];
  var rebuildNextTick = false;
  var transformObj = new TransformNode("");
  this.allBaseMeshes = [];
  var managers = {};
  var getManager = (id) => {
    if (managers[id]) return managers[id];
    var mesh = noa.registry._blockMeshLookup[id];
    for (var id2 in managers) {
      var prev = managers[id2].mesh;
      if (prev === mesh || prev.geometry === mesh.geometry) {
        return managers[id] = managers[id2];
      }
    }
    this.allBaseMeshes.push(mesh);
    if (!mesh.metadata) mesh.metadata = {};
    mesh.metadata[objectMeshFlag] = true;
    return managers[id] = new InstanceManager(noa, mesh);
  };
  var objectMeshFlag = "noa_object_base_mesh";
  this.initChunk = function(chunk) {
    chunk._objectBlocks = {};
  };
  this.setObjectBlock = function(chunk, blockID, i, j, k) {
    var x = chunk.x + i;
    var y = chunk.y + j;
    var z = chunk.z + k;
    var key = `${x}:${y}:${z}`;
    var oldID = chunk._objectBlocks[key] || 0;
    if (oldID === blockID) return;
    if (oldID > 0) {
      var oldMgr = getManager(oldID);
      oldMgr.removeInstance(chunk, key);
    }
    if (blockID > 0) {
      var handlers = noa.registry._blockHandlerLookup[blockID];
      var onCreate = handlers && handlers.onCustomMeshCreate;
      if (onCreate) {
        transformObj.position.copyFromFloats(0.5, 0, 0.5);
        transformObj.scaling.setAll(1);
        transformObj.rotation.setAll(0);
        onCreate(transformObj, x, y, z);
      }
      var mgr = getManager(blockID);
      var xform = onCreate ? transformObj : null;
      mgr.addInstance(chunk, key, i, j, k, xform, rebaseOffset);
    }
    if (oldID > 0 && !blockID) delete chunk._objectBlocks[key];
    if (blockID > 0) chunk._objectBlocks[key] = blockID;
  };
  this.buildObjectMeshes = function() {
    profile_hook("start");
    for (var id in managers) {
      var mgr = managers[id];
      mgr.updateMatrix();
      if (mgr.count === 0) mgr.dispose();
      if (mgr.disposed) delete managers[id];
    }
    profile_hook("rebuilt");
    profile_hook("end");
  };
  this.disposeChunk = function(chunk) {
    for (var key in chunk._objectBlocks) {
      var id = chunk._objectBlocks[key];
      if (id > 0) {
        var mgr = getManager(id);
        mgr.removeInstance(chunk, key);
      }
    }
    chunk._objectBlocks = null;
    rebuildNextTick = true;
  };
  this.tick = function() {
    if (rebuildNextTick) {
      this.buildObjectMeshes();
      rebuildNextTick = false;
    }
  };
  this._rebaseOrigin = function(delta) {
    rebaseOffset[0] += delta[0];
    rebaseOffset[1] += delta[1];
    rebaseOffset[2] += delta[2];
    for (var id1 in managers) managers[id1].rebased = false;
    for (var id2 in managers) {
      var mgr = managers[id2];
      if (mgr.rebased) continue;
      for (var i = 0; i < mgr.count; i++) {
        var ix = i << 4;
        mgr.buffer[ix + 12] -= delta[0];
        mgr.buffer[ix + 13] -= delta[1];
        mgr.buffer[ix + 14] -= delta[2];
      }
      mgr.rebased = true;
      mgr.dirty = true;
    }
    rebuildNextTick = true;
  };
}
function InstanceManager(noa, mesh) {
  this.noa = noa;
  this.mesh = mesh;
  this.buffer = null;
  this.capacity = 0;
  this.count = 0;
  this.dirty = false;
  this.rebased = true;
  this.disposed = false;
  this.keyToIndex = {};
  this.locToKey = [];
  this.mesh.position.setAll(0);
  this.mesh.parent = noa._objectMesher.rootNode;
  this.noa.rendering.addMeshToScene(this.mesh, false);
  this.noa.emit("addingTerrainMesh", this.mesh);
  this.mesh.isPickable = false;
  this.mesh.doNotSyncBoundingInfo = true;
  this.mesh.alwaysSelectAsActiveMesh = true;
}
InstanceManager.prototype.dispose = function() {
  if (this.disposed) return;
  this.mesh.thinInstanceCount = 0;
  this.setCapacity(0);
  this.noa.emit("removingTerrainMesh", this.mesh);
  this.noa.rendering.setMeshVisibility(this.mesh, false);
  this.mesh = null;
  this.keyToIndex = null;
  this.locToKey = null;
  this.disposed = true;
};
InstanceManager.prototype.addInstance = function(chunk, key, i, j, k, transform, rebaseVec) {
  maybeExpandBuffer(this);
  var ix = this.count << 4;
  this.locToKey[this.count] = key;
  this.keyToIndex[key] = ix;
  if (transform) {
    transform.position.x += chunk.x - rebaseVec[0] + i;
    transform.position.y += chunk.y - rebaseVec[1] + j;
    transform.position.z += chunk.z - rebaseVec[2] + k;
    transform.computeWorldMatrix(true);
    var xformArr = transform._localMatrix._m;
    copyMatrixData(xformArr, 0, this.buffer, ix);
  } else {
    var matArray = tempMatrixArray;
    matArray[12] = chunk.x - rebaseVec[0] + i + 0.5;
    matArray[13] = chunk.y - rebaseVec[1] + j;
    matArray[14] = chunk.z - rebaseVec[2] + k + 0.5;
    copyMatrixData(matArray, 0, this.buffer, ix);
  }
  this.count++;
  this.dirty = true;
};
InstanceManager.prototype.removeInstance = function(chunk, key) {
  var remIndex = this.keyToIndex[key];
  if (!(remIndex >= 0)) throw "tried to remove object instance not in storage";
  delete this.keyToIndex[key];
  var remLoc = remIndex >> 4;
  var tailLoc = this.count - 1;
  if (remLoc !== tailLoc) {
    var tailIndex = tailLoc << 4;
    copyMatrixData(this.buffer, tailIndex, this.buffer, remIndex);
    var tailKey = this.locToKey[tailLoc];
    this.keyToIndex[tailKey] = remIndex;
    this.locToKey[remLoc] = tailKey;
  }
  this.count--;
  this.dirty = true;
  maybeContractBuffer(this);
};
InstanceManager.prototype.updateMatrix = function() {
  if (!this.dirty) return;
  this.mesh.thinInstanceCount = this.count;
  this.mesh.thinInstanceBufferUpdated("matrix");
  this.mesh.isVisible = this.count > 0;
  this.dirty = false;
};
InstanceManager.prototype.setCapacity = function(size = 4) {
  this.capacity = size;
  if (size === 0) {
    this.buffer = null;
  } else {
    var newBuff = new Float32Array(this.capacity * 16);
    if (this.buffer) {
      var len2 = Math.min(this.buffer.length, newBuff.length);
      for (var i = 0; i < len2; i++) newBuff[i] = this.buffer[i];
    }
    this.buffer = newBuff;
  }
  this.mesh.thinInstanceSetBuffer("matrix", this.buffer);
  this.updateMatrix();
};
function maybeExpandBuffer(mgr) {
  if (mgr.count < mgr.capacity) return;
  var size = Math.max(8, mgr.capacity * 2);
  mgr.setCapacity(size);
}
function maybeContractBuffer(mgr) {
  if (mgr.count > mgr.capacity * 0.4) return;
  if (mgr.capacity < 100) return;
  mgr.setCapacity(Math.round(mgr.capacity / 2));
  mgr.locToKey.length = Math.min(mgr.locToKey.length, mgr.capacity);
}
var tempMatrixArray = [
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1
];
function copyMatrixData(src, srcOff, dest, destOff) {
  for (var i = 0; i < 16; i++) dest[destOff + i] = src[srcOff + i];
}
var profile_hook = PROFILE ? makeProfileHook(PROFILE, "Object meshing") : () => {
};

// node_modules/noa-engine/src/lib/terrainMesher.js
var import_ndarray = __toESM(require_ndarray());

// node_modules/noa-engine/src/lib/terrainMaterials.js
var TerrainMatManager = class {
  /** @param {import('../index').Engine} noa  */
  constructor(noa) {
    this._defaultMat = noa.rendering.makeStandardMaterial("base-terrain");
    this._defaultMat.freeze();
    this.allMaterials = [this._defaultMat];
    this.noa = noa;
    this._idCounter = 1e3;
    this._blockMatIDtoTerrainID = {};
    this._terrainIDtoMatObject = {};
    this._texURLtoTerrainID = {};
    this._renderMatToTerrainID = /* @__PURE__ */ new Map();
  }
  /** 
   * Maps a given `matID` (from noa.registry) to a unique ID of which 
   * terrain material can be used for that block material.
   * This lets the terrain mesher map which blocks can be merged into
   * the same meshes.
   * Internally, this accessor also creates the material for each 
   * terrainMatID as they are first encountered.
   */
  getTerrainMatId(blockMatID) {
    if (blockMatID in this._blockMatIDtoTerrainID) {
      return this._blockMatIDtoTerrainID[blockMatID];
    }
    var terrID = decideTerrainMatID(this, blockMatID);
    if (!(terrID in this._terrainIDtoMatObject)) {
      var mat = createTerrainMat(this, blockMatID);
      this.allMaterials.push(mat);
      this._terrainIDtoMatObject[terrID] = mat;
    }
    this._blockMatIDtoTerrainID[blockMatID] = terrID;
    return terrID;
  }
  /**
   * Get a Babylon Material object, given a terrainMatID (gotten from this module)
   */
  getMaterial(terrainMatID = 1) {
    return this._terrainIDtoMatObject[terrainMatID];
  }
};
function decideTerrainMatID(self, blockMatID = 0) {
  var matInfo = self.noa.registry.getMaterialData(blockMatID);
  if (matInfo.renderMat) {
    var mat = matInfo.renderMat;
    if (!self._renderMatToTerrainID.has(mat)) {
      self._renderMatToTerrainID.set(mat, self._idCounter++);
    }
    return self._renderMatToTerrainID.get(mat);
  }
  if (matInfo.texture) {
    var url = matInfo.texture;
    if (!(url in self._texURLtoTerrainID)) {
      self._texURLtoTerrainID[url] = self._idCounter++;
    }
    return self._texURLtoTerrainID[url];
  }
  var alpha = matInfo.alpha;
  if (alpha > 0 && alpha < 1) return 10 + Math.round(alpha * 100);
  return 1;
}
function createTerrainMat(self, blockMatID = 0) {
  var matInfo = self.noa.registry.getMaterialData(blockMatID);
  if (matInfo.renderMat) return matInfo.renderMat;
  if (!matInfo.texture) {
    var needsAlpha = matInfo.alpha > 0 && matInfo.alpha < 1;
    if (!needsAlpha) return self._defaultMat;
    var matName = "terrain-alpha-" + blockMatID;
    var plainMat = self.noa.rendering.makeStandardMaterial(matName);
    plainMat.alpha = matInfo.alpha;
    plainMat.freeze();
    return plainMat;
  }
  var scene = self.noa.rendering.getScene();
  var mat = self.noa.rendering.makeStandardMaterial("terrain-textured-" + blockMatID);
  var texURL = matInfo.texture;
  var sampling = Texture.NEAREST_SAMPLINGMODE;
  var tex = new Texture(texURL, scene, true, false, sampling);
  if (matInfo.texHasAlpha) tex.hasAlpha = true;
  mat.diffuseTexture = tex;
  if (matInfo.atlasIndex >= 0) {
    new TerrainMaterialPlugin(mat, tex);
    if (self.noa.registry._textureNeedsAlpha(matInfo.texture)) {
      tex.hasAlpha = true;
    }
  }
  mat.freeze();
  return mat;
}
var TerrainMaterialPlugin = class extends MaterialPluginBase {
  constructor(material, texture) {
    var priority = 200;
    var defines = { "NOA_TWOD_ARRAY_TEXTURE": false };
    super(material, "TestPlugin", priority, defines);
    this._enable(true);
    this._atlasTextureArray = null;
    texture.onLoadObservable.add((tex) => {
      this.setTextureArrayData(tex);
    });
  }
  setTextureArrayData(texture) {
    var { width, height } = texture.getSize();
    var numLayers = Math.round(height / width);
    height = width;
    var data = texture._readPixelsSync();
    var format = Engine.TEXTUREFORMAT_RGBA;
    var genMipMaps = true;
    var invertY = false;
    var mode = Texture.NEAREST_SAMPLINGMODE;
    var scene = texture.getScene();
    this._atlasTextureArray = new RawTexture2DArray(
      data,
      width,
      height,
      numLayers,
      format,
      scene,
      genMipMaps,
      invertY,
      mode
    );
  }
  prepareDefines(defines, scene, mesh) {
    defines["NOA_TWOD_ARRAY_TEXTURE"] = true;
  }
  getClassName() {
    return "TerrainMaterialPluginName";
  }
  getSamplers(samplers) {
    samplers.push("atlasTexture");
  }
  getAttributes(attributes) {
    attributes.push("texAtlasIndices");
  }
  getUniforms() {
    return { ubo: [] };
  }
  bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
    if (this._atlasTextureArray) {
      uniformBuffer.setTexture("atlasTexture", this._atlasTextureArray);
    }
  }
  getCustomCode(shaderType) {
    if (shaderType === "vertex") return {
      "CUSTOM_VERTEX_MAIN_BEGIN": `
                texAtlasIndex = texAtlasIndices;
            `,
      "CUSTOM_VERTEX_DEFINITIONS": `
                uniform highp sampler2DArray atlasTexture;
                attribute float texAtlasIndices;
                varying float texAtlasIndex;
            `
    };
    if (shaderType === "fragment") return {
      "!baseColor\\=texture2D\\(diffuseSampler,vDiffuseUV\\+uvOffset\\);": `baseColor = texture(atlasTexture, vec3(vDiffuseUV, texAtlasIndex));`,
      "CUSTOM_FRAGMENT_DEFINITIONS": `
                uniform highp sampler2DArray atlasTexture;
                varying float texAtlasIndex;
            `
    };
    return null;
  }
};

// node_modules/noa-engine/src/lib/terrainMesher.js
var PROFILE_EVERY = 0;
function TerrainMesher(noa) {
  var terrainMatManager = new TerrainMatManager(noa);
  this.allTerrainMaterials = terrainMatManager.allMaterials;
  this._defaultMaterial = terrainMatManager._defaultMat;
  var greedyMesher = new GreedyMesher(noa, terrainMatManager);
  var meshBuilder = new MeshBuilder(noa, terrainMatManager);
  this.initChunk = function(chunk) {
    chunk._terrainMeshes.length = 0;
  };
  this.disposeChunk = function(chunk) {
    chunk._terrainMeshes.forEach((mesh) => {
      noa.emit("removingTerrainMesh", mesh);
      mesh.dispose();
    });
    chunk._terrainMeshes.length = 0;
  };
  this.meshChunk = function(chunk, ignoreMaterials = false) {
    profile_hook2("start");
    this.disposeChunk(chunk);
    profile_hook2("cleanup");
    var faceDataSet = greedyMesher.mesh(chunk, ignoreMaterials);
    profile_hook2("geom");
    var meshes = meshBuilder.buildMesh(chunk, faceDataSet, ignoreMaterials);
    profile_hook2("build");
    profile_hook2("end");
    meshes.forEach((mesh) => {
      mesh.cullingStrategy = Mesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;
      noa.rendering.addMeshToScene(mesh, true, chunk.pos, this);
      noa.emit("addingTerrainMesh", mesh);
      mesh.freezeNormals();
      mesh.freezeWorldMatrix();
      chunk._terrainMeshes.push(mesh);
      if (!mesh.metadata) mesh.metadata = {};
      mesh.metadata[terrainMeshFlag] = true;
    });
  };
  var terrainMeshFlag = "noa_chunk_terrain_mesh";
}
function MeshedFaceData() {
  this.terrainID = 0;
  this.numFaces = 0;
  this.matIDs = [];
  this.dirs = [];
  this.is = [];
  this.js = [];
  this.ks = [];
  this.wids = [];
  this.hts = [];
  this.packedAO = [];
}
function GreedyMesher(noa, terrainMatManager) {
  var maskCache = new Int16Array(16);
  var aoMaskCache = new Int16Array(16);
  var realGetTerrainID = terrainMatManager.getTerrainMatId.bind(terrainMatManager);
  var fakeGetTerrainID = (matID) => 1;
  var terrainIDgetter = realGetTerrainID;
  this.mesh = function(chunk, ignoreMaterials) {
    var cs = chunk.size;
    terrainIDgetter = ignoreMaterials ? fakeGetTerrainID : realGetTerrainID;
    var edgesOnly = chunk._isEmpty || chunk._isFull;
    var faceDataSet = {};
    faceDataPool.reset();
    for (var d = 0; d < 3; ++d) {
      var u = d === 2 ? 0 : 2;
      var v = d === 1 ? 0 : 1;
      var nabVoxelsArr = chunk._neighbors.data.map((c) => {
        if (c && c.voxels) return c.voxels.transpose(d, u, v);
        return null;
      });
      var nabVoxelsT = (0, import_ndarray.default)(nabVoxelsArr, [3, 3, 3]).lo(1, 1, 1).transpose(d, u, v);
      if (maskCache.length < cs * cs) {
        maskCache = new Int16Array(cs * cs);
        aoMaskCache = new Int16Array(cs * cs);
      }
      prepareSolidityLookup(nabVoxelsT, cs);
      var prev = nabVoxelsT.get(-1, 0, 0);
      var here = nabVoxelsT.get(0, 0, 0);
      if (prev) {
        var prevOff = prev.lo(cs, 0, 0);
        var nFaces = constructMeshMask(d, prevOff, -1, here, 0);
        if (nFaces > 0) {
          constructGeometryFromMasks(0, d, u, v, cs, cs, nFaces, faceDataSet);
        }
      }
      if (edgesOnly) continue;
      for (var i = 0; i < cs - 1; i++) {
        if (d === 1) {
          var v1 = chunk._wholeLayerVoxel[i];
          if (v1 >= 0 && v1 === chunk._wholeLayerVoxel[i + 1]) {
            continue;
          }
        }
        var layerVoxRef = d === 1 ? null : chunk._wholeLayerVoxel;
        var nf = constructMeshMask(d, here, i, here, i + 1, layerVoxRef);
        if (nf > 0) {
          constructGeometryFromMasks(i + 1, d, u, v, cs, cs, nf, faceDataSet);
        }
      }
    }
    return faceDataSet;
  };
  function prepareSolidityLookup(nabVoxelsT, size) {
    if (solidityLookupInittedSize !== size) {
      solidityLookupInittedSize = size;
      voxelIDtoSolidity = noa.registry._solidityLookup;
      for (var x = -1; x < size + 1; x++) {
        var loc = x < 0 ? 0 : x < size ? 1 : 2;
        coordToLoc[x + 1] = [0, 1, 2][loc];
        edgeCoordLookup[x + 1] = [size - 1, x, 0][loc];
        missingCoordLookup[x + 1] = [0, x, size - 1][loc];
      }
    }
    var centerChunk = nabVoxelsT.get(0, 0, 0);
    for (var i = 0; i < 3; i++) {
      for (var j = 0; j < 3; j++) {
        for (var k = 0; k < 3; k++) {
          var ix = i * 9 + j * 3 + k;
          var nab = nabVoxelsT.get(i - 1, j - 1, k - 1);
          var type = 0;
          if (!nab) type = 1;
          if (nab === centerChunk) type = 2;
          voxTypeLookup[ix] = type;
          voxLookup[ix] = nab || centerChunk;
        }
      }
    }
  }
  var solidityLookupInittedSize = -1;
  var voxelIDtoSolidity = [false, true];
  var voxLookup = Array(27).fill(null);
  var voxTypeLookup = Array(27).fill(0);
  var coordToLoc = [0, 1, 1, 1, 1, 1, 2];
  var edgeCoordLookup = [3, 0, 1, 2, 3, 0];
  var missingCoordLookup = [0, 0, 1, 2, 3, 3];
  function voxelIsSolid(i, j, k) {
    var li = coordToLoc[i + 1];
    var lj = coordToLoc[j + 1];
    var lk = coordToLoc[k + 1];
    var ix = li * 9 + lj * 3 + lk;
    var voxArray = voxLookup[ix];
    var type = voxTypeLookup[ix];
    if (type === 2) {
      return voxelIDtoSolidity[voxArray.get(i, j, k)];
    }
    var lookup = [edgeCoordLookup, missingCoordLookup][type];
    var ci = lookup[i + 1];
    var cj = lookup[j + 1];
    var ck = lookup[k + 1];
    return voxelIDtoSolidity[voxArray.get(ci, cj, ck)];
  }
  function constructMeshMask(d, arrA, iA, arrB, iB, wholeLayerVoxel = null) {
    var len2 = arrA.shape[1];
    var mask = maskCache;
    var aoMask = aoMaskCache;
    var doAO = noa.rendering.useAO;
    var skipRevAo = noa.rendering.revAoVal === noa.rendering.aoVals[0];
    var opacityLookup = noa.registry._opacityLookup;
    var getMaterial = noa.registry.getBlockFaceMaterial;
    var materialDir = d * 2;
    var n = 0;
    var indexA = arrA.index(iA, 0, 0);
    var jstrideA = arrA.stride[1];
    var kstrideA = arrA.stride[2];
    var indexB = arrB.index(iB, 0, 0);
    var jstrideB = arrB.stride[1];
    var kstrideB = arrB.stride[2];
    var facesFound = 0;
    for (var k = 0; k < len2; ++k) {
      var dA = indexA;
      var dB = indexB;
      indexA += kstrideA;
      indexB += kstrideB;
      if (wholeLayerVoxel && wholeLayerVoxel[k] >= 0) {
        n += len2;
        continue;
      }
      for (var j = 0; j < len2; j++, n++, dA += jstrideA, dB += jstrideB) {
        var id0 = arrA.data[dA];
        var id1 = arrB.data[dB];
        if (id0 === id1) continue;
        var op0 = opacityLookup[id0];
        var op1 = opacityLookup[id1];
        if (op0 && op1) continue;
        var m0 = getMaterial(id0, materialDir);
        var m1 = getMaterial(id1, materialDir + 1);
        if (m0 === m1) continue;
        if (op0 || m1 === 0) {
          mask[n] = m0;
          if (doAO) aoMask[n] = packAOMask(voxelIsSolid, iB, iA, j, k, skipRevAo);
          facesFound++;
        } else if (op1 || m0 === 0) {
          mask[n] = -m1;
          if (doAO) aoMask[n] = packAOMask(voxelIsSolid, iA, iB, j, k, skipRevAo);
          facesFound++;
        } else {
        }
      }
    }
    return facesFound;
  }
  function constructGeometryFromMasks(i, d, u, v, len1, len2, numFaces, faceDataSet) {
    var doAO = noa.rendering.useAO;
    var mask = maskCache;
    var aomask = aoMaskCache;
    var n = 0;
    var materialDir = d * 2;
    var x = [0, 0, 0];
    x[d] = i;
    var maskCompareFcn = doAO ? maskCompare : maskCompare_noAO;
    for (var k = 0; k < len2; ++k) {
      var w = 1;
      var h = 1;
      for (var j = 0; j < len1; j += w, n += w) {
        var maskVal = mask[n] | 0;
        if (!maskVal) {
          w = 1;
          continue;
        }
        var ao = aomask[n] | 0;
        for (w = 1; w < len1 - j; ++w) {
          if (!maskCompareFcn(n + w, mask, maskVal, aomask, ao)) break;
        }
        OUTER:
          for (h = 1; h < len2 - k; ++h) {
            for (var m = 0; m < w; ++m) {
              var ix = n + m + h * len1;
              if (!maskCompareFcn(ix, mask, maskVal, aomask, ao)) break OUTER;
            }
          }
        var matID = Math.abs(maskVal);
        var terrainID = terrainIDgetter(matID);
        if (!(terrainID in faceDataSet)) {
          var fdFromPool = faceDataPool.get();
          fdFromPool.numFaces = 0;
          fdFromPool.terrainID = terrainID;
          faceDataSet[terrainID] = fdFromPool;
        }
        var faceData = faceDataSet[terrainID];
        var nf = faceData.numFaces;
        faceData.numFaces++;
        faceData.matIDs[nf] = matID;
        x[u] = j;
        x[v] = k;
        faceData.is[nf] = x[0];
        faceData.js[nf] = x[1];
        faceData.ks[nf] = x[2];
        faceData.wids[nf] = w;
        faceData.hts[nf] = h;
        faceData.packedAO[nf] = ao;
        faceData.dirs[nf] = maskVal > 0 ? materialDir : materialDir + 1;
        for (var hx = 0; hx < h; ++hx) {
          for (var wx = 0; wx < w; ++wx) {
            mask[n + wx + hx * len1] = 0;
          }
        }
        numFaces -= w * h;
        if (numFaces === 0) return;
      }
    }
  }
  function maskCompare(index, mask, maskVal, aomask, aoVal) {
    if (maskVal !== mask[index]) return false;
    if (aoVal !== aomask[index]) return false;
    return true;
  }
  function maskCompare_noAO(index, mask, maskVal, aomask, aoVal) {
    if (maskVal !== mask[index]) return false;
    return true;
  }
}
var faceDataPool = /* @__PURE__ */ (() => {
  var arr = [], ix = 0;
  var get = () => {
    if (ix >= arr.length) arr.push(new MeshedFaceData());
    ix++;
    return arr[ix - 1];
  };
  var reset = () => {
    ix = 0;
  };
  return { get, reset };
})();
function MeshBuilder(noa, terrainMatManager) {
  this.buildMesh = function(chunk, faceDataSet, ignoreMaterials) {
    var scene = noa.rendering.getScene();
    var doAO = noa.rendering.useAO;
    var aoVals = noa.rendering.aoVals;
    var revAoVal = noa.rendering.revAoVal;
    var atlasIndexLookup = noa.registry._matAtlasIndexLookup;
    var matColorLookup = noa.registry._materialColorLookup;
    var white = [1, 1, 1];
    var meshes = [];
    for (var key in faceDataSet) {
      var faceData = faceDataSet[key];
      var terrainID = faceData.terrainID;
      var usesAtlas = false;
      if (!ignoreMaterials) {
        var firstIx = atlasIndexLookup[faceData.matIDs[0]];
        usesAtlas = firstIx >= 0;
      }
      var nf = faceData.numFaces;
      var indices = new Uint16Array(nf * 6);
      var positions = new Float32Array(nf * 12);
      var normals = new Float32Array(nf * 12);
      var colors = new Float32Array(nf * 16);
      var uvs = new Float32Array(nf * 8);
      var atlasIndexes;
      if (usesAtlas) atlasIndexes = new Float32Array(nf * 4);
      for (var f = 0; f < faceData.numFaces; f++) {
        var matID = faceData.matIDs[f];
        var materialDir = faceData.dirs[f];
        var i = faceData.is[f];
        var j = faceData.js[f];
        var k = faceData.ks[f];
        var w = faceData.wids[f];
        var h = faceData.hts[f];
        var axis = materialDir / 2 | 0;
        var dir = materialDir % 2 ? -1 : 1;
        addPositionValues(positions, f, i, j, k, axis, w, h);
        addUVs(uvs, f, axis, w, h, dir);
        var norms = [0, 0, 0];
        norms[axis] = dir;
        addNormalValues(normals, f, norms);
        var ao = faceData.packedAO[f];
        var [A, B, C, D] = unpackAOMask(ao);
        var triDir = decideTriDir(A, B, C, D);
        addIndexValues(indices, f, axis, dir, triDir);
        if (usesAtlas) {
          var atlasIndex = atlasIndexLookup[matID];
          addAtlasIndices(atlasIndexes, f, atlasIndex);
        }
        var matColor = matColorLookup[matID] || white;
        if (doAO) {
          pushMeshColors(colors, f, matColor, aoVals, revAoVal, A, B, C, D);
        } else {
          pushMeshColors_noAO(colors, f, matColor);
        }
      }
      var name = `chunk_${chunk.requestID}_${terrainID}`;
      var mesh = new Mesh(name, scene);
      var vdat = new VertexData();
      vdat.positions = positions;
      vdat.indices = indices;
      vdat.normals = normals;
      vdat.colors = colors;
      vdat.uvs = uvs;
      vdat.applyToMesh(mesh);
      if (usesAtlas) {
        mesh.setVerticesData("texAtlasIndices", atlasIndexes, false, 1);
      }
      mesh.isPickable = false;
      mesh.doNotSyncBoundingInfo = true;
      mesh._refreshBoundingInfo = () => mesh;
      if (!ignoreMaterials) {
        mesh.material = terrainMatManager.getMaterial(terrainID);
      }
      meshes.push(mesh);
    }
    return meshes;
  };
  function addPositionValues(posArr, faceNum, i, j, k, axis, w, h) {
    var offset = faceNum * 12;
    var loc = [i, j, k];
    var du = [0, 0, 0];
    var dv2 = [0, 0, 0];
    du[axis === 2 ? 0 : 2] = w;
    dv2[axis === 1 ? 0 : 1] = h;
    for (var ix = 0; ix < 3; ix++) {
      posArr[offset + ix] = loc[ix];
      posArr[offset + 3 + ix] = loc[ix] + du[ix];
      posArr[offset + 6 + ix] = loc[ix] + du[ix] + dv2[ix];
      posArr[offset + 9 + ix] = loc[ix] + dv2[ix];
    }
  }
  function addUVs(uvArr, faceNum, d, w, h, dir) {
    var offset = faceNum * 8;
    var epsilon = 0;
    for (var i = 0; i < 8; i++) uvArr[offset + i] = epsilon;
    if (d === 0) {
      uvArr[offset + 1] = uvArr[offset + 3] = h - epsilon;
      uvArr[offset + 2] = uvArr[offset + 4] = dir * w;
    } else if (d === 1) {
      uvArr[offset + 1] = uvArr[offset + 7] = w - epsilon;
      uvArr[offset + 4] = uvArr[offset + 6] = dir * h;
    } else {
      uvArr[offset + 1] = uvArr[offset + 3] = h - epsilon;
      uvArr[offset + 2] = uvArr[offset + 4] = -dir * w;
    }
  }
  function addNormalValues(normArr, faceNum, norms) {
    var offset = faceNum * 12;
    for (var i = 0; i < 12; i++) {
      normArr[offset + i] = norms[i % 3];
    }
  }
  function addIndexValues(indArr, faceNum, axis, dir, triDir) {
    var offset = faceNum * 6;
    var baseIndex = faceNum * 4;
    if (axis === 0) dir = -dir;
    var ix = dir < 0 ? 0 : 1;
    if (!triDir) ix += 2;
    var indexVals = indexLists[ix];
    for (var i = 0; i < 6; i++) {
      indArr[offset + i] = baseIndex + indexVals[i];
    }
  }
  var indexLists = [
    [0, 1, 2, 0, 2, 3],
    // base
    [0, 2, 1, 0, 3, 2],
    // flipped
    [1, 2, 3, 1, 3, 0],
    // opposite triDir
    [1, 3, 2, 1, 0, 3]
    // opposite triDir
  ];
  function addAtlasIndices(indArr, faceNum, atlasIndex) {
    var offset = faceNum * 4;
    for (var i = 0; i < 4; i++) {
      indArr[offset + i] = atlasIndex;
    }
  }
  function decideTriDir(A, B, C, D) {
    if (A === C) {
      return D === B ? D === 2 : true;
    } else {
      return D === B ? false : A + C > D + B;
    }
  }
  function pushMeshColors_noAO(colors, faceNum, col) {
    var offset = faceNum * 16;
    for (var i = 0; i < 16; i += 4) {
      colors[offset + i] = col[0];
      colors[offset + i + 1] = col[1];
      colors[offset + i + 2] = col[2];
      colors[offset + i + 3] = 1;
    }
  }
  function pushMeshColors(colors, faceNum, col, aoVals, revAo, A, B, C, D) {
    var offset = faceNum * 16;
    pushAOColor(colors, offset, col, A, aoVals, revAo);
    pushAOColor(colors, offset + 4, col, D, aoVals, revAo);
    pushAOColor(colors, offset + 8, col, C, aoVals, revAo);
    pushAOColor(colors, offset + 12, col, B, aoVals, revAo);
  }
  function pushAOColor(colors, ix, baseCol, ao, aoVals, revAoVal) {
    var mult = ao === 0 ? revAoVal : aoVals[ao - 1];
    colors[ix] = baseCol[0] * mult;
    colors[ix + 1] = baseCol[1] * mult;
    colors[ix + 2] = baseCol[2] * mult;
    colors[ix + 3] = 1;
  }
}
function packAOMask(isSolid, ipos, ineg, j, k, skipReverse = false) {
  var A = 1;
  var B = 1;
  var D = 1;
  var C = 1;
  if (isSolid(ipos, j + 1, k)) {
    ++D;
    ++C;
  }
  if (isSolid(ipos, j - 1, k)) {
    ++A;
    ++B;
  }
  if (isSolid(ipos, j, k + 1)) {
    ++B;
    ++C;
  }
  if (isSolid(ipos, j, k - 1)) {
    ++A;
    ++D;
  }
  var facingSolid = isSolid(ipos, j, k);
  if (facingSolid) {
    C = C === 3 || isSolid(ipos, j + 1, k + 1) ? 3 : 2;
    B = B === 3 || isSolid(ipos, j - 1, k + 1) ? 3 : 2;
    D = D === 3 || isSolid(ipos, j + 1, k - 1) ? 3 : 2;
    A = A === 3 || isSolid(ipos, j - 1, k - 1) ? 3 : 2;
    return C << 6 | D << 4 | B << 2 | A;
  }
  if (skipReverse) {
    if (C === 1 && isSolid(ipos, j + 1, k + 1)) {
      C = 2;
    }
    if (B === 1 && isSolid(ipos, j - 1, k + 1)) {
      B = 2;
    }
    if (D === 1 && isSolid(ipos, j + 1, k - 1)) {
      D = 2;
    }
    if (A === 1 && isSolid(ipos, j - 1, k - 1)) {
      A = 2;
    }
    return C << 6 | D << 4 | B << 2 | A;
  }
  if (C === 1) {
    if (isSolid(ipos, j + 1, k + 1)) {
      C = 2;
    } else if (!isSolid(ineg, j, k + 1) || !isSolid(ineg, j + 1, k) || !isSolid(ineg, j + 1, k + 1)) {
      C = 0;
    }
  }
  if (D === 1) {
    if (isSolid(ipos, j + 1, k - 1)) {
      D = 2;
    } else if (!isSolid(ineg, j, k - 1) || !isSolid(ineg, j + 1, k) || !isSolid(ineg, j + 1, k - 1)) {
      D = 0;
    }
  }
  if (B === 1) {
    if (isSolid(ipos, j - 1, k + 1)) {
      B = 2;
    } else if (!isSolid(ineg, j, k + 1) || !isSolid(ineg, j - 1, k) || !isSolid(ineg, j - 1, k + 1)) {
      B = 0;
    }
  }
  if (A === 1) {
    if (isSolid(ipos, j - 1, k - 1)) {
      A = 2;
    } else if (!isSolid(ineg, j, k - 1) || !isSolid(ineg, j - 1, k) || !isSolid(ineg, j - 1, k - 1)) {
      A = 0;
    }
  }
  return C << 6 | D << 4 | B << 2 | A;
}
function unpackAOMask(aomask) {
  var A = aomask & 3;
  var B = aomask >> 2 & 3;
  var D = aomask >> 4 & 3;
  var C = aomask >> 6 & 3;
  return [A, B, C, D];
}
var profile_hook2 = PROFILE_EVERY ? makeProfileHook(PROFILE_EVERY, "Meshing") : () => {
};

// node_modules/noa-engine/src/lib/registry.js
var defaults = {
  texturePath: ""
};
var MAX_BLOCK_ID = (1 << 16) - 1;
var Registry = class {
  /** 
   * @internal 
   * @param {import('../index').Engine} noa
  */
  constructor(noa, opts) {
    opts = Object.assign({}, defaults, opts);
    this.noa = noa;
    this._texturePath = opts.texturePath;
    var matIDs = {};
    var blockSolidity = [false];
    var blockOpacity = [false];
    var blockIsFluid = [false];
    var blockIsObject = [false];
    var blockProps = [null];
    var blockMeshes = [null];
    var blockHandlers = [null];
    var blockIsPlain = [false];
    var blockMats = [0, 0, 0, 0, 0, 0];
    var matColorLookup = [null];
    var matAtlasIndexLookup = [-1];
    var matDefs = [];
    this.registerBlock = function(id = 1, options = null) {
      var defaults3 = new BlockOptions(options && options.fluid);
      var opts2 = Object.assign({}, defaults3, options || {});
      if (id < 1 || id > MAX_BLOCK_ID) throw "Block id out of range: " + id;
      while (id > blockSolidity.length) {
        this.registerBlock(blockSolidity.length, {});
      }
      blockSolidity[id] = !!opts2.solid;
      blockOpacity[id] = !!opts2.opaque;
      blockIsFluid[id] = !!opts2.fluid;
      blockIsObject[id] = !!opts2.blockMesh;
      blockMeshes[id] = opts2.blockMesh || null;
      var mat = opts2.material || null;
      var mats;
      if (!mat) {
        mats = [null, null, null, null, null, null];
      } else if (typeof mat == "string") {
        mats = [mat, mat, mat, mat, mat, mat];
      } else if (mat.length && mat.length == 2) {
        mats = [mat[1], mat[1], mat[0], mat[0], mat[1], mat[1]];
      } else if (mat.length && mat.length == 3) {
        mats = [mat[2], mat[2], mat[0], mat[1], mat[2], mat[2]];
      } else if (mat.length && mat.length == 6) {
        mats = mat;
      } else throw "Invalid material parameter: " + mat;
      for (var i = 0; i < 6; ++i) {
        blockMats[id * 6 + i] = getMaterialId(this, matIDs, mats[i], true);
      }
      blockProps[id] = {};
      if (blockIsFluid[id]) {
        blockProps[id].fluidDensity = opts2.fluidDensity;
        blockProps[id].viscosity = opts2.viscosity;
      }
      var hasHandler = opts2.onLoad || opts2.onUnload || opts2.onSet || opts2.onUnset || opts2.onCustomMeshCreate;
      blockHandlers[id] = hasHandler ? new BlockCallbackHolder(opts2) : null;
      var isPlain = blockSolidity[id] && blockOpacity[id] && !hasHandler && !blockIsFluid[id] && !blockIsObject[id];
      blockIsPlain[id] = isPlain;
      return id;
    };
    this.registerMaterial = function(name = "?", options = null) {
      if (Array.isArray(options)) {
        throw 'This API changed signatures in v0.33, please use: `noa.registry.registerMaterial("name", optionsObj)`';
      }
      var opts2 = Object.assign(new MaterialOptions(), options || {});
      var matID = matIDs[name] || matDefs.length;
      matIDs[name] = matID;
      var texURL = opts2.textureURL ? this._texturePath + opts2.textureURL : "";
      var alpha = 1;
      var color = opts2.color || [1, 1, 1];
      if (color.length === 4) alpha = color.pop();
      if (texURL) color = null;
      matColorLookup[matID] = color;
      matAtlasIndexLookup[matID] = opts2.atlasIndex;
      matDefs[matID] = {
        color,
        alpha,
        texture: texURL,
        texHasAlpha: !!opts2.texHasAlpha,
        atlasIndex: opts2.atlasIndex,
        renderMat: opts2.renderMaterial
      };
      return matID;
    };
    this.getBlockSolidity = function(id) {
      return blockSolidity[id];
    };
    this.getBlockOpacity = function(id) {
      return blockOpacity[id];
    };
    this.getBlockFluidity = function(id) {
      return blockIsFluid[id];
    };
    this.getBlockProps = function(id) {
      return blockProps[id];
    };
    this.getBlockFaceMaterial = function(blockId, dir) {
      return blockMats[blockId * 6 + dir];
    };
    this.getMaterialData = function(matID) {
      return matDefs[matID];
    };
    this._textureNeedsAlpha = function(tex = "") {
      return matDefs.some((def) => {
        if (def.texture !== tex) return false;
        return def.texHasAlpha;
      });
    };
    this._solidityLookup = blockSolidity;
    this._opacityLookup = blockOpacity;
    this._fluidityLookup = blockIsFluid;
    this._objectLookup = blockIsObject;
    this._blockMeshLookup = blockMeshes;
    this._blockHandlerLookup = blockHandlers;
    this._blockIsPlainLookup = blockIsPlain;
    this._materialColorLookup = matColorLookup;
    this._matAtlasIndexLookup = matAtlasIndexLookup;
    this.registerMaterial("dirt", { color: [0.4, 0.3, 0] });
    this.registerBlock(1, { material: "dirt" });
  }
};
function getMaterialId(reg, matIDs, name, lazyInit) {
  if (!name) return 0;
  var id = matIDs[name];
  if (id === void 0 && lazyInit) id = reg.registerMaterial(name);
  return id;
}
function BlockCallbackHolder(opts) {
  this.onLoad = opts.onLoad || null;
  this.onUnload = opts.onUnload || null;
  this.onSet = opts.onSet || null;
  this.onUnset = opts.onUnset || null;
  this.onCustomMeshCreate = opts.onCustomMeshCreate || null;
}
function BlockOptions(isFluid = false) {
  this.solid = isFluid ? false : true;
  this.opaque = isFluid ? false : true;
  this.fluid = false;
  this.material = null;
  this.blockMesh = null;
  this.fluidDensity = 1;
  this.viscosity = 0.5;
  this.onLoad = null;
  this.onUnload = null;
  this.onSet = null;
  this.onUnset = null;
  this.onCustomMeshCreate = null;
}
function MaterialOptions() {
  this.color = null;
  this.textureURL = null;
  this.texHasAlpha = false;
  this.atlasIndex = -1;
  this.renderMaterial = null;
}

// node_modules/noa-engine/src/lib/rendering.js
var import_gl_vec39 = __toESM(require_gl_vec3());

// node_modules/noa-engine/src/lib/sceneOctreeManager.js
var SceneOctreeManager = class {
  /** @internal */
  constructor(rendering, blockSize) {
    var scene = rendering.scene;
    scene._addComponent(new OctreeSceneComponent(scene));
    var octreeBlock = "noa_octree_block";
    var inDynamicList = "noa_in_dynamic_list";
    var inOctreeBlock = "noa_in_octree_block";
    var octree = new Octree(NOP);
    scene._selectionOctree = octree;
    octree.blocks = [];
    var octBlocksHash = {};
    this.rebase = (offset) => {
      recurseRebaseBlocks(octree, offset);
    };
    this.addMesh = (mesh, isStatic, pos, chunk) => {
      if (!mesh.metadata) mesh.metadata = {};
      if (!isStatic) {
        if (mesh.metadata[inDynamicList]) return;
        octree.dynamicContent.push(mesh);
        mesh.metadata[inDynamicList] = true;
        return;
      }
      var ci = Math.floor(pos[0] / bs);
      var cj = Math.floor(pos[1] / bs);
      var ck = Math.floor(pos[2] / bs);
      var mapKey = locationHasher(ci, cj, ck);
      var block = octBlocksHash[mapKey];
      if (!block) {
        var gloc = [ci * bs, cj * bs, ck * bs];
        var loc = [0, 0, 0];
        rendering.noa.globalToLocal(gloc, null, loc);
        block = makeOctreeBlock(loc, bs);
        octree.blocks.push(block);
        octBlocksHash[mapKey] = block;
        block._noaMapKey = mapKey;
      }
      block.entries.push(mesh);
      mesh.metadata[octreeBlock] = block;
      mesh.metadata[inOctreeBlock] = true;
      mesh.alwaysSelectAsActiveMesh = true;
    };
    this.removeMesh = (mesh) => {
      if (!mesh.metadata) return;
      if (mesh.metadata[inDynamicList]) {
        removeUnorderedListItem(octree.dynamicContent, mesh);
        mesh.metadata[inDynamicList] = false;
      }
      if (mesh.metadata[inOctreeBlock]) {
        var block = mesh.metadata[octreeBlock];
        if (block && block.entries) {
          removeUnorderedListItem(block.entries, mesh);
          if (block.entries.length === 0) {
            delete octBlocksHash[block._noaMapKey];
            removeUnorderedListItem(octree.blocks, block);
          }
        }
        mesh.metadata[octreeBlock] = null;
        mesh.metadata[inOctreeBlock] = false;
      }
    };
    this.setMeshVisibility = (mesh, visible = false) => {
      if (mesh.metadata[octreeBlock]) {
        if (mesh.metadata[inOctreeBlock] === visible) return;
        var block = mesh.metadata[octreeBlock];
        if (block && block.entries) {
          if (visible) {
            block.entries.push(mesh);
          } else {
            removeUnorderedListItem(block.entries, mesh);
          }
        }
        mesh.metadata[inOctreeBlock] = visible;
      } else {
        if (mesh.metadata[inDynamicList] === visible) return;
        if (visible) {
          octree.dynamicContent.push(mesh);
        } else {
          removeUnorderedListItem(octree.dynamicContent, mesh);
        }
        mesh.metadata[inDynamicList] = visible;
      }
    };
    var NOP = () => {
    };
    var bs = blockSize * rendering.noa.world._chunkSize;
    var recurseRebaseBlocks = (parent, offset) => {
      parent.blocks.forEach((child) => {
        child.minPoint.subtractInPlace(offset);
        child.maxPoint.subtractInPlace(offset);
        child._boundingVectors.forEach((v) => v.subtractInPlace(offset));
        if (child.blocks) recurseRebaseBlocks(child, offset);
      });
    };
    var makeOctreeBlock = (minPt, size) => {
      var min2 = new Vector3(minPt[0], minPt[1], minPt[2]);
      var max2 = new Vector3(minPt[0] + size, minPt[1] + size, minPt[2] + size);
      return new OctreeBlock(min2, max2, void 0, void 0, void 0, NOP);
    };
  }
};

// node_modules/noa-engine/src/lib/rendering.js
var PROFILE2 = 0;
var defaults2 = {
  showFPS: false,
  antiAlias: true,
  clearColor: [0.8, 0.9, 1],
  ambientColor: [0.5, 0.5, 0.5],
  lightDiffuse: [1, 1, 1],
  lightSpecular: [1, 1, 1],
  lightVector: [1, -1, 0.5],
  useAO: true,
  AOmultipliers: [0.93, 0.8, 0.5],
  reverseAOmultiplier: 1,
  preserveDrawingBuffer: true,
  octreeBlockSize: 2,
  renderOnResize: true
};
var Rendering = class {
  /** 
   * @internal 
   * @param {import('../index').Engine} noa  
  */
  constructor(noa, opts, canvas) {
    opts = Object.assign({}, defaults2, opts);
    this.noa = noa;
    this.renderOnResize = !!opts.renderOnResize;
    this.useAO = !!opts.useAO;
    this.aoVals = opts.AOmultipliers;
    this.revAoVal = opts.reverseAOmultiplier;
    this.meshingCutoffTime = 6;
    this.engine = null;
    this.scene = null;
    this.light = null;
    this.camera = null;
    this._initScene(canvas, opts);
    if (opts.showFPS) setUpFPS();
  }
  /**
   * Constructor helper - set up the Babylon.js scene and basic components
   * @internal
   */
  _initScene(canvas, opts) {
    this.engine = new Engine(canvas, opts.antiAlias, {
      preserveDrawingBuffer: opts.preserveDrawingBuffer
    });
    var scene = new Scene(this.engine);
    this.scene = scene;
    scene.detachControl();
    scene.performancePriority = ScenePerformancePriority.Intermediate;
    scene.autoClear = true;
    var blockSize = Math.round(opts.octreeBlockSize);
    this._octreeManager = new SceneOctreeManager(this, blockSize);
    this._cameraHolder = new TransformNode("camHolder", scene);
    this.camera = new FreeCamera("camera", new Vector3(0, 0, 0), scene);
    this.camera.parent = this._cameraHolder;
    this.camera.minZ = 0.01;
    this._camScreen = CreatePlane("camScreen", { size: 10 }, scene);
    this.addMeshToScene(this._camScreen);
    this._camScreen.position.z = 0.1;
    this._camScreen.parent = this.camera;
    this._camScreenMat = this.makeStandardMaterial("camera_screen_mat");
    this._camScreen.material = this._camScreenMat;
    this._camScreen.setEnabled(false);
    this._camScreenMat.freeze();
    this._camLocBlock = 0;
    scene.clearColor = Color4.FromArray(opts.clearColor);
    scene.ambientColor = Color3.FromArray(opts.ambientColor);
    var lightVec = Vector3.FromArray(opts.lightVector);
    this.light = new DirectionalLight("light", lightVec, scene);
    this.light.diffuse = Color3.FromArray(opts.lightDiffuse);
    this.light.specular = Color3.FromArray(opts.lightSpecular);
    scene.skipPointerMovePicking = true;
  }
};
Rendering.prototype.getScene = function() {
  return this.scene;
};
Rendering.prototype.tick = function(dt) {
};
Rendering.prototype.render = function() {
  profile_hook3("start");
  updateCameraForRender(this);
  profile_hook3("updateCamera");
  this.engine.beginFrame();
  profile_hook3("beginFrame");
  this.scene.render();
  profile_hook3("render");
  fps_hook();
  this.engine.endFrame();
  profile_hook3("endFrame");
  profile_hook3("end");
};
Rendering.prototype.postRender = function() {
};
Rendering.prototype.resize = function() {
  this.engine.resize();
  if (this.noa._paused && this.renderOnResize) {
    this.scene.render();
  }
};
Rendering.prototype.highlightBlockFace = function(show, posArr, normArr) {
  var m = getHighlightMesh(this);
  if (show) {
    this.noa.globalToLocal(posArr, null, hlpos);
    var dist2 = import_gl_vec39.default.dist(this.noa.camera._localGetPosition(), hlpos);
    var slop = 1e-3 + 1e-3 * dist2;
    for (var i = 0; i < 3; i++) {
      if (normArr[i] === 0) {
        hlpos[i] += 0.5;
      } else {
        hlpos[i] += normArr[i] > 0 ? 1 + slop : -slop;
      }
    }
    m.position.copyFromFloats(hlpos[0], hlpos[1], hlpos[2]);
    m.rotation.x = normArr[1] ? Math.PI / 2 : 0;
    m.rotation.y = normArr[0] ? Math.PI / 2 : 0;
  }
  m.setEnabled(show);
};
var hlpos = [];
Rendering.prototype.addMeshToScene = function(mesh, isStatic = false, pos = null, containingChunk = null) {
  if (!mesh.metadata) mesh.metadata = {};
  if (mesh.metadata[addedToSceneFlag]) {
    this._octreeManager.setMeshVisibility(mesh, true);
    return;
  }
  mesh.metadata[addedToSceneFlag] = true;
  if (!mesh.parent) {
    if (!pos) pos = mesh.position.asArray();
    var lpos = this.noa.globalToLocal(pos, null, []);
    mesh.position.fromArray(lpos);
  }
  this._octreeManager.addMesh(mesh, isStatic, pos, containingChunk);
  mesh.onDisposeObservable.add(() => {
    this._octreeManager.removeMesh(mesh);
    mesh.metadata[addedToSceneFlag] = false;
  });
};
var addedToSceneFlag = "noa_added_to_scene";
Rendering.prototype.setMeshVisibility = function(mesh, visible = false) {
  if (!mesh.metadata) mesh.metadata = {};
  if (mesh.metadata[addedToSceneFlag]) {
    this._octreeManager.setMeshVisibility(mesh, visible);
  } else {
    if (visible) this.addMeshToScene(mesh);
  }
};
Rendering.prototype.makeStandardMaterial = function(name) {
  var mat = new StandardMaterial(name, this.scene);
  mat.specularColor.copyFromFloats(0, 0, 0);
  mat.ambientColor.copyFromFloats(1, 1, 1);
  mat.diffuseColor.copyFromFloats(1, 1, 1);
  return mat;
};
Rendering.prototype.prepareChunkForRendering = function(chunk) {
};
Rendering.prototype.disposeChunkForRendering = function(chunk) {
};
Rendering.prototype._rebaseOrigin = function(delta) {
  var dvec = new Vector3(delta[0], delta[1], delta[2]);
  this.scene.meshes.forEach((mesh) => {
    if (mesh.parent) return;
    mesh.position.subtractInPlace(dvec);
    if (mesh.isWorldMatrixFrozen) {
      mesh.freezeWorldMatrix();
    }
  });
  this._octreeManager.rebase(dvec);
};
function updateCameraForRender(self) {
  var cam = self.noa.camera;
  var tgtLoc = cam._localGetTargetPosition();
  self._cameraHolder.position.copyFromFloats(tgtLoc[0], tgtLoc[1], tgtLoc[2]);
  self._cameraHolder.rotation.x = cam.pitch;
  self._cameraHolder.rotation.y = cam.heading;
  self.camera.position.z = -cam.currentZoom;
  var cloc = cam._localGetPosition();
  var off = self.noa.worldOriginOffset;
  var cx = Math.floor(cloc[0] + off[0]);
  var cy = Math.floor(cloc[1] + off[1]);
  var cz = Math.floor(cloc[2] + off[2]);
  var id = self.noa.getBlock(cx, cy, cz);
  checkCameraEffect(self, id);
}
function checkCameraEffect(self, id) {
  if (id === self._camLocBlock) return;
  if (id === 0) {
    self._camScreen.setEnabled(false);
  } else {
    var matId = self.noa.registry.getBlockFaceMaterial(id, 0);
    if (matId) {
      var matData = self.noa.registry.getMaterialData(matId);
      var col = matData.color;
      var alpha = matData.alpha;
      if (col && alpha && alpha < 1) {
        self._camScreenMat.diffuseColor.set(0, 0, 0);
        self._camScreenMat.ambientColor.set(col[0], col[1], col[2]);
        self._camScreenMat.alpha = alpha;
        self._camScreen.setEnabled(true);
      }
    }
  }
  self._camLocBlock = id;
}
function getHighlightMesh(rendering) {
  var mesh = rendering._highlightMesh;
  if (!mesh) {
    mesh = CreatePlane("highlight", { size: 1 }, rendering.scene);
    var hlm = rendering.makeStandardMaterial("block_highlight_mat");
    hlm.backFaceCulling = false;
    hlm.emissiveColor = new Color3(1, 1, 1);
    hlm.alpha = 0.2;
    hlm.freeze();
    mesh.material = hlm;
    var s = 0.5;
    var lines = CreateLines("hightlightLines", {
      points: [
        new Vector3(s, s, 0),
        new Vector3(s, -s, 0),
        new Vector3(-s, -s, 0),
        new Vector3(-s, s, 0),
        new Vector3(s, s, 0)
      ]
    }, rendering.scene);
    lines.color = new Color3(1, 1, 1);
    lines.parent = mesh;
    rendering.addMeshToScene(mesh);
    rendering.addMeshToScene(lines);
    rendering._highlightMesh = mesh;
  }
  return mesh;
}
Rendering.prototype.debug_SceneCheck = function() {
  var meshes = this.scene.meshes;
  var octree = this.scene._selectionOctree;
  var dyns = octree.dynamicContent;
  var octs = [];
  var numOcts = 0;
  var numSubs = 0;
  var mats = this.scene.materials;
  var allmats = [];
  mats.forEach((mat) => {
    if (mat.subMaterials) mat.subMaterials.forEach((mat2) => allmats.push(mat2));
    else allmats.push(mat);
  });
  octree.blocks.forEach(function(block) {
    numOcts++;
    block.entries.forEach((m) => octs.push(m));
  });
  meshes.forEach(function(m) {
    if (m.isDisposed()) warn(m, "disposed mesh in scene");
    if (empty(m)) return;
    if (missing(m, dyns, octs)) warn(m, "non-empty mesh missing from octree");
    if (!m.material) {
      warn(m, "non-empty scene mesh with no material");
      return;
    }
    numSubs += m.subMeshes ? m.subMeshes.length : 1;
    var mats2 = m.material.subMaterials || [m.material];
    mats2.forEach(function(mat) {
      if (missing(mat, mats2)) warn(mat, "mesh material not in scene");
    });
  });
  var unusedMats = [];
  allmats.forEach((mat) => {
    var used = false;
    meshes.forEach((mesh) => {
      if (mesh.material === mat) used = true;
      if (!mesh.material) return;
      var mats2 = mesh.material.subMaterials || [mesh.material];
      if (mats2.includes(mat)) used = true;
    });
    if (!used) unusedMats.push(mat.name);
  });
  if (unusedMats.length) {
    console.warn("Materials unused by any mesh: ", unusedMats.join(", "));
  }
  dyns.forEach(function(m) {
    if (missing(m, meshes)) warn(m, "octree/dynamic mesh not in scene");
  });
  octs.forEach(function(m) {
    if (missing(m, meshes)) warn(m, "octree block mesh not in scene");
  });
  var avgPerOct = Math.round(10 * octs.length / numOcts) / 10;
  console.log(
    "meshes - octree:",
    octs.length,
    "  dynamic:",
    dyns.length,
    "   subMeshes:",
    numSubs,
    "   avg meshes/octreeBlock:",
    avgPerOct
  );
  function warn(obj, msg) {
    console.warn(obj.name + " --- " + msg);
  }
  function empty(mesh) {
    return mesh.getIndices().length === 0;
  }
  function missing(obj, list1, list2) {
    if (!obj) return false;
    if (list1.includes(obj)) return false;
    if (list2 && list2.includes(obj)) return false;
    return true;
  }
  return "done.";
};
Rendering.prototype.debug_MeshCount = function() {
  var ct = {};
  this.scene.meshes.forEach((m) => {
    var n = m.name || "";
    n = n.replace(/-\d+.*/, "#");
    n = n.replace(/\d+.*/, "#");
    n = n.replace(/(rotHolder|camHolder|camScreen)/, "rendering use");
    n = n.replace(/atlas sprite .*/, "atlas sprites");
    ct[n] = ct[n] || 0;
    ct[n]++;
  });
  for (var s in ct) console.log("   " + (ct[s] + "       ").substr(0, 7) + s);
};
var profile_hook3 = PROFILE2 ? makeProfileHook(200, "render internals") : () => {
};
var fps_hook = function() {
};
function setUpFPS() {
  var div2 = document.createElement("div");
  div2.id = "noa_fps";
  div2.style.position = "absolute";
  div2.style.top = "0";
  div2.style.right = "0";
  div2.style.zIndex = "0";
  div2.style.color = "white";
  div2.style.backgroundColor = "rgba(0,0,0,0.5)";
  div2.style.font = "14px monospace";
  div2.style.textAlign = "center";
  div2.style.minWidth = "2em";
  div2.style.margin = "4px";
  document.body.appendChild(div2);
  var every = 1e3;
  var ct = 0;
  var longest = 0;
  var start = performance.now();
  var last = start;
  fps_hook = function() {
    ct++;
    var nt = performance.now();
    if (nt - last > longest) longest = nt - last;
    last = nt;
    if (nt - start < every) return;
    var fps = Math.round(ct / (nt - start) * 1e3);
    var min2 = Math.round(1 / longest * 1e3);
    div2.innerHTML = fps + "<br>" + min2;
    ct = 0;
    longest = 0;
    start = nt;
  };
}

// node_modules/voxel-physics-engine/src/index.js
var import_gl_vec311 = __toESM(require_gl_vec3());
var import_voxel_aabb_sweep2 = __toESM(require_voxel_aabb_sweep());

// node_modules/voxel-physics-engine/src/rigidBody.js
var import_gl_vec310 = __toESM(require_gl_vec3());
var DEBUG = 0;
var RigidBody = class {
  constructor(_aabb, mass, friction, restitution, gravMult, onCollide, autoStep) {
    this.aabb = new AABB(_aabb.base, _aabb.vec);
    this.mass = mass;
    this.friction = friction;
    this.restitution = restitution;
    this.gravityMultiplier = gravMult;
    this.onCollide = onCollide;
    this.autoStep = !!autoStep;
    this.airDrag = -1;
    this.fluidDrag = -1;
    this.onStep = null;
    this.velocity = import_gl_vec310.default.create();
    this.resting = [0, 0, 0];
    this.inFluid = false;
    this._ratioInFluid = 0;
    this._forces = import_gl_vec310.default.create();
    this._impulses = import_gl_vec310.default.create();
    this._sleepFrameCount = 10 | 0;
  }
  setPosition(p) {
    sanityCheck(p);
    import_gl_vec310.default.subtract(p, p, this.aabb.base);
    this.aabb.translate(p);
    this._markActive();
  }
  getPosition() {
    return import_gl_vec310.default.clone(this.aabb.base);
  }
  applyForce(f) {
    sanityCheck(f);
    import_gl_vec310.default.add(this._forces, this._forces, f);
    this._markActive();
  }
  applyImpulse(i) {
    sanityCheck(i);
    import_gl_vec310.default.add(this._impulses, this._impulses, i);
    this._markActive();
  }
  /** @internal */
  _markActive() {
    this._sleepFrameCount = 10 | 0;
  }
  // temp
  atRestX() {
    return this.resting[0];
  }
  atRestY() {
    return this.resting[1];
  }
  atRestZ() {
    return this.resting[2];
  }
};
var sanityCheck = (v) => {
};
if (DEBUG) sanityCheck = (v) => {
  if (isNaN(import_gl_vec310.default.length(v))) throw "Vector with NAN: " + v;
};

// node_modules/voxel-physics-engine/src/index.js
var DEBUG2 = 0;
function DefaultOptions2() {
  this.airDrag = 0.1;
  this.fluidDrag = 0.4;
  this.fluidDensity = 2;
  this.gravity = [0, -10, 0];
  this.minBounceImpulse = 0.5;
}
function Physics(opts, testSolid, testFluid) {
  opts = Object.assign(new DefaultOptions2(), opts);
  this.gravity = opts.gravity || [0, -10, 0];
  this.airDrag = opts.airDrag || 0.1;
  this.fluidDensity = opts.fluidDensity || 2;
  this.fluidDrag = opts.fluidDrag || 0.4;
  this.minBounceImpulse = opts.minBounceImpulse;
  this.bodies = [];
  this.testSolid = testSolid;
  this.testFluid = testFluid;
}
Physics.prototype.addBody = function(_aabb, mass, friction, restitution, gravMult, onCollide) {
  _aabb = _aabb || new AABB([0, 0, 0], [1, 1, 1]);
  if (typeof mass == "undefined") mass = 1;
  if (typeof friction == "undefined") friction = 1;
  if (typeof restitution == "undefined") restitution = 0;
  if (typeof gravMult == "undefined") gravMult = 1;
  var b = new RigidBody(_aabb, mass, friction, restitution, gravMult, onCollide);
  this.bodies.push(b);
  return b;
};
Physics.prototype.removeBody = function(b) {
  var i = this.bodies.indexOf(b);
  if (i < 0) return void 0;
  this.bodies.splice(i, 1);
  b.aabb = b.onCollide = null;
};
var a = import_gl_vec311.default.create();
var dv = import_gl_vec311.default.create();
var dx = import_gl_vec311.default.create();
var impacts = import_gl_vec311.default.create();
var oldResting = import_gl_vec311.default.create();
Physics.prototype.tick = function(dt) {
  dt = dt / 1e3;
  var noGravity = equals2(0, import_gl_vec311.default.squaredLength(this.gravity));
  this.bodies.forEach((b) => iterateBody(this, b, dt, noGravity));
};
function iterateBody(self, b, dt, noGravity) {
  import_gl_vec311.default.copy(oldResting, b.resting);
  if (b.mass <= 0) {
    import_gl_vec311.default.set(b.velocity, 0, 0, 0);
    import_gl_vec311.default.set(b._forces, 0, 0, 0);
    import_gl_vec311.default.set(b._impulses, 0, 0, 0);
    return;
  }
  var localNoGrav = noGravity || b.gravityMultiplier === 0;
  if (bodyAsleep(self, b, dt, localNoGrav)) return;
  b._sleepFrameCount--;
  applyFluidForces(self, b);
  sanityCheck2(b._forces);
  sanityCheck2(b._impulses);
  sanityCheck2(b.velocity);
  sanityCheck2(b.resting);
  import_gl_vec311.default.scale(a, b._forces, 1 / b.mass);
  import_gl_vec311.default.scaleAndAdd(a, a, self.gravity, b.gravityMultiplier);
  import_gl_vec311.default.scale(dv, b._impulses, 1 / b.mass);
  import_gl_vec311.default.scaleAndAdd(dv, dv, a, dt);
  import_gl_vec311.default.add(b.velocity, b.velocity, dv);
  if (b.friction) {
    applyFrictionByAxis(0, b, dv);
    applyFrictionByAxis(1, b, dv);
    applyFrictionByAxis(2, b, dv);
  }
  var drag = b.airDrag >= 0 ? b.airDrag : self.airDrag;
  if (b.inFluid) {
    drag = b.fluidDrag >= 0 ? b.fluidDrag : self.fluidDrag;
    drag *= 1 - (1 - b.ratioInFluid) ** 2;
  }
  var mult = Math.max(1 - drag * dt / b.mass, 0);
  import_gl_vec311.default.scale(b.velocity, b.velocity, mult);
  import_gl_vec311.default.scale(dx, b.velocity, dt);
  import_gl_vec311.default.set(b._forces, 0, 0, 0);
  import_gl_vec311.default.set(b._impulses, 0, 0, 0);
  if (b.autoStep) {
    cloneAABB(tmpBox, b.aabb);
  }
  processCollisions(self, b.aabb, dx, b.resting);
  if (b.autoStep) {
    tryAutoStepping(self, b, tmpBox, dx);
  }
  for (var i = 0; i < 3; ++i) {
    impacts[i] = 0;
    if (b.resting[i]) {
      if (!oldResting[i]) impacts[i] = -b.velocity[i];
      b.velocity[i] = 0;
    }
  }
  var mag = import_gl_vec311.default.length(impacts);
  if (mag > 1e-3) {
    import_gl_vec311.default.scale(impacts, impacts, b.mass);
    if (b.onCollide) b.onCollide(impacts);
    if (b.restitution > 0 && mag > self.minBounceImpulse) {
      import_gl_vec311.default.scale(impacts, impacts, b.restitution);
      b.applyImpulse(impacts);
    }
  }
  var vsq = import_gl_vec311.default.squaredLength(b.velocity);
  if (vsq > 1e-5) b._markActive();
}
function applyFluidForces(self, body) {
  var box = body.aabb;
  var cx = Math.floor(box.base[0]);
  var cz = Math.floor(box.base[2]);
  var y0 = Math.floor(box.base[1]);
  var y1 = Math.floor(box.max[1]);
  if (!self.testFluid(cx, y0, cz)) {
    body.inFluid = false;
    body.ratioInFluid = 0;
    return;
  }
  var submerged = 1;
  var cy = y0 + 1;
  while (cy <= y1 && self.testFluid(cx, cy, cz)) {
    submerged++;
    cy++;
  }
  var fluidLevel = y0 + submerged;
  var heightInFluid = fluidLevel - box.base[1];
  var ratioInFluid = heightInFluid / box.vec[1];
  if (ratioInFluid > 1) ratioInFluid = 1;
  var vol = box.vec[0] * box.vec[1] * box.vec[2];
  var displaced = vol * ratioInFluid;
  var f = _fluidVec;
  import_gl_vec311.default.scale(f, self.gravity, -self.fluidDensity * displaced);
  body.applyForce(f);
  body.inFluid = true;
  body.ratioInFluid = ratioInFluid;
}
var _fluidVec = import_gl_vec311.default.create();
function applyFrictionByAxis(axis, body, dvel) {
  var restDir = body.resting[axis];
  var vNormal = dvel[axis];
  if (restDir === 0) return;
  if (restDir * vNormal <= 0) return;
  import_gl_vec311.default.copy(lateralVel, body.velocity);
  lateralVel[axis] = 0;
  var vCurr = import_gl_vec311.default.length(lateralVel);
  if (equals2(vCurr, 0)) return;
  var dvMax = Math.abs(body.friction * vNormal);
  var scaler = vCurr > dvMax ? (vCurr - dvMax) / vCurr : 0;
  body.velocity[(axis + 1) % 3] *= scaler;
  body.velocity[(axis + 2) % 3] *= scaler;
}
var lateralVel = import_gl_vec311.default.create();
function processCollisions(self, box, velocity, resting) {
  import_gl_vec311.default.set(resting, 0, 0, 0);
  return (0, import_voxel_aabb_sweep2.default)(self.testSolid, box, velocity, function(dist2, axis, dir, vec) {
    resting[axis] = dir;
    vec[axis] = 0;
  });
}
var tmpBox = new AABB([], []);
var tmpResting = import_gl_vec311.default.create();
var targetPos = import_gl_vec311.default.create();
var upvec = import_gl_vec311.default.create();
var leftover = import_gl_vec311.default.create();
function tryAutoStepping(self, b, oldBox, dx2) {
  if (b.resting[1] >= 0 && !b.inFluid) return;
  var xBlocked = b.resting[0] !== 0;
  var zBlocked = b.resting[2] !== 0;
  if (!(xBlocked || zBlocked)) return;
  var ratio = Math.abs(dx2[0] / dx2[2]);
  var cutoff = 4;
  if (!xBlocked && ratio > cutoff) return;
  if (!zBlocked && ratio < 1 / cutoff) return;
  import_gl_vec311.default.add(targetPos, oldBox.base, dx2);
  var getVoxels = self.testSolid;
  (0, import_voxel_aabb_sweep2.default)(getVoxels, oldBox, dx2, function(dist2, axis, dir, vec) {
    if (axis === 1) vec[axis] = 0;
    else return true;
  });
  var y = b.aabb.base[1];
  var ydist = Math.floor(y + 1.001) - y;
  import_gl_vec311.default.set(upvec, 0, ydist, 0);
  var collided = false;
  (0, import_voxel_aabb_sweep2.default)(getVoxels, oldBox, upvec, function(dist2, axis, dir, vec) {
    collided = true;
    return true;
  });
  if (collided) return;
  import_gl_vec311.default.subtract(leftover, targetPos, oldBox.base);
  leftover[1] = 0;
  processCollisions(self, oldBox, leftover, tmpResting);
  if (xBlocked && !equals2(oldBox.base[0], targetPos[0])) return;
  if (zBlocked && !equals2(oldBox.base[2], targetPos[2])) return;
  cloneAABB(b.aabb, oldBox);
  b.resting[0] = tmpResting[0];
  b.resting[2] = tmpResting[2];
  if (b.onStep) b.onStep();
}
function bodyAsleep(self, body, dt, noGravity) {
  if (body._sleepFrameCount > 0) return false;
  if (noGravity) return true;
  var isResting = false;
  var gmult = 0.5 * dt * dt * body.gravityMultiplier;
  import_gl_vec311.default.scale(sleepVec, self.gravity, gmult);
  (0, import_voxel_aabb_sweep2.default)(self.testSolid, body.aabb, sleepVec, function() {
    isResting = true;
    return true;
  }, true);
  return isResting;
}
var sleepVec = import_gl_vec311.default.create();
function equals2(a2, b) {
  return Math.abs(a2 - b) < 1e-5;
}
function cloneAABB(tgt, src) {
  for (var i = 0; i < 3; i++) {
    tgt.base[i] = src.base[i];
    tgt.max[i] = src.max[i];
    tgt.vec[i] = src.vec[i];
  }
}
var sanityCheck2 = function(v) {
};
if (DEBUG2) sanityCheck2 = function(v) {
  if (isNaN(import_gl_vec311.default.length(v))) throw "Vector with NAN: " + v;
};

// node_modules/noa-engine/src/lib/physics.js
var defaultOptions3 = {
  gravity: [0, -10, 0],
  airDrag: 0.1
};
var Physics2 = class extends Physics {
  /** 
   * @internal 
   * @param {import('../index').Engine} noa
  */
  constructor(noa, opts) {
    opts = Object.assign({}, defaultOptions3, opts);
    var world = noa.world;
    var solidLookup = noa.registry._solidityLookup;
    var fluidLookup = noa.registry._fluidityLookup;
    var offset = noa.worldOriginOffset;
    var blockGetter = (x, y, z) => {
      var id = world.getBlockID(x + offset[0], y + offset[1], z + offset[2]);
      return solidLookup[id];
    };
    var isFluidGetter = (x, y, z) => {
      var id = world.getBlockID(x + offset[0], y + offset[1], z + offset[2]);
      return fluidLookup[id];
    };
    super(opts, blockGetter, isFluidGetter);
  }
};

// node_modules/noa-engine/src/lib/world.js
var import_events3 = __toESM(require_events());

// node_modules/noa-engine/src/lib/chunk.js
var import_ndarray2 = __toESM(require_ndarray());
function Chunk(noa, requestID, ci, cj, ck, size, dataArray, fillVoxelID = -1) {
  this.noa = noa;
  this.isDisposed = false;
  this.userData = null;
  this.requestID = requestID;
  this.voxels = dataArray;
  this.i = ci;
  this.j = cj;
  this.k = ck;
  this.size = size;
  this.x = ci * size;
  this.y = cj * size;
  this.z = ck * size;
  this.pos = [this.x, this.y, this.z];
  this._terrainDirty = false;
  this._objectsDirty = false;
  this._terrainMeshes = [];
  noa._terrainMesher.initChunk(this);
  noa._objectMesher.initChunk(this);
  this._isFull = false;
  this._isEmpty = false;
  this._wholeLayerVoxel = Array(size).fill(-1);
  if (fillVoxelID >= 0) {
    this.voxels.data.fill(fillVoxelID, 0, this.voxels.size);
    this._wholeLayerVoxel.fill(fillVoxelID);
  }
  var narr = Array.from(Array(27), () => null);
  this._neighbors = (0, import_ndarray2.default)(narr, [3, 3, 3]).lo(1, 1, 1);
  this._neighbors.set(0, 0, 0, this);
  this._neighborCount = 0;
  this._timesMeshed = 0;
  this._blockHandlerLocs = new LocationQueue();
  scanVoxelData(this);
}
Chunk._createVoxelArray = function(size) {
  var arr = new Uint16Array(size * size * size);
  return (0, import_ndarray2.default)(arr, [size, size, size]);
};
Chunk.prototype._updateVoxelArray = function(dataArray, fillVoxelID = -1) {
  callAllBlockHandlers(this, "onUnload");
  this.noa._objectMesher.disposeChunk(this);
  this.noa._terrainMesher.disposeChunk(this);
  this.voxels = dataArray;
  this._terrainDirty = false;
  this._objectsDirty = false;
  this._blockHandlerLocs.empty();
  this.noa._objectMesher.initChunk(this);
  this.noa._terrainMesher.initChunk(this);
  if (fillVoxelID >= 0) {
    this._wholeLayerVoxel.fill(fillVoxelID);
  } else {
    this._wholeLayerVoxel.fill(-1);
  }
  scanVoxelData(this);
};
Chunk.prototype.get = function(i, j, k) {
  return this.voxels.get(i, j, k);
};
Chunk.prototype.getSolidityAt = function(i, j, k) {
  var solidLookup = this.noa.registry._solidityLookup;
  return solidLookup[this.voxels.get(i, j, k)];
};
Chunk.prototype.set = function(i, j, k, newID) {
  var oldID = this.voxels.get(i, j, k);
  if (newID === oldID) return;
  this.voxels.set(i, j, k, newID);
  var solidLookup = this.noa.registry._solidityLookup;
  var objectLookup = this.noa.registry._objectLookup;
  var opaqueLookup = this.noa.registry._opacityLookup;
  var handlerLookup = this.noa.registry._blockHandlerLookup;
  if (!opaqueLookup[newID]) this._isFull = false;
  if (newID !== 0) this._isEmpty = false;
  if (this._wholeLayerVoxel[j] !== newID) this._wholeLayerVoxel[j] = -1;
  var hold = handlerLookup[oldID];
  var hnew = handlerLookup[newID];
  if (hold) callBlockHandler(this, hold, "onUnset", i, j, k);
  if (hnew) {
    callBlockHandler(this, hnew, "onSet", i, j, k);
    this._blockHandlerLocs.add(i, j, k);
  } else {
    this._blockHandlerLocs.remove(i, j, k);
  }
  var objMesher = this.noa._objectMesher;
  var objOld = objectLookup[oldID];
  var objNew = objectLookup[newID];
  if (objOld) objMesher.setObjectBlock(this, 0, i, j, k);
  if (objNew) objMesher.setObjectBlock(this, newID, i, j, k);
  var solidityChanged = solidLookup[oldID] !== solidLookup[newID];
  var opacityChanged = opaqueLookup[oldID] !== opaqueLookup[newID];
  var wasTerrain = !objOld && oldID !== 0;
  var nowTerrain = !objNew && newID !== 0;
  if (objOld || objNew) this._objectsDirty = true;
  if (solidityChanged || opacityChanged || wasTerrain || nowTerrain) {
    this._terrainDirty = true;
  }
  if (this._terrainDirty || this._objectsDirty) {
    this.noa.world._queueChunkForRemesh(this);
  }
  if (solidityChanged || opacityChanged) {
    var edge = this.size - 1;
    var imin = i === 0 ? -1 : 0;
    var jmin = j === 0 ? -1 : 0;
    var kmin = k === 0 ? -1 : 0;
    var imax = i === edge ? 1 : 0;
    var jmax = j === edge ? 1 : 0;
    var kmax = k === edge ? 1 : 0;
    for (var ni = imin; ni <= imax; ni++) {
      for (var nj = jmin; nj <= jmax; nj++) {
        for (var nk = kmin; nk <= kmax; nk++) {
          if ((ni | nj | nk) === 0) continue;
          var nab = this._neighbors.get(ni, nj, nk);
          if (!nab) continue;
          nab._terrainDirty = true;
          this.noa.world._queueChunkForRemesh(nab);
        }
      }
    }
  }
};
function callBlockHandler(chunk, handlers, type, i, j, k) {
  var handler = handlers[type];
  if (!handler) return;
  handler(chunk.x + i, chunk.y + j, chunk.z + k);
}
Chunk.prototype.updateMeshes = function() {
  if (this._terrainDirty) {
    this.noa._terrainMesher.meshChunk(this);
    this._timesMeshed++;
    this._terrainDirty = false;
  }
  if (this._objectsDirty) {
    this.noa._objectMesher.buildObjectMeshes();
    this._objectsDirty = false;
  }
};
function scanVoxelData(chunk) {
  var voxels = chunk.voxels;
  var data = voxels.data;
  var len2 = voxels.shape[0];
  var opaqueLookup = chunk.noa.registry._opacityLookup;
  var handlerLookup = chunk.noa.registry._blockHandlerLookup;
  var objectLookup = chunk.noa.registry._objectLookup;
  var plainLookup = chunk.noa.registry._blockIsPlainLookup;
  var objMesher = chunk.noa._objectMesher;
  var fullyOpaque = true;
  var fullyAir = true;
  for (var j = 0; j < len2; ++j) {
    var layerID = chunk._wholeLayerVoxel[j];
    if (layerID >= 0 && !objMesher[layerID] && !handlerLookup[layerID]) {
      if (!opaqueLookup[layerID]) fullyOpaque = false;
      if (layerID !== 0) fullyAir = false;
      continue;
    }
    var constantID = voxels.get(0, j, 0);
    for (var i = 0; i < len2; ++i) {
      var index = voxels.index(i, j, 0);
      for (var k = 0; k < len2; ++k, ++index) {
        var id = data[index];
        if (constantID >= 0 && id !== constantID) constantID = -1;
        if (id === 0) {
          fullyOpaque = false;
          continue;
        }
        if (plainLookup[id]) {
          fullyAir = false;
          continue;
        }
        fullyOpaque = fullyOpaque && opaqueLookup[id];
        fullyAir = false;
        if (objectLookup[id]) {
          objMesher.setObjectBlock(chunk, id, i, j, k);
          chunk._objectsDirty = true;
        }
        var handlers = handlerLookup[id];
        if (handlers) {
          chunk._blockHandlerLocs.add(i, j, k);
          callBlockHandler(chunk, handlers, "onLoad", i, j, k);
        }
      }
    }
    if (constantID >= 0) chunk._wholeLayerVoxel[j] = constantID;
  }
  chunk._isFull = fullyOpaque;
  chunk._isEmpty = fullyAir;
  chunk._terrainDirty = !chunk._isEmpty;
}
Chunk.prototype.dispose = function() {
  callAllBlockHandlers(this, "onUnload");
  this._blockHandlerLocs.empty();
  this.noa._objectMesher.disposeChunk(this);
  this.noa._terrainMesher.disposeChunk(this);
  this.voxels.data = null;
  this.voxels = null;
  this._neighbors.data = null;
  this._neighbors = null;
  this.isDisposed = true;
};
function callAllBlockHandlers(chunk, type) {
  var voxels = chunk.voxels;
  var handlerLookup = chunk.noa.registry._blockHandlerLookup;
  chunk._blockHandlerLocs.arr.forEach(([i, j, k]) => {
    var id = voxels.get(i, j, k);
    callBlockHandler(chunk, handlerLookup[id], type, i, j, k);
  });
}

// node_modules/noa-engine/src/lib/world.js
var PROFILE_EVERY2 = 0;
var PROFILE_QUEUES_EVERY = 0;
var defaultOptions4 = {
  chunkSize: 24,
  chunkAddDistance: [2, 2],
  // [horizontal, vertical]
  chunkRemoveDistance: [3, 3],
  // [horizontal, vertical]
  worldGenWhilePaused: false,
  manuallyControlChunkLoading: false
};
var World = class extends import_events3.default {
  /** @internal */
  constructor(noa, opts) {
    super();
    opts = Object.assign({}, defaultOptions4, opts);
    this.noa = noa;
    this.playerChunkLoaded = false;
    this.Chunk = Chunk;
    this.manuallyControlChunkLoading = !!opts.manuallyControlChunkLoading;
    this.chunkSortingDistFn = defaultSortDistance;
    this.minNeighborsToMesh = 6;
    this.worldGenWhilePaused = !!opts.worldGenWhilePaused;
    this.maxChunksPendingCreation = 50;
    this.maxChunksPendingMeshing = 50;
    this.maxProcessingPerTick = 5;
    this.maxProcessingPerRender = 3;
    this._chunkSize = opts.chunkSize;
    this._chunkAddDistance = [2, 2];
    this._chunkRemoveDistance = [3, 3];
    this._addDistanceFn = null;
    this._remDistanceFn = null;
    this._prevWorldName = "";
    this._prevPlayerChunkHash = 0;
    this._chunkAddSearchFrom = 0;
    this._prevSortingFn = null;
    this._sortMeshQueueEvery = 0;
    this._chunksKnown = new LocationQueue();
    this._chunksToRequest = new LocationQueue();
    this._chunksInvalidated = new LocationQueue();
    this._chunksToRemove = new LocationQueue();
    this._chunksPending = new LocationQueue();
    this._chunksToMesh = new LocationQueue();
    this._chunksToMeshFirst = new LocationQueue();
    this._chunksSortedLocs = new LocationQueue();
    this.setAddRemoveDistance(opts.chunkAddDistance, opts.chunkRemoveDistance);
    this._storage = new ChunkStorage();
    var cs = this._chunkSize;
    this._coordsToChunkIndexes = chunkCoordsToIndexesGeneral;
    this._coordsToChunkLocals = chunkCoordsToLocalsGeneral;
    var powerOfTwo = (cs & cs - 1) === 0;
    if (powerOfTwo) {
      this._coordShiftBits = Math.log2(cs) | 0;
      this._coordMask = cs - 1 | 0;
      this._coordsToChunkIndexes = chunkCoordsToIndexesPowerOfTwo;
      this._coordsToChunkLocals = chunkCoordsToLocalsPowerOfTwo;
    }
  }
};
World.prototype.getBlockID = function(x = 0, y = 0, z = 0) {
  var [ci, cj, ck] = this._coordsToChunkIndexes(x, y, z);
  var chunk = this._storage.getChunkByIndexes(ci, cj, ck);
  if (!chunk) return 0;
  var [i, j, k] = this._coordsToChunkLocals(x, y, z);
  return chunk.voxels.get(i, j, k);
};
World.prototype.getBlockSolidity = function(x = 0, y = 0, z = 0) {
  var [ci, cj, ck] = this._coordsToChunkIndexes(x, y, z);
  var chunk = this._storage.getChunkByIndexes(ci, cj, ck);
  if (!chunk) return false;
  var [i, j, k] = this._coordsToChunkLocals(x, y, z);
  return !!chunk.getSolidityAt(i, j, k);
};
World.prototype.getBlockOpacity = function(x = 0, y = 0, z = 0) {
  var id = this.getBlockID(x, y, z);
  return this.noa.registry.getBlockOpacity(id);
};
World.prototype.getBlockFluidity = function(x = 0, y = 0, z = 0) {
  var id = this.getBlockID(x, y, z);
  return this.noa.registry.getBlockFluidity(id);
};
World.prototype.getBlockProperties = function(x = 0, y = 0, z = 0) {
  var id = this.getBlockID(x, y, z);
  return this.noa.registry.getBlockProps(id);
};
World.prototype.setBlockID = function(id = 0, x = 0, y = 0, z = 0) {
  var [ci, cj, ck] = this._coordsToChunkIndexes(x, y, z);
  var chunk = this._storage.getChunkByIndexes(ci, cj, ck);
  if (!chunk) return;
  var [i, j, k] = this._coordsToChunkLocals(x, y, z);
  return chunk.set(i, j, k, id);
};
World.prototype.isBoxUnobstructed = function(box) {
  var base = box.base;
  var max2 = box.max;
  for (var i = Math.floor(base[0]); i < max2[0] + 1; i++) {
    for (var j = Math.floor(base[1]); j < max2[1] + 1; j++) {
      for (var k = Math.floor(base[2]); k < max2[2] + 1; k++) {
        if (this.getBlockSolidity(i, j, k)) return false;
      }
    }
  }
  return true;
};
World.prototype.setChunkData = function(id, array, userData = null, fillVoxelID = -1) {
  setChunkData(this, id, array, userData, fillVoxelID);
};
World.prototype.setAddRemoveDistance = function(addDist = 2, remDist = 3) {
  var addArr = Array.isArray(addDist) ? addDist : [addDist, addDist];
  var remArr = Array.isArray(remDist) ? remDist : [remDist, remDist];
  var minGap = 1;
  if (remArr[0] < addArr[0] + minGap) remArr[0] = addArr[0] + minGap;
  if (remArr[1] < addArr[1] + minGap) remArr[1] = addArr[1] + minGap;
  this._chunkAddDistance = addArr;
  this._chunkRemoveDistance = remArr;
  this._addDistanceFn = makeDistanceTestFunction(addArr[0], addArr[1]);
  this._remDistanceFn = makeDistanceTestFunction(remArr[0], remArr[1]);
  this._chunksSortedLocs.empty();
  for (var i = 0; i <= addArr[0]; i++) {
    for (var k = 0; k <= i; k++) {
      for (var j = 0; j <= addArr[1]; j++) {
        if (!this._addDistanceFn(i, j, k)) continue;
        this._chunksSortedLocs.add(i, j, k);
      }
    }
  }
  this._prevSortingFn = null;
  this._chunkAddSearchFrom = 0;
};
World.prototype.invalidateVoxelsInAABB = function(box) {
  invalidateChunksInBox(this, box);
};
World.prototype.manuallyLoadChunk = function(x = 0, y = 0, z = 0) {
  if (!this.manuallyControlChunkLoading) throw manualErr;
  var [i, j, k] = this._coordsToChunkIndexes(x, y, z);
  this._chunksKnown.add(i, j, k);
  this._chunksToRequest.add(i, j, k);
};
World.prototype.manuallyUnloadChunk = function(x = 0, y = 0, z = 0) {
  if (!this.manuallyControlChunkLoading) throw manualErr;
  var [i, j, k] = this._coordsToChunkIndexes(x, y, z);
  this._chunksToRemove.add(i, j, k);
  this._chunksToMesh.remove(i, j, k);
  this._chunksToRequest.remove(i, j, k);
  this._chunksToMeshFirst.remove(i, j, k);
};
var manualErr = "Set `noa.world.manuallyControlChunkLoading` if you need this API";
World.prototype.tick = function() {
  var tickStartTime = performance.now();
  var [ci, cj, ck] = getPlayerChunkIndexes(this);
  var chunkLocHash = locationHasher(ci, cj, ck);
  var changedChunks = chunkLocHash !== this._prevPlayerChunkHash;
  if (changedChunks) {
    this.emit("playerEnteredChunk", ci, cj, ck);
    this._prevPlayerChunkHash = chunkLocHash;
    this._chunkAddSearchFrom = 0;
  }
  if (this._prevWorldName !== this.noa.worldName) {
    if (!this.manuallyControlChunkLoading) {
      markAllChunksInvalid(this);
      this._chunkAddSearchFrom = 0;
      processRemoveQueue(this);
    }
    this._prevWorldName = this.noa.worldName;
  }
  profile_hook4("start");
  profile_queues_hook("start");
  if (!this.manuallyControlChunkLoading) {
    findDistantChunksToRemove(this, ci, cj, ck);
    profile_hook4("remQueue");
    findChunksToRequest(this, ci, cj, ck);
    profile_hook4("addQueue");
  }
  findChunksToMesh(this);
  var t = performance.now();
  var t1 = tickStartTime + (this.maxProcessingPerTick || 0);
  if (t < t1) t1 = t + 1;
  var done1 = false;
  var done2 = false;
  var done3 = false;
  while (t < t1) {
    if (!done1) {
      done1 = processRemoveQueue(this) || processRemoveQueue(this);
      profile_hook4("removes");
    }
    if (!done2) {
      done2 = processRequestQueue(this);
      profile_hook4("requests");
    }
    if (!done3) {
      done3 = processMeshingQueue(this, false);
      profile_hook4("meshes");
    }
    if (done1 && done2 && done3) break;
    t = performance.now();
  }
  var pChunk = this._storage.getChunkByIndexes(ci, cj, ck);
  this.playerChunkLoaded = !!pChunk;
  profile_queues_hook("end", this);
  profile_hook4("end");
};
World.prototype.render = function() {
  var t = performance.now();
  var t1 = t + this.maxProcessingPerRender;
  while (t < t1) {
    var done = processMeshingQueue(this, true);
    if (done) break;
    t = performance.now();
  }
};
World.prototype._getChunkByCoords = function(x = 0, y = 0, z = 0) {
  var [i, j, k] = this._coordsToChunkIndexes(x, y, z);
  return this._storage.getChunkByIndexes(i, j, k);
};
World.prototype._queueChunkForRemesh = function(chunk) {
  possiblyQueueChunkForMeshing(this, chunk);
};
function getPlayerChunkIndexes(world) {
  var [x, y, z] = world.noa.entities.getPosition(world.noa.playerEntity);
  return world._coordsToChunkIndexes(x, y, z);
}
function findChunksToRequest(world, ci, cj, ck) {
  var toRequest = world._chunksToRequest;
  var numQueued = toRequest.count();
  var maxQueued = 50;
  if (numQueued >= maxQueued) return;
  var sortDistFn = world.chunkSortingDistFn || defaultSortDistance;
  if (sortDistFn !== world._prevSortingFn) {
    sortQueueByDistanceFrom(world, world._chunksSortedLocs, 0, 0, 0, true);
    world._prevSortingFn = sortDistFn;
  }
  var locsArr = world._chunksSortedLocs.arr;
  var ix = world._chunkAddSearchFrom;
  var maxIter = Math.min(20, locsArr.length / 10);
  for (var ct = 0; ct < maxIter; ct++) {
    var [di, dj, dk] = locsArr[ix++ % locsArr.length];
    checkReflectedLocations(world, ci, cj, ck, di, dj, dk);
    if (toRequest.count() >= maxQueued) break;
  }
  if (world._chunksInvalidated.isEmpty()) {
    world._chunkAddSearchFrom = ix % locsArr.length;
  }
  sortQueueByDistanceFrom(world, toRequest, ci, cj, ck, false);
}
var checkReflectedLocations = (world, ci, cj, ck, i, j, k) => {
  checkOneLocation(world, ci + i, cj + j, ck + k);
  if (i !== k) checkOneLocation(world, ci + k, cj + j, ck + i);
  if (i > 0) checkReflectedLocations(world, ci, cj, ck, -i, j, k);
  if (j > 0) checkReflectedLocations(world, ci, cj, ck, i, -j, k);
  if (k > 0) checkReflectedLocations(world, ci, cj, ck, i, j, -k);
};
var checkOneLocation = (world, i, j, k) => {
  if (world._chunksKnown.includes(i, j, k)) return;
  world._chunksKnown.add(i, j, k);
  world._chunksToRequest.add(i, j, k, true);
};
function findDistantChunksToRemove(world, ci, cj, ck) {
  var distCheck = world._remDistanceFn;
  var toRemove = world._chunksToRemove;
  var numQueued = toRemove.count() + world._chunksInvalidated.count();
  var maxQueued = 50;
  if (numQueued >= maxQueued) return;
  var knownArr = world._chunksKnown.arr;
  if (knownArr.length === 0) return;
  var maxIter = Math.min(100, knownArr.length / 10);
  var found = false;
  for (var ct = 0; ct < maxIter; ct++) {
    var [i, j, k] = knownArr[removeCheckIndex++ % knownArr.length];
    if (toRemove.includes(i, j, k)) continue;
    if (distCheck(i - ci, j - cj, k - ck)) continue;
    world._chunksToRemove.add(i, j, k);
    world._chunksToRequest.remove(i, j, k);
    world._chunksToMesh.remove(i, j, k);
    world._chunksToMeshFirst.remove(i, j, k);
    found = true;
    numQueued++;
    if (numQueued > maxQueued) break;
  }
  removeCheckIndex = removeCheckIndex % knownArr.length;
  if (found) sortQueueByDistanceFrom(world, toRemove, ci, cj, ck);
}
var removeCheckIndex = 0;
function findChunksToMesh(world) {
  var maxQueued = 10;
  var numQueued = world._chunksToMesh.count() + world._chunksToMeshFirst.count();
  if (numQueued > maxQueued) return;
  var knownArr = world._chunksKnown.arr;
  var maxIter = Math.min(50, knownArr.length / 10);
  for (var ct = 0; ct < maxIter; ct++) {
    var [i, j, k] = knownArr[meshCheckIndex++ % knownArr.length];
    var chunk = world._storage.getChunkByIndexes(i, j, k);
    if (!chunk) continue;
    var res = possiblyQueueChunkForMeshing(world, chunk);
    if (res) numQueued++;
    if (numQueued > maxQueued) break;
  }
  meshCheckIndex %= knownArr.length;
}
var meshCheckIndex = 0;
function invalidateChunksInBox(world, box) {
  var min2 = world._coordsToChunkIndexes(box.base[0], box.base[1], box.base[2]);
  var max2 = world._coordsToChunkIndexes(box.max[0], box.max[1], box.max[2]);
  for (var i = 0; i < 3; i++) {
    if (!Number.isFinite(box.base[i])) min2[i] = box.base[i];
    if (!Number.isFinite(box.max[i])) max2[i] = box.max[i];
  }
  world._chunksKnown.forEach((loc) => {
    var [i2, j, k] = loc;
    if (i2 < min2[0] || i2 >= max2[0]) return;
    if (j < min2[1] || j >= max2[1]) return;
    if (k < min2[2] || k >= max2[2]) return;
    world._chunksInvalidated.add(i2, j, k);
    world._chunksToRemove.remove(i2, j, k);
    world._chunksToRequest.remove(i2, j, k);
    world._chunksToMesh.remove(i2, j, k);
    world._chunksToMeshFirst.remove(i2, j, k);
  });
}
function markAllChunksInvalid(world) {
  world._chunksInvalidated.copyFrom(world._chunksKnown);
  world._chunksToRemove.empty();
  world._chunksToRequest.empty();
  world._chunksToMesh.empty();
  world._chunksToMeshFirst.empty();
  sortQueueByDistanceFrom(world, world._chunksInvalidated);
}
function processRequestQueue(world) {
  var toRequest = world._chunksToRequest;
  if (toRequest.isEmpty()) return true;
  var pending = world._chunksPending.count();
  var toMesh = world._chunksToMesh.count();
  if (pending >= world.maxChunksPendingCreation) return true;
  if (toMesh >= world.maxChunksPendingMeshing) return true;
  var [i, j, k] = toRequest.pop();
  requestNewChunk(world, i, j, k);
  return toRequest.isEmpty();
}
function processRemoveQueue(world) {
  var queue = world._chunksInvalidated;
  if (queue.isEmpty()) queue = world._chunksToRemove;
  if (queue.isEmpty()) return true;
  var [i, j, k] = queue.pop();
  removeChunk(world, i, j, k);
  return queue.isEmpty();
}
function processMeshingQueue(world, firstOnly) {
  var queue = world._chunksToMeshFirst;
  if (queue.isEmpty() && !firstOnly) queue = world._chunksToMesh;
  if (queue.isEmpty()) return true;
  var [i, j, k] = queue.pop();
  if (world._chunksToRemove.includes(i, j, k)) return;
  var chunk = world._storage.getChunkByIndexes(i, j, k);
  if (chunk) doChunkRemesh(world, chunk);
}
function possiblyQueueChunkForMeshing(world, chunk) {
  if (!(chunk._terrainDirty || chunk._objectsDirty)) return false;
  if (chunk._neighborCount < chunk.minNeighborsToMesh) return false;
  if (world._chunksToMesh.includes(chunk.i, chunk.j, chunk.k)) return false;
  if (world._chunksToMeshFirst.includes(chunk.i, chunk.j, chunk.k)) return false;
  var queue = chunk._neighborCount === 26 ? world._chunksToMeshFirst : world._chunksToMesh;
  queue.add(chunk.i, chunk.j, chunk.k);
  world._sortMeshQueueEvery++;
  if (world._sortMeshQueueEvery > 20) {
    sortQueueByDistanceFrom(world, queue);
    world._sortMeshQueueEvery = 0;
  }
  return true;
}
function requestNewChunk(world, i, j, k) {
  var size = world._chunkSize;
  var dataArr = Chunk._createVoxelArray(world._chunkSize);
  var worldName = world.noa.worldName;
  var requestID = [i, j, k, worldName].join("|");
  var x = i * size;
  var y = j * size;
  var z = k * size;
  world._chunksPending.add(i, j, k);
  world.emit("worldDataNeeded", requestID, dataArr, x, y, z, worldName);
  profile_queues_hook("request");
}
function setChunkData(world, reqID, array, userData, fillVoxelID) {
  var arr = reqID.split("|");
  var i = parseInt(arr.shift());
  var j = parseInt(arr.shift());
  var k = parseInt(arr.shift());
  var worldName = arr.join("|");
  world._chunksPending.remove(i, j, k);
  if (worldName !== world.noa.worldName) return;
  if (!world._chunksKnown.includes(i, j, k)) return;
  if (world._chunksToRemove.includes(i, j, k)) return;
  var chunk = world._storage.getChunkByIndexes(i, j, k);
  if (!chunk) {
    var size = world._chunkSize;
    chunk = new Chunk(world.noa, reqID, i, j, k, size, array, fillVoxelID);
    world._storage.storeChunkByIndexes(i, j, k, chunk);
    chunk.userData = userData;
    world.noa.rendering.prepareChunkForRendering(chunk);
    world.emit("chunkAdded", chunk);
  } else {
    chunk._updateVoxelArray(array, fillVoxelID);
  }
  possiblyQueueChunkForMeshing(world, chunk);
  updateNeighborsOfChunk(world, i, j, k, chunk);
  profile_queues_hook("receive");
}
function removeChunk(world, i, j, k) {
  var chunk = world._storage.getChunkByIndexes(i, j, k);
  if (chunk) {
    world.emit("chunkBeingRemoved", chunk.requestID, chunk.voxels, chunk.userData);
    world.noa.rendering.disposeChunkForRendering(chunk);
    chunk.dispose();
    profile_queues_hook("dispose");
    updateNeighborsOfChunk(world, i, j, k, null);
  }
  world._storage.removeChunkByIndexes(i, j, k);
  world._chunksKnown.remove(i, j, k);
  world._chunksToMesh.remove(i, j, k);
  world._chunksToRemove.remove(i, j, k);
  world._chunksToMeshFirst.remove(i, j, k);
}
function doChunkRemesh(world, chunk) {
  world._chunksToMesh.remove(chunk.i, chunk.j, chunk.k);
  world._chunksToMeshFirst.remove(chunk.i, chunk.j, chunk.k);
  chunk.updateMeshes();
  profile_queues_hook("mesh");
}
function chunkCoordsToIndexesGeneral(x, y, z) {
  var cs = this._chunkSize;
  return [Math.floor(x / cs) | 0, Math.floor(y / cs) | 0, Math.floor(z / cs) | 0];
}
function chunkCoordsToLocalsGeneral(x, y, z) {
  var cs = this._chunkSize;
  var i = x % cs | 0;
  if (i < 0) i += cs;
  var j = y % cs | 0;
  if (j < 0) j += cs;
  var k = z % cs | 0;
  if (k < 0) k += cs;
  return [i, j, k];
}
function chunkCoordsToIndexesPowerOfTwo(x, y, z) {
  var shift = this._coordShiftBits;
  return [x >> shift | 0, y >> shift | 0, z >> shift | 0];
}
function chunkCoordsToLocalsPowerOfTwo(x, y, z) {
  var mask = this._coordMask;
  return [x & mask | 0, y & mask | 0, z & mask | 0];
}
function sortQueueByDistanceFrom(world, queue, pi, pj, pk, reverse = false) {
  var distFn = world.chunkSortingDistFn || defaultSortDistance;
  var localDist = (i, j, k) => distFn(pi - i, pj - j, pk - k);
  if (pi === void 0) {
    [pi, pj, pk] = getPlayerChunkIndexes(world);
  }
  queue.sortByDistance(localDist, reverse);
}
var defaultSortDistance = (i, j, k) => i * i + j * j + k * k;
function updateNeighborsOfChunk(world, ci, cj, ck, chunk) {
  var terrainChanged = !chunk || chunk && !chunk.isEmpty;
  for (var i = -1; i <= 1; i++) {
    for (var j = -1; j <= 1; j++) {
      for (var k = -1; k <= 1; k++) {
        if ((i | j | k) === 0) continue;
        var neighbor = world._storage.getChunkByIndexes(ci + i, cj + j, ck + k);
        if (!neighbor) continue;
        if (terrainChanged) neighbor._terrainDirty = true;
        if (chunk && !chunk._neighbors.get(i, j, k)) {
          chunk._neighborCount++;
          chunk._neighbors.set(i, j, k, neighbor);
        }
        var nabRef = neighbor._neighbors.get(-i, -j, -k);
        if (chunk && !nabRef) {
          neighbor._neighborCount++;
          neighbor._neighbors.set(-i, -j, -k, chunk);
          if (neighbor._neighborCount === 26) {
            possiblyQueueChunkForMeshing(world, neighbor);
          }
        }
        if (!chunk && nabRef) {
          neighbor._neighborCount--;
          neighbor._neighbors.set(-i, -j, -k, null);
        }
      }
    }
  }
}
function makeDistanceTestFunction(xsize, ysize) {
  var asq = xsize * xsize;
  var bsq = ysize * ysize;
  if (xsize === ysize) return (i, j, k) => i * i + j * j + k * k <= asq;
  if (xsize > ysize) return (i, j, k) => {
    if (Math.abs(j) > ysize) return false;
    return i * i + j * j + k * k <= asq;
  };
  return (i, j, k) => {
    var dxsq = i * i + k * k;
    if (dxsq > asq) return false;
    return dxsq + j * j <= bsq;
  };
}
World.prototype.report = function() {
  console.log("World report - playerChunkLoaded: ", this.playerChunkLoaded);
  _report(this, "  known:     ", this._chunksKnown.arr, true);
  _report(this, "  to request:", this._chunksToRequest.arr, 0);
  _report(this, "  to remove: ", this._chunksToRemove.arr, 0);
  _report(this, "  invalid:   ", this._chunksInvalidated.arr, 0);
  _report(this, "  creating:  ", this._chunksPending.arr, 0);
  _report(this, "  to mesh:   ", this._chunksToMesh.arr, 0);
  _report(this, "  mesh 1st:  ", this._chunksToMeshFirst.arr, 0);
};
function _report(world, name, arr, ext) {
  var full = 0, empty = 0, exist = 0, surrounded = 0, remeshes = [];
  arr.forEach((loc) => {
    var chunk = world._storage.getChunkByIndexes(loc[0], loc[1], loc[2]);
    if (!chunk) return;
    exist++;
    remeshes.push(chunk._timesMeshed);
    if (chunk._isFull) full++;
    if (chunk._isEmpty) empty++;
    if (chunk._neighborCount === 26) surrounded++;
  });
  var out = arr.length.toString().padEnd(8);
  out += ("exist: " + exist).padEnd(12);
  out += ("full: " + full).padEnd(12);
  out += ("empty: " + empty).padEnd(12);
  out += ("surr: " + surrounded).padEnd(12);
  if (ext) {
    var sum = remeshes.reduce((acc, val) => acc + val, 0);
    var max2 = remeshes.reduce((acc, val) => Math.max(acc, val), 0);
    var min2 = remeshes.reduce((acc, val) => Math.min(acc, val), 0);
    out += "times meshed: avg " + (sum / exist).toFixed(2);
    out += "  max " + max2;
    out += "  min " + min2;
  }
  console.log(name, out);
}
var profile_hook4 = makeProfileHook(PROFILE_EVERY2, "world ticks:", 1);
var profile_queues_hook = ((every) => {
  if (!(every > 0)) return () => {
  };
  var iter = 0;
  var counts = {};
  var queues = {};
  var started = performance.now();
  return function profile_queues_hook2(state, world) {
    if (state === "start") return;
    if (state !== "end") return counts[state] = (counts[state] || 0) + 1;
    queues.toreq = (queues.toreq || 0) + world._chunksToRequest.count();
    queues.toget = (queues.toget || 0) + world._chunksPending.count();
    queues.tomesh = (queues.tomesh || 0) + world._chunksToMesh.count() + world._chunksToMeshFirst.count();
    queues.tomesh1 = (queues.tomesh1 || 0) + world._chunksToMeshFirst.count();
    queues.torem = (queues.torem || 0) + world._chunksToRemove.count();
    if (++iter < every) return;
    var t = performance.now(), dt = t - started;
    var res = {};
    Object.keys(queues).forEach((k) => {
      var num = Math.round((queues[k] || 0) / iter);
      res[k] = `[${num}]`.padStart(5);
    });
    Object.keys(counts).forEach((k) => {
      var num = Math.round((counts[k] || 0) * 1e3 / dt);
      res[k] = ("" + num).padStart(3);
    });
    console.log(
      "chunk flow: ",
      `${res.toreq}-> ${res.request || 0} req/s  `,
      `${res.toget}-> ${res.receive || 0} got/s  `,
      `${res.tomesh}-> ${res.mesh || 0} mesh/s  `,
      `${res.torem}-> ${res.dispose || 0} rem/s  `,
      `(meshFirst: ${res.tomesh1.trim()})`
    );
    iter = 0;
    counts = {};
    queues = {};
    started = performance.now();
  };
})(PROFILE_QUEUES_EVERY);

// node_modules/noa-engine/package.json
var package_default2 = {
  name: "noa-engine",
  version: "0.33.0",
  description: "Experimental voxel game engine",
  main: "src/index.js",
  typings: "dist/src/index.d.ts",
  files: [
    "/src",
    "/dist"
  ],
  scripts: {
    build: "npm run types; npm run docs",
    types: "tsc",
    docs: "typedoc"
  },
  author: "Andy Hall (https://fenomas.com)",
  license: "MIT",
  repository: {
    type: "git",
    url: "https://github.com/fenomas/noa.git"
  },
  bugs: {
    url: "https://github.com/fenomas/noa/issues"
  },
  dependencies: {
    "aabb-3d": "fenomas/aabb-3d",
    "box-intersect": "fenomas/box-intersect",
    "ent-comp": "^0.11.0",
    events: "^3.3.0",
    "fast-voxel-raycast": "^0.1.1",
    "game-inputs": "^0.8.0",
    "gl-vec3": "^1.1.3",
    "micro-game-shell": "^0.9.0",
    ndarray: "^1.0.19",
    "voxel-aabb-sweep": "^0.5.0",
    "voxel-physics-engine": "^0.13.0"
  },
  peerDependencies: {
    "@babylonjs/core": "^6.1.0"
  },
  devDependencies: {
    eslint: "^8.3.0",
    "js-beautify": "^1.14.0",
    typedoc: "^0.24.6",
    "typedoc-plugin-missing-exports": "^2.0.0",
    typescript: "^5.0.4"
  },
  keywords: [
    "voxel",
    "voxels",
    "game",
    "engine",
    "game-engine"
  ]
};

// node_modules/noa-engine/src/index.js
var version2 = package_default2.version;
var PROFILE3 = 0;
var PROFILE_RENDER = 0;
var defaultOptions5 = {
  debug: false,
  silent: false,
  silentBabylon: false,
  playerHeight: 1.8,
  playerWidth: 0.6,
  playerStart: [0, 10, 0],
  playerAutoStep: false,
  playerShadowComponent: true,
  tickRate: 30,
  // ticks per second
  maxRenderRate: 0,
  // max FPS, 0 for uncapped 
  blockTestDistance: 10,
  stickyPointerLock: true,
  dragCameraOutsidePointerLock: true,
  stickyFullscreen: false,
  skipDefaultHighlighting: false,
  originRebaseDistance: 25
};
var Engine2 = class extends import_events4.EventEmitter {
  /**
   * The core Engine constructor uses the following options:
   * 
   * ```js
   * var defaultOptions = {
   *    debug: false,
   *    silent: false,
   *    playerHeight: 1.8,
   *    playerWidth: 0.6,
   *    playerStart: [0, 10, 0],
   *    playerAutoStep: false,
   *    playerShadowComponent: true,
   *    tickRate: 30,           // ticks per second
   *    maxRenderRate: 0,       // max FPS, 0 for uncapped 
   *    blockTestDistance: 10,
   *    stickyPointerLock: true,
   *    dragCameraOutsidePointerLock: true,
   *    stickyFullscreen: false,
   *    skipDefaultHighlighting: false,
   *    originRebaseDistance: 25,
   * }
   * ```
   * 
   * **Events:**
   *  + `tick => (dt)`  
   *    Tick update, `dt` is (fixed) tick duration in ms
   *  + `beforeRender => (dt)`  
   *    `dt` is the time (in ms) since the most recent tick
   *  + `afterRender => (dt)`  
   *    `dt` is the time (in ms) since the most recent tick
   *  + `targetBlockChanged => (blockInfo)`  
   *    Emitted each time the user's targeted world block changes
   *  + `addingTerrainMesh => (mesh)`  
   *    Alerts client about a terrain mesh being added to the scene
   *  + `removingTerrainMesh => (mesh)`  
   *    Alerts client before a terrain mesh is removed.
  */
  constructor(opts = {}) {
    super();
    opts = Object.assign({}, defaultOptions5, opts);
    this.version = version2;
    if (!opts.silent) {
      var debugstr = opts.debug ? " (debug)" : "";
      console.log(`noa-engine v${this.version}${debugstr}`);
    }
    this._paused = false;
    this._originRebaseDistance = opts.originRebaseDistance;
    this.worldOriginOffset = [0, 0, 0];
    this.positionInCurrentTick = 0;
    this.worldName = "default";
    this.timeScale = 1;
    this.container = new Container(this, opts);
    this.tickRate = this.container._shell.tickRate;
    Object.defineProperty(this, "tickRate", {
      get: () => this.container._shell.tickRate
    });
    this.maxRenderRate = this.container._shell.maxRenderRate;
    Object.defineProperty(this, "maxRenderRate", {
      get: () => this.container._shell.maxRenderRate,
      set: (v) => {
        this.container._shell.maxRenderRate = v || 0;
      }
    });
    this.inputs = new Inputs(this, opts, this.container.element);
    this.registry = new Registry(this, opts);
    this.world = new World(this, opts);
    var _consoleLog = console.log;
    if (opts.silentBabylon) console.log = () => {
    };
    this.rendering = new Rendering(this, opts, this.container.canvas);
    if (opts.silentBabylon) console.log = _consoleLog;
    this.physics = new Physics2(this, opts);
    this.entities = new Entities(this, opts);
    this.ents = this.entities;
    var ents = this.entities;
    this.playerEntity = ents.add(
      opts.playerStart,
      // starting location
      opts.playerWidth,
      opts.playerHeight,
      null,
      null,
      // no mesh for now, no meshOffset, 
      true,
      opts.playerShadowComponent
    );
    ents.addComponent(this.playerEntity, ents.names.collideTerrain);
    ents.addComponent(this.playerEntity, ents.names.collideEntities);
    var body = ents.getPhysics(this.playerEntity).body;
    body.gravityMultiplier = 2;
    body.autoStep = opts.playerAutoStep;
    ents.addComponent(this.playerEntity, ents.names.receivesInputs);
    ents.addComponent(this.playerEntity, ents.names.fadeOnZoom);
    ents.addComponent(this.playerEntity, ents.names.movement, {
      airJumps: 1
    });
    this.camera = new Camera(this, opts);
    this.blockTestDistance = opts.blockTestDistance;
    this.blockTargetIdCheck = this.registry.getBlockSolidity;
    this.targetedBlock = null;
    if (!opts.skipDefaultHighlighting) {
      this.defaultBlockHighlightFunction = (tgt) => {
        if (tgt) {
          this.rendering.highlightBlockFace(true, tgt.position, tgt.normal);
        } else {
          this.rendering.highlightBlockFace(false);
        }
      };
      this.on("targetBlockChanged", this.defaultBlockHighlightFunction);
    }
    this._terrainMesher = new TerrainMesher(this);
    this._objectMesher = new ObjectMesher(this);
    this._targetedBlockDat = {
      blockID: 0,
      position: import_gl_vec312.default.create(),
      normal: import_gl_vec312.default.create(),
      adjacent: import_gl_vec312.default.create()
    };
    this._prevTargetHash = 0;
    this._pickPos = import_gl_vec312.default.create();
    this._pickResult = {
      _localPosition: import_gl_vec312.default.create(),
      position: [0, 0, 0],
      normal: [0, 0, 0]
    };
    if (opts.debug) {
      this.vec3 = import_gl_vec312.default;
      this.ndarray = import_ndarray3.default;
      ents.getMovement(1).airJumps = 999;
      var win = (
        /** @type {any} */
        window
      );
      win.noa = this;
      win.vec3 = import_gl_vec312.default;
      win.ndarray = import_ndarray3.default;
      win.scene = this.rendering.scene;
    }
    deprecateStuff(this);
  }
  /*
   *
   *
   *              Core Engine APIs
   *
   *
  */
  /**
   * Tick function, called by container module at a fixed timestep. 
   * Clients should not normally need to call this manually.
   * @internal
  */
  tick(dt) {
    dt *= this.timeScale || 1;
    if (this._paused) {
      if (this.world.worldGenWhilePaused) this.world.tick();
      return;
    }
    profile_hook5("start");
    checkWorldOffset(this);
    this.world.tick();
    profile_hook5("world");
    if (!this.world.playerChunkLoaded) {
      this.rendering.tick(dt);
      return;
    }
    this.physics.tick(dt);
    profile_hook5("physics");
    this._objectMesher.tick();
    this.rendering.tick(dt);
    profile_hook5("rendering");
    updateBlockTargets(this);
    profile_hook5("targets");
    this.entities.tick(dt);
    profile_hook5("entities");
    this.emit("tick", dt);
    profile_hook5("tick event");
    profile_hook5("end");
    var pst = this.inputs.pointerState;
    pst.scrollx = pst.scrolly = pst.scrollz = 0;
  }
  /**
   * Render function, called every animation frame. Emits #beforeRender(dt), #afterRender(dt) 
   * where dt is the time in ms *since the last tick*.
   * Clients should not normally need to call this manually.
   * @internal
  */
  render(dt, framePart) {
    dt *= this.timeScale || 1;
    this.positionInCurrentTick = framePart;
    if (this._paused) {
      if (this.world.worldGenWhilePaused) this.world.render();
      return;
    }
    profile_hook_render("start");
    this.camera.applyInputsToCamera();
    profile_hook_render("init");
    this.world.render();
    profile_hook_render("meshing");
    this.camera.updateBeforeEntityRenderSystems();
    this.entities.render(dt);
    this.camera.updateAfterEntityRenderSystems();
    profile_hook_render("entities");
    this.emit("beforeRender", dt);
    profile_hook_render("before render");
    this.rendering.render();
    this.rendering.postRender();
    profile_hook_render("render");
    this.emit("afterRender", dt);
    profile_hook_render("after render");
    profile_hook_render("end");
    this.inputs.pointerState.dx = this.inputs.pointerState.dy = 0;
  }
  /** Pausing the engine will also stop render/tick events, etc. */
  setPaused(paused = false) {
    this._paused = !!paused;
    if (!paused) {
      this.inputs.pointerState.dx = this.inputs.pointerState.dy = 0;
    }
  }
  /** 
   * Get the voxel ID at the specified position
  */
  getBlock(x, y = 0, z = 0) {
    if (x.length) return this.world.getBlockID(x[0], x[1], x[2]);
    return this.world.getBlockID(x, y, z);
  }
  /** 
   * Sets the voxel ID at the specified position. 
   * Does not check whether any entities are in the way! 
   */
  setBlock(id, x, y = 0, z = 0) {
    if (x.length) return this.world.setBlockID(id, x[0], x[1], x[2]);
    return this.world.setBlockID(id, x, y, z);
  }
  /**
   * Adds a block, unless there's an entity in the way.
  */
  addBlock(id, x, y = 0, z = 0) {
    if (x.length) {
      if (this.entities.isTerrainBlocked(x[0], x[1], x[2])) return;
      this.world.setBlockID(id, x[0], x[1], x[2]);
      return id;
    } else {
      if (this.entities.isTerrainBlocked(x, y, z)) return;
      this.world.setBlockID(id, x, y, z);
      return id;
    }
  }
  /*
   *              Rebasing local <-> global coords
  */
  /** 
   * Precisely converts a world position to the current internal 
   * local frame of reference.
   * 
   * See `/docs/positions.md` for more info.
   * 
   * Params: 
   *  * `global`: input position in global coords
   *  * `globalPrecise`: (optional) sub-voxel offset to the global position
   *  * `local`: output array which will receive the result
   */
  globalToLocal(global2, globalPrecise, local2) {
    var off = this.worldOriginOffset;
    if (globalPrecise) {
      for (var i = 0; i < 3; i++) {
        var coord = global2[i] - off[i];
        coord += globalPrecise[i];
        local2[i] = coord;
      }
      return local2;
    } else {
      return import_gl_vec312.default.subtract(local2, global2, off);
    }
  }
  /** 
   * Precisely converts a world position to the current internal 
   * local frame of reference.
   * 
   * See `/docs/positions.md` for more info.
   * 
   * Params: 
   *  * `local`: input array of local coords
   *  * `global`: output array which receives the result
   *  * `globalPrecise`: (optional) sub-voxel offset to the output global position
   * 
   * If both output arrays are passed in, `global` will get int values and 
   * `globalPrecise` will get fractional parts. If only one array is passed in,
   * `global` will get the whole output position.
  */
  localToGlobal(local2, global2, globalPrecise = null) {
    var off = this.worldOriginOffset;
    if (globalPrecise) {
      for (var i = 0; i < 3; i++) {
        var floored = Math.floor(local2[i]);
        global2[i] = floored + off[i];
        globalPrecise[i] = local2[i] - floored;
      }
      return global2;
    } else {
      return import_gl_vec312.default.add(global2, local2, off);
    }
  }
  /*
   *              Picking / raycasting
  */
  /**
   * Raycast through the world, returning a result object for any non-air block
   * 
   * See `/docs/positions.md` for info on working with precise positions.
   * 
   * @param {number[]} pos where to pick from (default: player's eye pos)
   * @param {number[]} dir direction to pick along (default: camera vector)
   * @param {number} dist pick distance (default: `noa.blockTestDistance`)
   * @param {(id:number) => boolean} blockTestFunction which voxel IDs can be picked (default: any solid voxel)
  */
  pick(pos = null, dir = null, dist2 = -1, blockTestFunction = null) {
    if (dist2 === 0) return null;
    var pickPos = this._pickPos;
    if (pos) {
      this.globalToLocal(pos, null, pickPos);
      pos = pickPos;
    }
    return this._localPick(pos, dir, dist2, blockTestFunction);
  }
  /**
   * @internal
   * Do a raycast in local coords. 
   * See `/docs/positions.md` for more info.
   * @param {number[]} pos where to pick from (default: player's eye pos)
   * @param {number[]} dir direction to pick along (default: camera vector)
   * @param {number} dist pick distance (default: `noa.blockTestDistance`)
   * @param {(id:number) => boolean} blockTestFunction which voxel IDs can be picked (default: any solid voxel)
   * @returns { null | {
   *      position: number[],
   *      normal: number[],
   *      _localPosition: number[],
   * }}
   */
  _localPick(pos = null, dir = null, dist2 = -1, blockTestFunction = null) {
    if (dist2 === 0) return null;
    var testFn = blockTestFunction || this.registry.getBlockSolidity;
    var world = this.world;
    var off = this.worldOriginOffset;
    var testVoxel = function(x, y, z) {
      var id = world.getBlockID(x + off[0], y + off[1], z + off[2]);
      return testFn(id);
    };
    if (!pos) pos = this.camera._localGetTargetPosition();
    dir = dir || this.camera.getDirection();
    dist2 = dist2 || -1;
    if (dist2 < 0) dist2 = this.blockTestDistance;
    var result = this._pickResult;
    var rpos = result._localPosition;
    var rnorm = result.normal;
    var hit = (0, import_fast_voxel_raycast.default)(testVoxel, pos, dir, dist2, rpos, rnorm);
    if (!hit) return null;
    import_gl_vec312.default.scaleAndAdd(rpos, rpos, rnorm, 0.01);
    this.localToGlobal(rpos, result.position);
    return result;
  }
};
function checkWorldOffset(noa) {
  var lpos = noa.ents.getPositionData(noa.playerEntity)._localPosition;
  var cutoff = noa._originRebaseDistance;
  if (import_gl_vec312.default.sqrLen(lpos) < cutoff * cutoff) return;
  var delta = [];
  for (var i = 0; i < 3; i++) {
    delta[i] = Math.floor(lpos[i]);
    noa.worldOriginOffset[i] += delta[i];
  }
  noa.rendering._rebaseOrigin(delta);
  noa.entities._rebaseOrigin(delta);
  noa._objectMesher._rebaseOrigin(delta);
}
function updateBlockTargets(noa) {
  var newhash = 0;
  var blockIdFn = noa.blockTargetIdCheck || noa.registry.getBlockSolidity;
  var result = noa._localPick(null, null, null, blockIdFn);
  if (result) {
    var dat = noa._targetedBlockDat;
    import_gl_vec312.default.floor(dat.adjacent, result.position);
    import_gl_vec312.default.copy(dat.normal, result.normal);
    import_gl_vec312.default.subtract(dat.position, dat.adjacent, dat.normal);
    dat.blockID = noa.world.getBlockID(dat.position[0], dat.position[1], dat.position[2]);
    noa.targetedBlock = dat;
    var pos = dat.position, norm = dat.normal;
    var x = locationHasher(pos[0] + dat.blockID, pos[1], pos[2]);
    x ^= locationHasher(norm[0], norm[1] + dat.blockID, norm[2]);
    newhash = x;
  } else {
    noa.targetedBlock = null;
  }
  if (newhash != noa._prevTargetHash) {
    noa.emit("targetBlockChanged", noa.targetedBlock);
    noa._prevTargetHash = newhash;
  }
}
function deprecateStuff(noa) {
  var ver = `0.27`;
  var dep = (loc, name, msg) => {
    var throwFn = () => {
      throw `This property changed in ${ver} - ${msg}`;
    };
    Object.defineProperty(loc, name, { get: throwFn, set: throwFn });
  };
  dep(noa, "getPlayerEyePosition", "to get the camera/player offset see API docs for `noa.camera.cameraTarget`");
  dep(noa, "setPlayerEyePosition", "to set the camera/player offset see API docs for `noa.camera.cameraTarget`");
  dep(noa, "getPlayerPosition", "use `noa.ents.getPosition(noa.playerEntity)` or similar");
  dep(noa, "getCameraVector", "use `noa.camera.getDirection`");
  dep(noa, "getPlayerMesh", "use `noa.ents.getMeshData(noa.playerEntity).mesh` or similar");
  dep(noa, "playerBody", "use `noa.ents.getPhysicsBody(noa.playerEntity)`");
  dep(noa.rendering, "zoomDistance", "use `noa.camera.zoomDistance`");
  dep(noa.rendering, "_currentZoom", "use `noa.camera.currentZoom`");
  dep(noa.rendering, "_cameraZoomSpeed", "use `noa.camera.zoomSpeed`");
  dep(noa.rendering, "getCameraVector", "use `noa.camera.getDirection`");
  dep(noa.rendering, "getCameraPosition", "use `noa.camera.getLocalPosition`");
  dep(noa.rendering, "getCameraRotation", "use `noa.camera.heading` and `noa.camera.pitch`");
  dep(noa.rendering, "setCameraRotation", "to customize camera behavior see API docs for `noa.camera`");
  ver = "0.28";
  dep(noa.rendering, "makeMeshInstance", "removed, use Babylon's `mesh.createInstance`");
  dep(noa.world, "_maxChunksPendingCreation", 'use `maxChunksPendingCreation` (no "_")');
  dep(noa.world, "_maxChunksPendingMeshing", 'use `maxChunksPendingMeshing` (no "_")');
  dep(noa.world, "_maxProcessingPerTick", 'use `maxProcessingPerTick` (no "_")');
  dep(noa.world, "_maxProcessingPerRender", 'use `maxProcessingPerRender` (no "_")');
  ver = "0.29";
  dep(noa, "_constants", "removed, voxel IDs are no longer packed with bit flags");
  ver = "0.30";
  dep(noa, "_tickRate", "tickRate is now at `noa.tickRate`");
  dep(noa.container, "_tickRate", "tickRate is now at `noa.tickRate`");
  ver = "0.31";
  dep(noa.world, "chunkSize", "effectively an internal, so changed to `_chunkSize`");
  dep(noa.world, "chunkAddDistance", "set this with `noa.world.setAddRemoveDistance`");
  dep(noa.world, "chunkRemoveDistance", "set this with `noa.world.setAddRemoveDistance`");
  ver = "0.33";
  dep(noa.rendering, "postMaterialCreationHook", "Removed - use mesh post-creation hook instead`");
}
var profile_hook5 = PROFILE3 > 0 ? makeProfileHook(PROFILE3, "tick   ") : () => {
};
var profile_hook_render = PROFILE_RENDER > 0 ? makeProfileHook(PROFILE_RENDER, "render ") : () => {
};
export {
  Engine2 as Engine
};
/*! Bundled license information:

is-buffer/index.js:
  (*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

ent-comp/src/ECS.js:
  (*!
   * ent-comp: a light, *fast* Entity Component System in JS
   * @url      github.com/fenomas/ent-comp
   * @author   Andy Hall <andy@fenomas.com>
   * @license  MIT
  *)

is-buffer/index.js:
  (*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

noa-engine/src/index.js:
  (*!
   * noa: an experimental voxel game engine.
   * @url      github.com/fenomas/noa
   * @author   Andy Hall <andy@fenomas.com>
   * @license  MIT
   *)
*/
//# sourceMappingURL=noa-engine.js.map
